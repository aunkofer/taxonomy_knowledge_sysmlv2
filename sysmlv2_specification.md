```
An OMG®Systems Modeling Publication
```
# OMG Systems Modeling Language™

# (SysML®)

## Version 2.0 Beta 1

## Part 1: Language Specification

### _______________________________________________________________________________

**OMG Document Number:** ptc/2023-06-
**Date:** June 2023
**Standard document URL:** https://www.omg.org/spec/SysML/2.0/Language/
**Machine Readable File(s):** https://www.omg.org/spec/SysML/20230201/
**Normative:**
https://www.omg.org/spec/SysML/20230201/SysML.xmi
https://www.omg.org/spec/SysML/20230201/Systems-Library.kpar
https://www.omg.org/spec/SysML/20230201/Analysis-Domain-Libary.kpar
https://www.omg.org/spec/SysML/20230201/Cause-and-Effect-Domain-Library.kpar
https://www.omg.org/spec/SysML/20230201/Geometry-Domain-Library.kpar
https://www.omg.org/spec/SysML/20230201/Metadata-Domain-Library.kpar
https://www.omg.org/spec/SysML/20230201/Quantities-and-Units-Domain-Library.kpar
https://www.omg.org/spec/SysML/20230201/Requirement-Derivation-Domain-Library.kpar
https://www.omg.org/spec/SysML/20230201/SysML.json
**Non-normative:**
https://www.omg.org/spec/SysML/20230201/SimpleVehicleModel.sysml
**_______________________________________________________________________________**



Copyright © 2019-2023, 88solutions Corporation
Copyright © 2019-2023, Airbus
Copyright © 2019-2023, Aras Corporation
Copyright © 2019-2023, Association of Universities for Research in Astronomy (AURA)
Copyright © 2019-2023, BigLever Software
Copyright © 2019-2023, Boeing
Copyright © 2022-2023, Budapest University of Technology and Economics
Copyright © 2021-2023, Commissariat à l'énergie atomique et aux énergies alternatives (CEA)
Copyright © 2019-2023, Contact Software GmbH
Copyright © 2019-2023, Dassault Systèmes (No Magic)
Copyright © 2019-2023, DSC Corporation
Copyright © 2020-2023, DEKonsult
Copyright © 2020-2023, Delligatti Associates, LLC
Copyright © 2019-2023, The Charles Stark Draper Laboratory, Inc.
Copyright © 2020-2023, ESTACA
Copyright © 2023, Galois, Inc.
Copyright © 2019-2023, GfSE e.V.
Copyright © 2019-2023, George Mason University
Copyright © 2019-2023, IBM
Copyright © 2019-2023, Idaho National Laboratory
Copyright © 2019-2023, INCOSE
Copyright © 2019-2023, Intercax LLC
Copyright © 2019-2023, Jet Propulsion Laboratory (California Institute of Technology)
Copyright © 2019-2023, Kenntnis LLC
Copyright © 2020-2023, Kungliga Tekniska högskolon (KTH)
Copyright © 2019-2023, LightStreet Consulting LLC
Copyright © 2019-2023, Lockheed Martin Corporation
Copyright © 2019-2023, Maplesoft
Copyright © 2021-2023, MID GmbH
Copyright © 2020-2023, MITRE
Copyright © 2019-2023, Model Alchemy Consulting
Copyright © 2019-2023, Model Driven Solutions, Inc.
Copyright © 2019-2023, Model Foundry Pty. Ltd.
Copyright © 2023, Object Management Group, Inc.
Copyright © 2019-2023, On-Line Application Research Corporation (OAC)
Copyright © 2019-2023, oose Innovative Informatik eG
Copyright © 2019-2023, Østfold University College
Copyright © 2019-2023, PTC
Copyright © 2020-2023, Qualtech Systems, Inc.
Copyright © 2019-2023, SAF Consulting
Copyright © 2019-2023, Simula Research Laboratory AS
Copyright © 2019-2023, System Strategy, Inc.
Copyright © 2019-2023, Thematix Partners LLC
Copyright © 2019-2023, Tom Sawyer
Copyright © 2023, Tucson Embedded Systems, Inc.
Copyright © 2019-2023, Universidad de Cantabria
Copyright © 2019-2023, University of Alabama in Huntsville
Copyright © 2019-2023, University of Detroit Mercy
Copyright © 2019-2023, University of Kaiserslauten
Copyright © 2020-2023, Willert Software Tools GmbH (SodiusWillert)


### USE OF SPECIFICATION - TERMS, CONDITIONS & NOTICES

The material in this document details an Object Management Group specification in accordance with the
terms, conditions and notices set forth below. This document does not represent a commitment to
implement any portion of this specification in any companys products. The information contained in this
document is subject to change without notice.

LICENSES
The companies listed above have granted to the Object Management Group, Inc. (OMG) a nonexclusive,
royalty-free, paid up, worldwide license to copy and distribute this document and to modify this document
and distribute copies of the modified version. Each of the copyright holders listed above has agreed that
no person shall be deemed to have infringed the copyright in the included material of any such copyright
holder by reason of having used the specification set forth herein or having conformed any computer
software to the specification.
Subject to all of the terms and conditions below, the owners of the copyright in this specification hereby
grant you a fully-paid up, non-exclusive, nontransferable, perpetual, worldwide license (without the right to
sublicense), to use this specification to create and distribute software and special purpose specifications
that are based upon this specification, and to use, copy, and distribute this specification as provided
under the Copyright Act; provided that: (1) both the copyright notice identified above and this permission
notice appear on any copies of this specification; (2) the use of the specifications is for informational
purposes and will not be copied or posted on any network computer or broadcast in any media and will
not be otherwise resold or transferred for commercial purposes; and (3) no modifications are made to this
specification. This limited permission automatically terminates without notice if you breach any of these
terms or conditions. Upon termination, you will destroy immediately any copies of the specifications in
your possession or control.

PATENTS
The attention of adopters is directed to the possibility that compliance with or adoption of OMG
specifications may require use of an invention covered by patent rights. OMG shall not be responsible for
identifying patents for which a license may be required by any OMG specification, or for conducting legal
inquiries into the legal validity or scope of those patents that are brought to its attention. OMG
specifications are prospective and advisory only. Prospective users are responsible for protecting
themselves against liability for infringement of patents.

GENERAL USE RESTRICTIONS
Any unauthorized use of this specification may violate copyright laws, trademark laws, and
communications regulations and statutes. This document contains information which is protected by
copyright. All Rights Reserved. No part of this work covered by copyright herein may be reproduced or
used in any form or by any means--graphic, electronic, or mechanical, including photocopying, recording,
taping, or information storage and retrieval systems--without permission of the copyright owner.

DISCLAIMER OF WARRANTY
WHILE THIS PUBLICATION IS BELIEVED TO BE ACCURATE, IT IS PROVIDED "AS IS" AND MAY
CONTAIN ERRORS OR MISPRINTS. THE OBJECT MANAGEMENT GROUP AND THE COMPANIES
LISTED ABOVE MAKE NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO
THIS PUBLICATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF TITLE OR


### OWNERSHIP, IMPLIED WARRANTY OF MERCHANTABILITY OR WARRANTY OF FITNESS FOR A

### PARTICULAR PURPOSE OR USE. IN NO EVENT SHALL THE OBJECT MANAGEMENT GROUP OR

### ANY OF THE COMPANIES LISTED ABOVE BE LIABLE FOR ERRORS CONTAINED HEREIN OR FOR

### DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, RELIANCE OR COVER DAMAGES,

### INCLUDING LOSS OF PROFITS, REVENUE, DATA OR USE, INCURRED BY ANY USER OR ANY

### THIRD PARTY IN CONNECTION WITH THE FURNISHING, PERFORMANCE, OR USE OF THIS

### MATERIAL, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

The entire risk as to the quality and performance of software developed using this specification is borne
by you. This disclaimer of warranty constitutes an essential part of the license granted to you to use this
specification.

RESTRICTED RIGHTS LEGEND
Use, duplication or disclosure by the U.S. Government is subject to the restrictions set forth in
subparagraph (c) (1) (ii) of The Rights in Technical Data and Computer Software Clause at DFARS
252.227-7013 or in subparagraph (c)(1) and (2) of the Commercial Computer Software - Restricted Rights
clauses at 48 C.F.R. 52.227-19 or as specified in 48 C.F.R. 227-7202-2 of the DoD F.A.R. Supplement
and its successors, or as specified in 48 C.F.R. 12.212 of the Federal Acquisition Regulations and its
successors, as applicable. The specification copyright owners are as indicated above and may be
contacted through the Object Management Group, 109 Highland Avenue, Needham, MA 02494, U.S.A.

```
TRADEMARKS
```
CORBA®, CORBA logos®, FIBO®, Financial Industry Business Ontology®, Financial Instrument Global
Identifier®, IIOP®, IMM®, Model Driven Architecture®, MDA®, Object Management Group®, OMG®, OMG
Logo®, SoaML®, SOAML®, SysML®, UAF®, Unified Modeling Language™, UML®, UML Cube Logo®,
VSIPL®, and XMI®are registered trademarks of the Object Management Group, Inc.
For a complete list of trademarks, see:https://www.omg.org/legal/tm_list.htm. All other products or
company names mentioned are used for identification purposes only, and may be trademarks of their
respective owners.

COMPLIANCE
The copyright holders listed above acknowledge that the Object Management Group (acting itself or
through its designees) is and shall at all times be the sole entity that may authorize developers, suppliers
and sellers of computer software to use certification marks, trademarks or other special designations to
indicate compliance with these materials.
Software developed under the terms of this license may claim compliance or conformance with this
specification if and only if the software compliance is of a nature fully matching the applicable compliance
points as stated in the specification. Software developed only partially matching the applicable
compliance points may claim only that the software was based on this specification, but may not claim
compliance or conformance with this specification. In the event that testing suites are implemented or
approved by Object Management Group, Inc., software developed using this specification may claim
compliance or conformance with the specification only if the software satisfactorily completes the testing
suites.


### OMG’S ISSUE REPORTING PROCEDURE

All OMG specifications are subject to continuous review and improvement. As part of this process we
encourage readers to report any ambiguities, inconsistencies, or inaccuracies they may find by
completing the Issue Reporting Form listed on the main web pagehttps://www.omg.org, under
Documents, Report a Bug/Issue.


## Table of Contents














- 0 Preface.............................................................................................................................................................................................
- 1 Scope.................................................................................................................................................................................................
- 2 Conformance.....................................................................................................................................................................................
- 3 Normative References......................................................................................................................................................................
- 4 Terms and Definitions......................................................................................................................................................................
- 5 Symbols............................................................................................................................................................................................
- 6 Introduction.....................................................................................................................................................................................
   - 6.1 Document Overview...........................................................................................................................................................
   - 6.2 Document Organization......................................................................................................................................................
   - 6.3 Document Conventions.......................................................................................................................................................
   - 6.4 Acknowlegements...............................................................................................................................................................
- 7 Language Description.....................................................................................................................................................................
   - 7.1 Language Overview............................................................................................................................................................
   - 7.2 Elements and Relationships................................................................................................................................................
      - 7.2.1 Elements and Relationships Overview....................................................................................................................
      - 7.2.2 Elements..................................................................................................................................................................
      - 7.2.3 Relationships...........................................................................................................................................................
   - 7.3 Dependencies......................................................................................................................................................................
      - 7.3.1 Dependencies Overview..........................................................................................................................................
      - 7.3.2 Dependency Declaration.........................................................................................................................................
   - 7.4 Annotations.........................................................................................................................................................................
      - 7.4.1 Annotations Overview............................................................................................................................................
      - 7.4.2 Comments and Documentation...............................................................................................................................
      - 7.4.3 Textual Representation............................................................................................................................................
   - 7.5 Namespaces and Packages..................................................................................................................................................
      - 7.5.1 Namespaces Overview............................................................................................................................................
      - 7.5.2 Owned Members and Aliases..................................................................................................................................
      - 7.5.3 Imports....................................................................................................................................................................
      - 7.5.4 Import Filtering.......................................................................................................................................................
      - 7.5.5 Root Namespaces....................................................................................................................................................
   - 7.6 Definition and Usage..........................................................................................................................................................
      - 7.6.1 Definition and Usage Overview..............................................................................................................................
      - 7.6.2 Definitions...............................................................................................................................................................
      - 7.6.3 Usages.....................................................................................................................................................................
      - 7.6.4 Reference Usages....................................................................................................................................................
      - 7.6.5 Effective Names......................................................................................................................................................
      - 7.6.6 Feature Chains.........................................................................................................................................................
      - 7.6.7 Variations and Variants...........................................................................................................................................
      - 7.6.8 Implicit Specialization............................................................................................................................................
   - 7.7 Attributes.............................................................................................................................................................................
      - 7.7.1 Attributes Overview................................................................................................................................................
      - 7.7.2 Attribute Definitions and Usages............................................................................................................................
   - 7.8 Enumerations......................................................................................................................................................................
      - 7.8.1 Enumerations Overview..........................................................................................................................................
      - 7.8.2 Enumeration Definitions and Usages......................................................................................................................
   - 7.9 Occurrences.........................................................................................................................................................................
      - 7.9.1 Occurrences Overview............................................................................................................................................
      - 7.9.2 Occurrence Definitions and Usages........................................................................................................................
      - 7.9.3 Time Slices and Snapshots......................................................................................................................................
      - 7.9.4 Individual Definitions and Usages..........................................................................................................................
      - 7.9.5 Event Occurrence Usages.......................................................................................................................................
   - 7.10 Items..................................................................................................................................................................................
      - 7.10.1 Items Overview.....................................................................................................................................................
      - 7.10.2 Item Definitions and Usages.................................................................................................................................
   - 7.11 Parts...................................................................................................................................................................................
      - 7.11.1 Parts Overview......................................................................................................................................................
      - 7.11.2 Part Definitions and Usages..................................................................................................................................
   - 7.12 Ports..................................................................................................................................................................................
      - 7.12.1 Ports Overview......................................................................................................................................................
      - 7.12.2 Port Definitions and Usages..................................................................................................................................
      - 7.12.3 Conjugated Port Definitions and Usages..............................................................................................................
   - 7.13 Connections.......................................................................................................................................................................
      - 7.13.1 Connections Overview..........................................................................................................................................
      - 7.13.2 Connection Definitions and Usages......................................................................................................................
      - 7.13.3 Bindings as Usages...............................................................................................................................................
      - 7.13.4 Feature Values.......................................................................................................................................................
      - 7.13.5 Successions as Usages...........................................................................................................................................
      - 7.13.6 Flow Connection Usages and Messages...............................................................................................................
   - 7.14 Interfaces...........................................................................................................................................................................
      - 7.14.1 Interfaces Overview..............................................................................................................................................
      - 7.14.2 Interface Definitions and Usages..........................................................................................................................
   - 7.15 Allocations........................................................................................................................................................................
      - 7.15.1 Allocations Overview............................................................................................................................................
      - 7.15.2 Allocation Definitions and Usages........................................................................................................................
   - 7.16 Actions..............................................................................................................................................................................
      - 7.16.1 Actions Overview..................................................................................................................................................
      - 7.16.2 Action Definitions and Usages..............................................................................................................................
      - 7.16.3 Control Nodes.......................................................................................................................................................
      - 7.16.4 Succession Shorthands........................................................................................................................................
      - 7.16.5 Conditional Successions......................................................................................................................................
      - 7.16.6 Perform Action Usages.......................................................................................................................................
      - 7.16.7 Send Action Usages............................................................................................................................................
      - 7.16.8 Accept Action Usages.........................................................................................................................................
      - 7.16.9 Assignment Action Usages.................................................................................................................................
      - 7.16.10 If Action Usages................................................................................................................................................
      - 7.16.11 Loop Action Usages..........................................................................................................................................
   - 7.17 States...............................................................................................................................................................................
      - 7.17.1 States Overview..................................................................................................................................................
      - 7.17.2 State Definitions and Usages..............................................................................................................................
      - 7.17.3 Transition Usages................................................................................................................................................
      - 7.17.4 Exhibit State Usages...........................................................................................................................................
   - 7.18 Calculations.....................................................................................................................................................................
      - 7.18.1 Calculations Overview........................................................................................................................................
      - 7.18.2 Calculation Definitions and Usages....................................................................................................................
   - 7.19 Constraints......................................................................................................................................................................
      - 7.19.1 Constraints Overview..........................................................................................................................................
      - 7.19.2 Constraint Definitions and Usages......................................................................................................................
      - 7.19.3 Assert Constraint Usages....................................................................................................................................
   - 7.20 Requirements..................................................................................................................................................................
      - 7.20.1 Requirements Overview......................................................................................................................................
      - 7.20.2 Requirement Definition and Usage.....................................................................................................................
      - 7.20.3 Concern Definitions and Usages.........................................................................................................................
      - 7.20.4 Satisfy Requirement Usages...............................................................................................................................
   - 7.21 Cases...............................................................................................................................................................................
      - 7.21.1 Cases Overview...................................................................................................................................................
- ii OMG Systems Modeling Language (SysML) v2.0 Beta
      - 7.21.2 Case Definitions and Usages...............................................................................................................................
   - 7.22 Analysis Cases................................................................................................................................................................
      - 7.22.1 Analysis Cases Overview....................................................................................................................................
      - 7.22.2 Analysis Case Definitions and Usages................................................................................................................
      - 7.22.3 Trade-Off Analyses.............................................................................................................................................
   - 7.23 Verification Cases...........................................................................................................................................................
      - 7.23.1 Verification Cases Overview..............................................................................................................................
      - 7.23.2 Verification Case Definitions and Usages..........................................................................................................
   - 7.24 Use Cases........................................................................................................................................................................
      - 7.24.1 Use Cases Overview...........................................................................................................................................
      - 7.24.2 Use Case Definitions and Usages.......................................................................................................................
      - 7.24.3 Include Use Case Usages....................................................................................................................................
   - 7.25 Views and Viewpoints....................................................................................................................................................
      - 7.25.1 Views and Viewpoints Overview........................................................................................................................
      - 7.25.2 View Definitions and Usages..............................................................................................................................
      - 7.25.3 Viewpoint Definitions and Usages......................................................................................................................
      - 7.25.4 Rendering Definitions and Usages......................................................................................................................
      - 7.25.5 Diagrams.............................................................................................................................................................
   - 7.26 Metadata..........................................................................................................................................................................
      - 7.26.1 Metadata Overview.............................................................................................................................................
      - 7.26.2 Metadata Definitions and Usages........................................................................................................................
      - 7.26.3 Semantic Metadata..............................................................................................................................................
      - 7.26.4 User-Defined Keywords......................................................................................................................................
- 8 Metamodel....................................................................................................................................................................................
   - 8.1 Metamodel Overview........................................................................................................................................................
   - 8.2 Concrete Syntax................................................................................................................................................................
      - 8.2.1 Concrete Syntax Overview...................................................................................................................................
      - 8.2.2 Textual Notation....................................................................................................................................................
         - 8.2.2.1 Textual Notation Overview.......................................................................................................................
            - 8.2.2.1.1 EBNF Conventions.......................................................................................................................
            - 8.2.2.1.2 Lexical Structure...........................................................................................................................
         - 8.2.2.2 Elements and Relationships Textual Notation..........................................................................................
         - 8.2.2.3 Dependencies Textual Notation................................................................................................................
         - 8.2.2.4 Annotations Textual Notation...................................................................................................................
            - 8.2.2.4.1 Annotations...................................................................................................................................
            - 8.2.2.4.2 Comments and Documentation.....................................................................................................
            - 8.2.2.4.3 Textual Representation..................................................................................................................
         - 8.2.2.5 Namespaces and Packages Textual Notation............................................................................................
            - 8.2.2.5.1 Packages........................................................................................................................................
            - 8.2.2.5.2 Package Elements..........................................................................................................................
         - 8.2.2.6 Definition and Usage Textual Notation....................................................................................................
            - 8.2.2.6.1 Definitions.....................................................................................................................................
            - 8.2.2.6.2 Usages...........................................................................................................................................
            - 8.2.2.6.3 Reference Usages..........................................................................................................................
            - 8.2.2.6.4 Body Elements..............................................................................................................................
            - 8.2.2.6.5 Specialization................................................................................................................................
            - 8.2.2.6.6 Multiplicity....................................................................................................................................
         - 8.2.2.7 Attributes Textual Notation.......................................................................................................................
         - 8.2.2.8 Enumerations Textual Notation................................................................................................................
         - 8.2.2.9 Occurrences Textual Notation...................................................................................................................
            - 8.2.2.9.1 Occurrence Definitions..................................................................................................................
            - 8.2.2.9.2 Occurrence Usages........................................................................................................................
            - 8.2.2.9.3 Occurrence Successions................................................................................................................
         - 8.2.2.10 Items Textual Notation............................................................................................................................
      - 8.2.2.11 Parts Textual Notation.............................................................................................................................
      - 8.2.2.12 Ports Textual Notation............................................................................................................................
      - 8.2.2.13 Connections Textual Notation.................................................................................................................
         - 8.2.2.13.1 Connection Definition and Usage...............................................................................................
         - 8.2.2.13.2 Binding Connectors.....................................................................................................................
         - 8.2.2.13.3 Successions..................................................................................................................................
         - 8.2.2.13.4 Messages and Flow Connections................................................................................................
      - 8.2.2.14 Interfaces Textual Notation.....................................................................................................................
         - 8.2.2.14.1 Interface Definitions....................................................................................................................
         - 8.2.2.14.2 Interface Usages..........................................................................................................................
      - 8.2.2.15 Allocations Textual Notation..................................................................................................................
      - 8.2.2.16 Actions Textual Notation........................................................................................................................
         - 8.2.2.16.1 Action Definitions.......................................................................................................................
         - 8.2.2.16.2 Action Usages..............................................................................................................................
         - 8.2.2.16.3 Control Nodes..............................................................................................................................
         - 8.2.2.16.4 Send and Accept Action Usages.................................................................................................
         - 8.2.2.16.5 Assignment Action Usages.........................................................................................................
         - 8.2.2.16.6 Structured Control Action Usages...............................................................................................
         - 8.2.2.16.7 Action Successions......................................................................................................................
      - 8.2.2.17 States Textual Notation...........................................................................................................................
         - 8.2.2.17.1 State Definitions..........................................................................................................................
         - 8.2.2.17.2 State Usages................................................................................................................................
         - 8.2.2.17.3 Transition Usages........................................................................................................................
      - 8.2.2.18 Calculations Textual Notation.................................................................................................................
         - 8.2.2.18.1 Calculation Definitions................................................................................................................
         - 8.2.2.18.2 Calculation Usages......................................................................................................................
      - 8.2.2.19 Constraints Textual Notation..................................................................................................................
      - 8.2.2.20 Requirements Textual Notation..............................................................................................................
         - 8.2.2.20.1 Requirement Definitions.............................................................................................................
         - 8.2.2.20.2 Requirement Usages....................................................................................................................
         - 8.2.2.20.3 Concerns......................................................................................................................................
      - 8.2.2.21 Cases Textual Notation...........................................................................................................................
      - 8.2.2.22 Analysis Cases Textual Notation............................................................................................................
      - 8.2.2.23 Verification Cases Textual Notation.......................................................................................................
      - 8.2.2.24 Use Cases Textual Notation....................................................................................................................
      - 8.2.2.25 Views and Viewpoints Textual Notation................................................................................................
         - 8.2.2.25.1 View Definitions.........................................................................................................................
         - 8.2.2.25.2 View Usages................................................................................................................................
         - 8.2.2.25.3 Viewpoints...................................................................................................................................
         - 8.2.2.25.4 Renderings...................................................................................................................................
      - 8.2.2.26 Metadata Textual Notation......................................................................................................................
   - 8.2.3 Graphical Notation................................................................................................................................................
      - 8.2.3.1 Graphical Notation Overview...................................................................................................................
      - 8.2.3.2 Elements and Relationships Graphical Notation.......................................................................................
      - 8.2.3.3 Dependencies Graphical Notation.............................................................................................................
      - 8.2.3.4 Annotations Graphical Notation................................................................................................................
      - 8.2.3.5 Namespaces and Packages Graphical Notation........................................................................................
      - 8.2.3.6 Definition and Usage Graphical Notation.................................................................................................
      - 8.2.3.7 Attributes Graphical Notation...................................................................................................................
      - 8.2.3.8 Enumerations Graphical Notation.............................................................................................................
      - 8.2.3.9 Occurrences Graphical Notation...............................................................................................................
      - 8.2.3.10 Items Graphical Notation........................................................................................................................
      - 8.2.3.11 Parts Graphical Notation.........................................................................................................................
      - 8.2.3.12 Ports Graphical Notation.........................................................................................................................
- iv OMG Systems Modeling Language (SysML) v2.0 Beta
      - 8.2.3.13 Connections Graphical Notation.............................................................................................................
      - 8.2.3.14 Interfaces Graphical Notation.................................................................................................................
      - 8.2.3.15 Allocations Graphical Notation...............................................................................................................
      - 8.2.3.16 Actions Graphical Notation.....................................................................................................................
      - 8.2.3.17 States Graphical Notation........................................................................................................................
      - 8.2.3.18 Calculations Graphical Notation.............................................................................................................
      - 8.2.3.19 Constraints Graphical Notation...............................................................................................................
      - 8.2.3.20 Requirements Graphical Notation...........................................................................................................
      - 8.2.3.21 Cases Graphical Notation........................................................................................................................
      - 8.2.3.22 Analysis Cases Graphical Notation.........................................................................................................
      - 8.2.3.23 Verification Cases Graphical Notation...................................................................................................
      - 8.2.3.24 Use Cases Graphical Notation.................................................................................................................
      - 8.2.3.25 Views and Viewpoints Graphical Notation.............................................................................................
      - 8.2.3.26 Metadata Graphical Notation..................................................................................................................
- 8.3 Abstract Syntax.................................................................................................................................................................
   - 8.3.1 Abstract Syntax Overview....................................................................................................................................
   - 8.3.2 Elements and Relationships Abstract Syntax........................................................................................................
   - 8.3.3 Dependencies Abstract Syntax..............................................................................................................................
   - 8.3.4 Annotations Abstract Syntax.................................................................................................................................
   - 8.3.5 Namespaces and Packages Abstract Syntax.........................................................................................................
   - 8.3.6 Definition and Usage Abstract Syntax..................................................................................................................
      - 8.3.6.1 Overview...................................................................................................................................................
      - 8.3.6.2 Definition..................................................................................................................................................
      - 8.3.6.3 ReferenceUsage.........................................................................................................................................
      - 8.3.6.4 Usage.........................................................................................................................................................
      - 8.3.6.5 VariantMembership...................................................................................................................................
   - 8.3.7 Attributes Abstract Syntax....................................................................................................................................
      - 8.3.7.1 Overview...................................................................................................................................................
      - 8.3.7.2 AttributeUsage..........................................................................................................................................
      - 8.3.7.3 AttributeDefinition....................................................................................................................................
   - 8.3.8 Enumerations Abstract Syntax..............................................................................................................................
      - 8.3.8.1 Overview...................................................................................................................................................
      - 8.3.8.2 EnumerationDefinition..............................................................................................................................
      - 8.3.8.3 EnumerationUsage....................................................................................................................................
   - 8.3.9 Occurrences Abstract Syntax................................................................................................................................
      - 8.3.9.1 Overview...................................................................................................................................................
      - 8.3.9.2 EventOccurrenceUsage.............................................................................................................................
      - 8.3.9.3 LifeClass....................................................................................................................................................
      - 8.3.9.4 OccurrenceDefinition................................................................................................................................
      - 8.3.9.5 OccurrenceUsage......................................................................................................................................
      - 8.3.9.6 PortionKind...............................................................................................................................................
   - 8.3.10 Items Abstract Syntax.........................................................................................................................................
      - 8.3.10.1 Overview.................................................................................................................................................
      - 8.3.10.2 ItemDefinition.........................................................................................................................................
      - 8.3.10.3 ItemUsage................................................................................................................................................
   - 8.3.11 Parts Abstract Syntax..........................................................................................................................................
      - 8.3.11.1 Overview.................................................................................................................................................
      - 8.3.11.2 PartDefinition..........................................................................................................................................
      - 8.3.11.3 PartUsage................................................................................................................................................
   - 8.3.12 Ports Abstract Syntax..........................................................................................................................................
      - 8.3.12.1 Overview.................................................................................................................................................
      - 8.3.12.2 ConjugatedPortDefinition.......................................................................................................................
      - 8.3.12.3 ConjugatedPortTyping............................................................................................................................
      - 8.3.12.4 PortConjugation......................................................................................................................................
      - 8.3.12.5 PortDefinition..........................................................................................................................................
      - 8.3.12.6 PortUsage................................................................................................................................................
   - 8.3.13 Connections Abstract Syntax..............................................................................................................................
      - 8.3.13.1 Overview.................................................................................................................................................
      - 8.3.13.2 BindingConnectorAsUsage.....................................................................................................................
      - 8.3.13.3 ConnectionDefinition..............................................................................................................................
      - 8.3.13.4 ConnectionUsage....................................................................................................................................
      - 8.3.13.5 ConnectorAsUsage..................................................................................................................................
      - 8.3.13.6 FlowConnectionDefinition......................................................................................................................
      - 8.3.13.7 FlowConnectionUsage............................................................................................................................
      - 8.3.13.8 SuccessionAsUsage.................................................................................................................................
      - 8.3.13.9 SuccessionFlowConnectionUsage..........................................................................................................
   - 8.3.14 Interfaces Abstract Syntax..................................................................................................................................
      - 8.3.14.1 Overview.................................................................................................................................................
      - 8.3.14.2 InterfaceDefinition..................................................................................................................................
      - 8.3.14.3 InterfaceUsage.........................................................................................................................................
   - 8.3.15 Allocations Abstract Syntax................................................................................................................................
      - 8.3.15.1 Overview.................................................................................................................................................
      - 8.3.15.2 AllocationDefinition................................................................................................................................
      - 8.3.15.3 AllocationUsage......................................................................................................................................
   - 8.3.16 Actions Abstract Syntax......................................................................................................................................
      - 8.3.16.1 Overview.................................................................................................................................................
      - 8.3.16.2 AcceptActionUsage.................................................................................................................................
      - 8.3.16.3 ActionDefinition......................................................................................................................................
      - 8.3.16.4 ActionUsage............................................................................................................................................
      - 8.3.16.5 AssignmentActionUsage.........................................................................................................................
      - 8.3.16.6 ControlNode............................................................................................................................................
      - 8.3.16.7 DecisionNode..........................................................................................................................................
      - 8.3.16.8 ForkNode.................................................................................................................................................
      - 8.3.16.9 ForLoopActionUsage..............................................................................................................................
      - 8.3.16.10 IfActionUsage.......................................................................................................................................
      - 8.3.16.11 JoinNode................................................................................................................................................
      - 8.3.16.12 LoopActionUsage..................................................................................................................................
      - 8.3.16.13 MergeNode............................................................................................................................................
      - 8.3.16.14 PerformActionUsage.............................................................................................................................
      - 8.3.16.15 SendActionUsage..................................................................................................................................
      - 8.3.16.16 TriggerInvocationExpression................................................................................................................
      - 8.3.16.17 TriggerKind...........................................................................................................................................
      - 8.3.16.18 WhileLoopsActionusage.......................................................................................................................
   - 8.3.17 States Abstract Syntax.........................................................................................................................................
      - 8.3.17.1 Overview.................................................................................................................................................
      - 8.3.17.2 ExhibitStateUsage...................................................................................................................................
      - 8.3.17.3 StateSubactionKind.................................................................................................................................
      - 8.3.17.4 StateSubactionMembership.....................................................................................................................
      - 8.3.17.5 StateDefinition........................................................................................................................................
      - 8.3.17.6 StateUsage...............................................................................................................................................
      - 8.3.17.7 TransitionFeatureKind............................................................................................................................
      - 8.3.17.8 TransitionFeatureMembership................................................................................................................
      - 8.3.17.9 TransitionUsage......................................................................................................................................
   - 8.3.18 Calculations Abstract Syntax..............................................................................................................................
      - 8.3.18.1 Overview.................................................................................................................................................
      - 8.3.18.2 CalculationDefinition..............................................................................................................................
      - 8.3.18.3 CalculationUsage....................................................................................................................................
- vi OMG Systems Modeling Language (SysML) v2.0 Beta
- 8.3.19 Constraints Abstract Syntax................................................................................................................................
   - 8.3.19.1 Overview.................................................................................................................................................
   - 8.3.19.2 AssertConstraintUsage............................................................................................................................
   - 8.3.19.3 ConstraintDefinition................................................................................................................................
   - 8.3.19.4 ConstraintUsage......................................................................................................................................
- 8.3.20 Requirements Abstract Syntax............................................................................................................................
   - 8.3.20.1 Overview.................................................................................................................................................
   - 8.3.20.2 ActorMembership....................................................................................................................................
   - 8.3.20.3 ConcernDefinition...................................................................................................................................
   - 8.3.20.4 ConcernUsage.........................................................................................................................................
   - 8.3.20.5 FramedConcernMembership...................................................................................................................
   - 8.3.20.6 RequirementConstraintKind....................................................................................................................
   - 8.3.20.7 RequirementConstraintMembership.......................................................................................................
   - 8.3.20.8 RequirementDefinition............................................................................................................................
   - 8.3.20.9 RequirementUsage..................................................................................................................................
   - 8.3.20.10 SatisfyRequirementUsage.....................................................................................................................
   - 8.3.20.11 SubjectMembership...............................................................................................................................
   - 8.3.20.12 StakeholderMembership........................................................................................................................
- 8.3.21 Cases Abstract Syntax.........................................................................................................................................
   - 8.3.21.1 Overview.................................................................................................................................................
   - 8.3.21.2 CaseDefinition.........................................................................................................................................
   - 8.3.21.3 CaseUsage...............................................................................................................................................
   - 8.3.21.4 ObjectiveMembership.............................................................................................................................
- 8.3.22 Analysis Cases Abstract Syntax..........................................................................................................................
   - 8.3.22.1 Overview.................................................................................................................................................
   - 8.3.22.2 AnalysisCaseDefinition...........................................................................................................................
   - 8.3.22.3 AnalysisCaseUsage.................................................................................................................................
- 8.3.23 Verification Cases Abstract Syntax....................................................................................................................
   - 8.3.23.1 Overview.................................................................................................................................................
   - 8.3.23.2 RequirementVerificationMembership.....................................................................................................
   - 8.3.23.3 VerificationCaseDefinition.....................................................................................................................
   - 8.3.23.4 VerificationCaseUsage............................................................................................................................
- 8.3.24 Use Cases Abstract Syntax..................................................................................................................................
   - 8.3.24.1 Overview.................................................................................................................................................
   - 8.3.24.2 IncludeUseCaseUsage.............................................................................................................................
   - 8.3.24.3 UseCaseDefinition..................................................................................................................................
   - 8.3.24.4 UseCaseUsage.........................................................................................................................................
- 8.3.25 Views and Viewpoints Abstract Syntax..............................................................................................................
   - 8.3.25.1 Overview.................................................................................................................................................
   - 8.3.25.2 Expose.....................................................................................................................................................
   - 8.3.25.3 MembershipExpose.................................................................................................................................
   - 8.3.25.4 NamespaceExpose...................................................................................................................................
   - 8.3.25.5 RenderingDefinition................................................................................................................................
   - 8.3.25.6 RenderingUsage......................................................................................................................................
   - 8.3.25.7 ViewDefinition........................................................................................................................................
   - 8.3.25.8 ViewpointDefinition................................................................................................................................
   - 8.3.25.9 ViewpointUsage......................................................................................................................................
   - 8.3.25.10 ViewRenderingMembership.................................................................................................................
   - 8.3.25.11 ViewUsage............................................................................................................................................
- 8.3.26 Metadata Abstract Syntax...................................................................................................................................
   - 8.3.26.1 Overview.................................................................................................................................................
   - 8.3.26.2 MetadataDefinition..................................................................................................................................
   - 8.3.26.3 MetadataUsage........................................................................................................................................
   - 8.4 Semantics..........................................................................................................................................................................
      - 8.4.1 Semantics Overview..............................................................................................................................................
      - 8.4.2 Definition and Usage Semantics...........................................................................................................................
         - 8.4.2.1 Definitions.................................................................................................................................................
         - 8.4.2.2 Usages.......................................................................................................................................................
         - 8.4.2.3 Variation Definitions and Usages.............................................................................................................
      - 8.4.3 Attributes Semantics.............................................................................................................................................
         - 8.4.3.1 Attribute Definitions.................................................................................................................................
         - 8.4.3.2 Attribute Usages........................................................................................................................................
      - 8.4.4 Enumerations Semantics.......................................................................................................................................
      - 8.4.5 Occurrences Semantics.........................................................................................................................................
         - 8.4.5.1 Occurrence Definitions.............................................................................................................................
         - 8.4.5.2 Occurrence Usages....................................................................................................................................
         - 8.4.5.3 Event Occurrence Usages..........................................................................................................................
      - 8.4.6 Items Semantics....................................................................................................................................................
         - 8.4.6.1 Item Definitions.........................................................................................................................................
         - 8.4.6.2 Item Usages...............................................................................................................................................
      - 8.4.7 Parts Semantics.....................................................................................................................................................
         - 8.4.7.1 Part Definitions.........................................................................................................................................
         - 8.4.7.2 Part Usages................................................................................................................................................
      - 8.4.8 Ports Semantics.....................................................................................................................................................
         - 8.4.8.1 Port Definitions.........................................................................................................................................
         - 8.4.8.2 Port Usages................................................................................................................................................
      - 8.4.9 Connections Semantics.........................................................................................................................................
         - 8.4.9.1 Connection Definitions.............................................................................................................................
         - 8.4.9.2 Connection Usages....................................................................................................................................
         - 8.4.9.3 Binding Connectors As Usages.................................................................................................................
         - 8.4.9.4 Successions As Usages..............................................................................................................................
         - 8.4.9.5 Flow Connection Definitions....................................................................................................................
         - 8.4.9.6 Flow Connection Usages...........................................................................................................................
         - 8.4.9.7 Succession Flow Connection Usage.........................................................................................................
      - 8.4.10 Interfaces Semantics............................................................................................................................................
         - 8.4.10.1 Interface Definitions................................................................................................................................
         - 8.4.10.2 Interface Usages......................................................................................................................................
      - 8.4.11 Allocations Semantics.........................................................................................................................................
         - 8.4.11.1 Allocation Definitions.............................................................................................................................
         - 8.4.11.2 Allocation Usages...................................................................................................................................
      - 8.4.12 Actions Semantics...............................................................................................................................................
         - 8.4.12.1 Action Definitions...................................................................................................................................
         - 8.4.12.2 Action Usages.........................................................................................................................................
         - 8.4.12.3 Decision Transition Usages.....................................................................................................................
         - 8.4.12.4 Control Nodes.........................................................................................................................................
         - 8.4.12.5 Send Action Usages................................................................................................................................
         - 8.4.12.6 Accept Action Usages.............................................................................................................................
         - 8.4.12.7 Assignment Action Usages.....................................................................................................................
         - 8.4.12.8 If Action Usages......................................................................................................................................
         - 8.4.12.9 Loop Action Usages................................................................................................................................
         - 8.4.12.10 Perform Action Usages.........................................................................................................................
      - 8.4.13 States Semantics..................................................................................................................................................
         - 8.4.13.1 State Definitions......................................................................................................................................
         - 8.4.13.2 State Usages............................................................................................................................................
         - 8.4.13.3 Transition Usages....................................................................................................................................
         - 8.4.13.4 Exhibit State Usages................................................................................................................................
- viii OMG Systems Modeling Language (SysML) v2.0 Beta
      - 8.4.14 Calculations Semantics.......................................................................................................................................
         - 8.4.14.1 Calculation Definitions...........................................................................................................................
         - 8.4.14.2 Calculation Usages..................................................................................................................................
      - 8.4.15 Constraints Semantics.........................................................................................................................................
         - 8.4.15.1 Constraint Definitions.............................................................................................................................
         - 8.4.15.2 Constraint Usages....................................................................................................................................
         - 8.4.15.3 Assert Constraint Usages........................................................................................................................
      - 8.4.16 Requirements Semantics.....................................................................................................................................
         - 8.4.16.1 Requirement Definitions.........................................................................................................................
         - 8.4.16.2 Requirement Usages................................................................................................................................
         - 8.4.16.3 Satisfy Requirement Usages....................................................................................................................
         - 8.4.16.4 Concern Definitions................................................................................................................................
         - 8.4.16.5 Concern Usages.......................................................................................................................................
      - 8.4.17 Cases Semantics..................................................................................................................................................
         - 8.4.17.1 Case Definitions......................................................................................................................................
         - 8.4.17.2 Case Usages.............................................................................................................................................
      - 8.4.18 Analysis Cases Semantics...................................................................................................................................
         - 8.4.18.1 Analysis Case Definitions.......................................................................................................................
         - 8.4.18.2 Analysis Case Usages..............................................................................................................................
      - 8.4.19 Verification Cases Semantics..............................................................................................................................
         - 8.4.19.1 Verification Case Definitions..................................................................................................................
         - 8.4.19.2 Verification Case Usages........................................................................................................................
      - 8.4.20 Use Cases Semantics...........................................................................................................................................
         - 8.4.20.1 Use Case Definitions...............................................................................................................................
         - 8.4.20.2 Use Case Usages.....................................................................................................................................
         - 8.4.20.3 Include Use Case Usages........................................................................................................................
      - 8.4.21 Views and Viewpoints Semantics.......................................................................................................................
         - 8.4.21.1 View Definitions.....................................................................................................................................
         - 8.4.21.2 View Usages............................................................................................................................................
         - 8.4.21.3 Viewpoint Definitions.............................................................................................................................
         - 8.4.21.4 Viewpoint Usages...................................................................................................................................
         - 8.4.21.5 Rendering Definitions.............................................................................................................................
         - 8.4.21.6 Rendering Usages....................................................................................................................................
      - 8.4.22 Metadata Semantics............................................................................................................................................
         - 8.4.22.1 Metadata Definitions...............................................................................................................................
         - 8.4.22.2 Metadata Usages.....................................................................................................................................
- 9 Model Libraries.............................................................................................................................................................................
   - 9.1 Model Libraries Overview................................................................................................................................................
   - 9.2 Systems Model Library.....................................................................................................................................................
      - 9.2.1 Systems Model Library Overview........................................................................................................................
      - 9.2.2 Attributes...............................................................................................................................................................
         - 9.2.2.1 Attributes Overview..................................................................................................................................
         - 9.2.2.2 Elements....................................................................................................................................................
            - 9.2.2.2.1 AttributeValue...............................................................................................................................
            - 9.2.2.2.2 attributeValues...............................................................................................................................
      - 9.2.3 Items......................................................................................................................................................................
         - 9.2.3.1 Items Overview.........................................................................................................................................
         - 9.2.3.2 Elements....................................................................................................................................................
            - 9.2.3.2.1 Item................................................................................................................................................
            - 9.2.3.2.2 items..............................................................................................................................................
            - 9.2.3.2.3 Touches.........................................................................................................................................
      - 9.2.4 Parts.......................................................................................................................................................................
         - 9.2.4.1 Parts Overview..........................................................................................................................................
      - 9.2.4.2 Elements....................................................................................................................................................
         - 9.2.4.2.1 Part.................................................................................................................................................
         - 9.2.4.2.2 parts...............................................................................................................................................
   - 9.2.5 Ports......................................................................................................................................................................
      - 9.2.5.1 Ports Overview..........................................................................................................................................
      - 9.2.5.2 Elements....................................................................................................................................................
         - 9.2.5.2.1 Port................................................................................................................................................
         - 9.2.5.2.2 ports...............................................................................................................................................
   - 9.2.6 Connections...........................................................................................................................................................
      - 9.2.6.1 Connections Overview..............................................................................................................................
      - 9.2.6.2 Elements....................................................................................................................................................
         - 9.2.6.2.1 BinaryConnection..........................................................................................................................
         - 9.2.6.2.2 binaryConnections.........................................................................................................................
         - 9.2.6.2.3 Connection.....................................................................................................................................
         - 9.2.6.2.4 connections....................................................................................................................................
         - 9.2.6.2.5 FlowConnection............................................................................................................................
         - 9.2.6.2.6 flowConnections............................................................................................................................
         - 9.2.6.2.7 MessageConnection.......................................................................................................................
         - 9.2.6.2.8 messageConnections.....................................................................................................................
         - 9.2.6.2.9 SuccessionFlowConnection...........................................................................................................
         - 9.2.6.2.10 successionFlowConnections........................................................................................................
   - 9.2.7 Interfaces...............................................................................................................................................................
      - 9.2.7.1 Interfaces Overview..................................................................................................................................
      - 9.2.7.2 Elements....................................................................................................................................................
         - 9.2.7.2.1 BinaryInterface..............................................................................................................................
         - 9.2.7.2.2 binaryInterfaces.............................................................................................................................
         - 9.2.7.2.3 Interface.........................................................................................................................................
         - 9.2.7.2.4 interfaces.......................................................................................................................................
   - 9.2.8 Allocations............................................................................................................................................................
      - 9.2.8.1 Allocations Overview................................................................................................................................
      - 9.2.8.2 Elements....................................................................................................................................................
         - 9.2.8.2.1 Allocation......................................................................................................................................
         - 9.2.8.2.2 allocations......................................................................................................................................
   - 9.2.9 Actions..................................................................................................................................................................
      - 9.2.9.1 Actions Overview......................................................................................................................................
      - 9.2.9.2 Elements....................................................................................................................................................
         - 9.2.9.2.1 AcceptAction.................................................................................................................................
         - 9.2.9.2.2 acceptActions................................................................................................................................
         - 9.2.9.2.3 AcceptMessageAction...................................................................................................................
         - 9.2.9.2.4 Action............................................................................................................................................
         - 9.2.9.2.5 actions............................................................................................................................................
         - 9.2.9.2.6 AssignmentAction.........................................................................................................................
         - 9.2.9.2.7 assignmentActions.........................................................................................................................
         - 9.2.9.2.8 ControlAction................................................................................................................................
         - 9.2.9.2.9 DecisionAction..............................................................................................................................
         - 9.2.9.2.10 DecisionTransitionAction...........................................................................................................
         - 9.2.9.2.11 ForkAction...................................................................................................................................
         - 9.2.9.2.12 ForLoopAction............................................................................................................................
         - 9.2.9.2.13 forLoopActions...........................................................................................................................
         - 9.2.9.2.14 IfThenAction...............................................................................................................................
         - 9.2.9.2.15 ifThenActions..............................................................................................................................
         - 9.2.9.2.16 IfThenElseAction........................................................................................................................
         - 9.2.9.2.17 ifThenElseActions.......................................................................................................................
         - 9.2.9.2.18 JoinAction...................................................................................................................................
- x OMG Systems Modeling Language (SysML) v2.0 Beta
      - 9.2.9.2.19 LoopAction..................................................................................................................................
      - 9.2.9.2.20 loopActions.................................................................................................................................
      - 9.2.9.2.21 MergeAction................................................................................................................................
      - 9.2.9.2.22 SendAction..................................................................................................................................
      - 9.2.9.2.23 sendActions.................................................................................................................................
      - 9.2.9.2.24 TransitionAction..........................................................................................................................
      - 9.2.9.2.25 transitionActions.........................................................................................................................
      - 9.2.9.2.26 WhileLoopAction........................................................................................................................
      - 9.2.9.2.27 whileLoopActions.......................................................................................................................
- 9.2.10 States...................................................................................................................................................................
   - 9.2.10.1 States Overview.......................................................................................................................................
   - 9.2.10.2 Elements..................................................................................................................................................
      - 9.2.10.2.1 StateAction..................................................................................................................................
      - 9.2.10.2.2 stateActions.................................................................................................................................
      - 9.2.10.2.3 StateTransitionAction..................................................................................................................
- 9.2.11 Calculations.........................................................................................................................................................
   - 9.2.11.1 Calculations Overview............................................................................................................................
   - 9.2.11.2 Elements..................................................................................................................................................
      - 9.2.11.2.1 Calculation...................................................................................................................................
      - 9.2.11.2.2 calculations..................................................................................................................................
- 9.2.12 Constraints..........................................................................................................................................................
   - 9.2.12.1 Constraints Overview..............................................................................................................................
   - 9.2.12.2 Elements..................................................................................................................................................
      - 9.2.12.2.1 assertedConstraintChecks............................................................................................................
      - 9.2.12.2.2 ConstraintCheck..........................................................................................................................
      - 9.2.12.2.3 constraintChecks.........................................................................................................................
      - 9.2.12.2.4 negatedConstraintChecks............................................................................................................
- 9.2.13 Requirements.......................................................................................................................................................
   - 9.2.13.1 Requirements Overview..........................................................................................................................
   - 9.2.13.2 Elements..................................................................................................................................................
      - 9.2.13.2.1 ConcernCheck.............................................................................................................................
      - 9.2.13.2.2 concernChecks.............................................................................................................................
      - 9.2.13.2.3 DesignConstraintCheck...............................................................................................................
      - 9.2.13.2.4 FunctionalRequirementCheck.....................................................................................................
      - 9.2.13.2.5 InterfaceRequirementCheck........................................................................................................
      - 9.2.13.2.6 PerformanceRequirementCheck..................................................................................................
      - 9.2.13.2.7 PhysicalRequirementCheck.........................................................................................................
      - 9.2.13.2.8 RequirementCheck......................................................................................................................
      - 9.2.13.2.9 requirementChecks......................................................................................................................
- 9.2.14 Cases...................................................................................................................................................................
   - 9.2.14.1 Cases Overview.......................................................................................................................................
   - 9.2.14.2 Elements..................................................................................................................................................
      - 9.2.14.2.1 Case.............................................................................................................................................
      - 9.2.14.2.2 cases.............................................................................................................................................
- 9.2.15 Analysis Cases....................................................................................................................................................
   - 9.2.15.1 Analysis Cases Overview........................................................................................................................
   - 9.2.15.2 Elements..................................................................................................................................................
      - 9.2.15.2.1 AnalysisAction............................................................................................................................
      - 9.2.15.2.2 AnalysisCase...............................................................................................................................
      - 9.2.15.2.3 analysisCases...............................................................................................................................
      - 9.2.15.2.4 AnalysisAction...........................................................................................................................
      - 9.2.15.2.5 AnalysisCase..............................................................................................................................
      - 9.2.15.2.6 analysisCases..............................................................................................................................
      - 9.2.16 Verification Cases...............................................................................................................................................
         - 9.2.16.1 Verification Cases Overview..................................................................................................................
         - 9.2.16.2 Elements..................................................................................................................................................
            - 9.2.16.2.1 PassIf...........................................................................................................................................
            - 9.2.16.2.2 VerificationCase..........................................................................................................................
            - 9.2.16.2.3 verificationCases.........................................................................................................................
            - 9.2.16.2.4 VerificationCheck.......................................................................................................................
            - 9.2.16.2.5 VerificationMethod.....................................................................................................................
      - 9.2.17 Use Cases............................................................................................................................................................
         - 9.2.17.1 Use Cases Overview................................................................................................................................
         - 9.2.17.2 Elements..................................................................................................................................................
            - 9.2.17.2.1 UseCase.......................................................................................................................................
            - 9.2.17.2.2 useCases......................................................................................................................................
      - 9.2.18 Views...................................................................................................................................................................
         - 9.2.18.1 Views Overview......................................................................................................................................
         - 9.2.18.2 Elements..................................................................................................................................................
            - 9.2.18.2.1 asElementTable...........................................................................................................................
            - 9.2.18.2.2 asInterconnectionDiagram...........................................................................................................
            - 9.2.18.2.3 asTextualNotation.......................................................................................................................
            - 9.2.18.2.4 asTreeDiagram............................................................................................................................
            - 9.2.18.2.5 GraphicalRendering.....................................................................................................................
            - 9.2.18.2.6 Rendering....................................................................................................................................
            - 9.2.18.2.7 renderings....................................................................................................................................
            - 9.2.18.2.8 TabularRendering........................................................................................................................
            - 9.2.18.2.9 TextualRendering........................................................................................................................
            - 9.2.18.2.10 View..........................................................................................................................................
            - 9.2.18.2.11 ViewpointCheck........................................................................................................................
            - 9.2.18.2.12 viewpointChecks.......................................................................................................................
            - 9.2.18.2.13 viewpointConformance.............................................................................................................
            - 9.2.18.2.14 views..........................................................................................................................................
      - 9.2.19 Standard View Definitions..................................................................................................................................
         - 9.2.19.1 Standard View Definitions Overview.....................................................................................................
         - 9.2.19.2 Elements..................................................................................................................................................
            - 9.2.19.2.1 ActionFlowView.........................................................................................................................
            - 9.2.19.2.2 BrowserView...............................................................................................................................
            - 9.2.19.2.3 CaseView.....................................................................................................................................
            - 9.2.19.2.4 GeneralView................................................................................................................................
            - 9.2.19.2.5 GeometryView............................................................................................................................
            - 9.2.19.2.6 GridView.....................................................................................................................................
            - 9.2.19.2.7 InterconnectionView...................................................................................................................
            - 9.2.19.2.8 SequenceView.............................................................................................................................
            - 9.2.19.2.9 StateTransitionView....................................................................................................................
      - 9.2.20 Metadata..............................................................................................................................................................
         - 9.2.20.1 Metadata Overview.................................................................................................................................
         - 9.2.20.2 Elements..................................................................................................................................................
            - 9.2.20.2.1 MetadataItem...............................................................................................................................
            - 9.2.20.2.2 metadataItems..............................................................................................................................
      - 9.2.21 SysML.................................................................................................................................................................
   - 9.3 Metadata Domain Library.................................................................................................................................................
      - 9.3.1 Metadata Domain Library Overview....................................................................................................................
      - 9.3.2 Modeling Metadata...............................................................................................................................................
         - 9.3.2.1 Modeling Metadata Overview...................................................................................................................
         - 9.3.2.2 Elements....................................................................................................................................................
            - 9.3.2.2.1 Issue...............................................................................................................................................
- xii OMG Systems Modeling Language (SysML) v2.0 Beta
         - 9.3.2.2.2 Rationale........................................................................................................................................
         - 9.3.2.2.3 Refinement....................................................................................................................................
         - 9.3.2.2.4 StatusInfo.......................................................................................................................................
         - 9.3.2.2.5 StatusKind.....................................................................................................................................
   - 9.3.3 Risk Metadata........................................................................................................................................................
      - 9.3.3.1 Risk Metadata Overview...........................................................................................................................
      - 9.3.3.2 Elements....................................................................................................................................................
         - 9.3.3.2.1 Level..............................................................................................................................................
         - 9.3.3.2.2 LevelEnum....................................................................................................................................
         - 9.3.3.2.3 Risk................................................................................................................................................
         - 9.3.3.2.4 RiskLevel.......................................................................................................................................
         - 9.3.3.2.5 RiskLevelEnum.............................................................................................................................
   - 9.3.4 Parameters of Interest Metadata............................................................................................................................
      - 9.3.4.1 Parameters of Interest Metadata Overview...............................................................................................
      - 9.3.4.2 Elements....................................................................................................................................................
         - 9.3.4.2.1 MeasureOfEffectiveness...............................................................................................................
         - 9.3.4.2.2 MeasureOfPerformance.................................................................................................................
         - 9.3.4.2.3 measuresOfEffectiveness..............................................................................................................
         - 9.3.4.2.4 measuresOfPerformance...............................................................................................................
   - 9.3.5 Image Metadata.....................................................................................................................................................
      - 9.3.5.1 Image Metadata Overview........................................................................................................................
      - 9.3.5.2 Elements....................................................................................................................................................
         - 9.3.5.2.1 Icon................................................................................................................................................
         - 9.3.5.2.2 Image.............................................................................................................................................
- 9.4 Analysis Domain Library..................................................................................................................................................
   - 9.4.1 Analysis Domain Library Overview.....................................................................................................................
   - 9.4.2 Analysis Tooling...................................................................................................................................................
      - 9.4.2.1 Analysis Tooling Overview......................................................................................................................
      - 9.4.2.2 Elements....................................................................................................................................................
         - 9.4.2.2.1 ToolExecution...............................................................................................................................
         - 9.4.2.2.2 ToolVariable..................................................................................................................................
   - 9.4.3 Sampled Functions................................................................................................................................................
      - 9.4.3.1 Sampled Functions Overview...................................................................................................................
      - 9.4.3.2 Elements....................................................................................................................................................
         - 9.4.3.2.1 Domain..........................................................................................................................................
         - 9.4.3.2.2 Interpolate......................................................................................................................................
         - 9.4.3.2.3 interpolateLinear...........................................................................................................................
         - 9.4.3.2.4 Range.............................................................................................................................................
         - 9.4.3.2.5 Sample...........................................................................................................................................
         - 9.4.3.2.6 SampledFunction...........................................................................................................................
         - 9.4.3.2.7 SamplePair.....................................................................................................................................
   - 9.4.4 State Space Representation...................................................................................................................................
      - 9.4.4.1 State Space Representation Overview.......................................................................................................
      - 9.4.4.2 Elements....................................................................................................................................................
   - 9.4.5 Trade Studies.........................................................................................................................................................
      - 9.4.5.1 Trade Studies Overview............................................................................................................................
      - 9.4.5.2 Elements....................................................................................................................................................
         - 9.4.5.2.1 EvaluationFunction.......................................................................................................................
         - 9.4.5.2.2 MaximizeObjective.......................................................................................................................
         - 9.4.5.2.3 MinimizeObjective........................................................................................................................
         - 9.4.5.2.4 TradeStudy....................................................................................................................................
         - 9.4.5.2.5 TradeStudyObjective.....................................................................................................................
- 9.5 Cause and Effect Domain Library....................................................................................................................................
   - 9.5.1 Cause and Effect Domain Library Overview........................................................................................................
      - 9.5.2 Causation Connections..........................................................................................................................................
         - 9.5.2.1 Causation Connections Overview.............................................................................................................
         - 9.5.2.2 Elements....................................................................................................................................................
            - 9.5.2.2.1 Causation.......................................................................................................................................
            - 9.5.2.2.2 causations......................................................................................................................................
            - 9.5.2.2.3 causes.............................................................................................................................................
            - 9.5.2.2.4 effects............................................................................................................................................
            - 9.5.2.2.5 Multicausation...............................................................................................................................
            - 9.5.2.2.6 multicausations..............................................................................................................................
      - 9.5.3 Cause and Effect...................................................................................................................................................
         - 9.5.3.1 Cause and Effect Overview.......................................................................................................................
         - 9.5.3.2 Elements....................................................................................................................................................
            - 9.5.3.2.1 CausationMetadata........................................................................................................................
            - 9.5.3.2.2 CausationSemanticMetadata.........................................................................................................
            - 9.5.3.2.3 CauseMetadata..............................................................................................................................
            - 9.5.3.2.4 EffectMetadata..............................................................................................................................
            - 9.5.3.2.5 MulticausationSemanticMetadata.................................................................................................
   - 9.6 Requirement Derivation Domain Library.........................................................................................................................
      - 9.6.1 Requirement Derivation Domain LIbrary Overview............................................................................................
      - 9.6.2 Derivation Connections.........................................................................................................................................
         - 9.6.2.1 Derivation Connections Overview............................................................................................................
         - 9.6.2.2 Elements....................................................................................................................................................
            - 9.6.2.2.1 Derivation......................................................................................................................................
            - 9.6.2.2.2 derivations.....................................................................................................................................
            - 9.6.2.2.3 derivedRequirements.....................................................................................................................
            - 9.6.2.2.4 originalRequirements....................................................................................................................
      - 9.6.3 Requirement Derivation........................................................................................................................................
         - 9.6.3.1 Requirement Derivation Overview...........................................................................................................
         - 9.6.3.2 Elements....................................................................................................................................................
            - 9.6.3.2.1 DerivationMetadata.......................................................................................................................
            - 9.6.3.2.2 DerivedRequirementMetadata.......................................................................................................
            - 9.6.3.2.3 OriginalRequirementMetadata......................................................................................................
   - 9.7 Geometry Domain Library................................................................................................................................................
      - 9.7.1 Geometry Domain Library Overview...................................................................................................................
      - 9.7.2 Spatial Items..........................................................................................................................................................
         - 9.7.2.1 Spatial Items Overview.............................................................................................................................
         - 9.7.2.2 Elements....................................................................................................................................................
            - 9.7.2.2.1 CurrentDisplacementOf.................................................................................................................
            - 9.7.2.2.2 CurrentPositionOf.........................................................................................................................
            - 9.7.2.2.3 DisplacementOf.............................................................................................................................
            - 9.7.2.2.4 PositionOf......................................................................................................................................
            - 9.7.2.2.5 SpatialItem.....................................................................................................................................
      - 9.7.3 Shape Items...........................................................................................................................................................
         - 9.7.3.1 Shape Items Overview..............................................................................................................................
         - 9.7.3.2 Elements....................................................................................................................................................
            - 9.7.3.2.1 Circle.............................................................................................................................................
            - 9.7.3.2.2 CircularCone.................................................................................................................................
            - 9.7.3.2.3 CircularCylinder............................................................................................................................
            - 9.7.3.2.4 CircularDisc...................................................................................................................................
            - 9.7.3.2.5 Cone...............................................................................................................................................
            - 9.7.3.2.6 ConeOrCylinder............................................................................................................................
            - 9.7.3.2.7 ConicSection.................................................................................................................................
            - 9.7.3.2.8 ConicSurface.................................................................................................................................
            - 9.7.3.2.9 Cuboid...........................................................................................................................................
- xiv OMG Systems Modeling Language (SysML) v2.0 Beta


```
9.7.3.2.10 CuboidOrTriangularPrism........................................................................................................... 538
9.7.3.2.11 Cylinder....................................................................................................................................... 539
9.7.3.2.12 Disc.............................................................................................................................................. 540
9.7.3.2.13 EccentricCone............................................................................................................................. 541
9.7.3.2.14 EccentricCylinder........................................................................................................................ 541
9.7.3.2.15 Ellipse.......................................................................................................................................... 541
9.7.3.2.16 Ellipsoid...................................................................................................................................... 542
9.7.3.2.17 Hyperbola.................................................................................................................................... 542
9.7.3.2.18 Hyperboloid................................................................................................................................. 543
9.7.3.2.19 Line.............................................................................................................................................. 543
9.7.3.2.20 Parabola....................................................................................................................................... 544
9.7.3.2.21 Paraboloid.................................................................................................................................... 544
9.7.3.2.22 Path.............................................................................................................................................. 544
9.7.3.2.23 PlanarCurve................................................................................................................................. 545
9.7.3.2.24 PlanarSurface............................................................................................................................... 545
9.7.3.2.25 Polygon........................................................................................................................................ 546
9.7.3.2.26 Polyhedron................................................................................................................................... 546
9.7.3.2.27 Pyramid....................................................................................................................................... 547
9.7.3.2.28 Quadrilateral................................................................................................................................ 548
9.7.3.2.29 Rectangle..................................................................................................................................... 548
9.7.3.2.30 RectangularCuboid...................................................................................................................... 549
9.7.3.2.31 RectangularPyramid.................................................................................................................... 549
9.7.3.2.32 RectangularToroid....................................................................................................................... 550
9.7.3.2.33 RightCircularCone....................................................................................................................... 550
9.7.3.2.34 RightCircularCylinder................................................................................................................. 551
9.7.3.2.35 RightTriangle............................................................................................................................... 551
9.7.3.2.36 RightTriangularPrism.................................................................................................................. 552
9.7.3.2.37 Shell............................................................................................................................................. 552
9.7.3.2.38 Sphere.......................................................................................................................................... 553
9.7.3.2.39 Tetrahedron................................................................................................................................. 553
9.7.3.2.40 Toriod.......................................................................................................................................... 554
9.7.3.2.41 Torus............................................................................................................................................ 554
9.7.3.2.42 Triangle....................................................................................................................................... 555
9.7.3.2.43 TriangularPrism........................................................................................................................... 555
9.8 Quantities and Units Domain Library............................................................................................................................... 556
9.8.1 Quantities and Units Domain Library Overview.................................................................................................. 556
9.8.2 Quantities.............................................................................................................................................................. 557
9.8.2.1 Quantities Overview.................................................................................................................................. 557
9.8.2.2 Elements.................................................................................................................................................... 558
9.8.2.2.1 3dVectorQuantityValue................................................................................................................. 558
9.8.2.2.2 QuantityDimension....................................................................................................................... 558
9.8.2.2.3 QuantityPowerFactor..................................................................................................................... 559
9.8.2.2.4 scalarQuantities............................................................................................................................. 559
9.8.2.2.5 ScalarQuantityValue..................................................................................................................... 560
9.8.2.2.6 SystemOfQuantities....................................................................................................................... 560
9.8.2.2.7 tensorQuantities............................................................................................................................. 561
9.8.2.2.8 TensorQuantityValue.................................................................................................................... 561
9.8.2.2.9 vectorQuantities............................................................................................................................. 563
9.8.2.2.10 VectorQuantityValue................................................................................................................... 563
9.8.3 Measurement References...................................................................................................................................... 564
9.8.3.1 Measurement References Overview.......................................................................................................... 564
9.8.3.2 Elements.................................................................................................................................................... 564
9.8.3.2.1 3dCoordinateFrame....................................................................................................................... 564
9.8.3.2.2 AffineTransformationMatrix3d..................................................................................................... 564
```
**OMG Systems Modeling Language (SysML) v2.0 Beta 1 xv**


```
9.8.3.2.3 ConversionByConvention............................................................................................................. 565
9.8.3.2.4 ConversionByPrefix...................................................................................................................... 565
9.8.3.2.5 CoordinateFrame........................................................................................................................... 566
9.8.3.2.6 CoordinateFramePlacement.......................................................................................................... 567
9.8.3.2.7 CoordinateTransformation............................................................................................................ 568
9.8.3.2.8 countQuantities.............................................................................................................................. 568
9.8.3.2.9 CountValue.................................................................................................................................... 569
9.8.3.2.10 CyclicRatioScale......................................................................................................................... 569
9.8.3.2.11 DefinitionalQuantityValue.......................................................................................................... 570
9.8.3.2.12 DerivedUnit................................................................................................................................. 570
9.8.3.2.13 dimensionOneQuantities............................................................................................................. 570
9.8.3.2.14 DimensionOneUnit...................................................................................................................... 571
9.8.3.2.15 DimensionOneValue................................................................................................................... 571
9.8.3.2.16 IntervalScale................................................................................................................................ 572
9.8.3.2.17 LogarithmicScale......................................................................................................................... 572
9.8.3.2.18 MeasurementScale....................................................................................................................... 573
9.8.3.2.19 MeasurementUnit........................................................................................................................ 574
9.8.3.2.20 NullTransformation..................................................................................................................... 574
9.8.3.2.21 nullTransformation...................................................................................................................... 575
9.8.3.2.22 one............................................................................................................................................... 575
9.8.3.2.23 OrdinalScale................................................................................................................................ 576
9.8.3.2.24 QuantityValueMapping............................................................................................................... 576
9.8.3.2.25 Rotation....................................................................................................................................... 577
9.8.3.2.26 ScalarMeasurementReference..................................................................................................... 577
9.8.3.2.27 SimpleUnit.................................................................................................................................. 578
9.8.3.2.28 SystemOfUnits............................................................................................................................ 579
9.8.3.2.29 TensorMeasurementReference.................................................................................................... 579
9.8.3.2.30 Translation................................................................................................................................... 580
9.8.3.2.31 TranslationOrRotation................................................................................................................. 581
9.8.3.2.32 TranslationRotationSequence...................................................................................................... 581
9.8.3.2.33 UnitConversion........................................................................................................................... 581
9.8.3.2.34 UnitPowerFactor......................................................................................................................... 582
9.8.3.2.35 UnitPrefix.................................................................................................................................... 583
9.8.3.2.36 VectorMeasurementReference.................................................................................................... 583
9.8.3.2.37 VectorQuantityValue[1].............................................................................................................. 584
9.8.4 ISQ........................................................................................................................................................................ 584
9.8.4.1 ISQ Overview............................................................................................................................................ 584
9.8.4.2 Elements.................................................................................................................................................... 585
9.8.4.2.1 amountOfSubstance....................................................................................................................... 585
9.8.4.2.2 AmountOfSubstanceUnit.............................................................................................................. 585
9.8.4.2.3 AmountOfSubstanceValue............................................................................................................ 586
9.8.4.2.4 AngularMeasureValue................................................................................................................... 586
9.8.4.2.5 Cartesian3dSpatialCoordinateSystem........................................................................................... 586
9.8.4.2.6 duration.......................................................................................................................................... 587
9.8.4.2.7 DurationUnit.................................................................................................................................. 587
9.8.4.2.8 DurationValue............................................................................................................................... 588
9.8.4.2.9 electricCurrent............................................................................................................................... 588
9.8.4.2.10 ElectricCurrentUnit..................................................................................................................... 588
9.8.4.2.11 ElectricCurrentValue................................................................................................................... 589
9.8.4.2.12 length........................................................................................................................................... 589
9.8.4.2.13 LengthUnit................................................................................................................................... 589
9.8.4.2.14 LengthValue................................................................................................................................ 590
9.8.4.2.15 luminousIntensity........................................................................................................................ 590
9.8.4.2.16 LuminousIntensityUnit................................................................................................................ 591
```
**xvi OMG Systems Modeling Language (SysML) v2.0 Beta 1**


9.8.4.2.17 LuminousIntensityValue............................................................................................................. 591
9.8.4.2.18 mass............................................................................................................................................. 591
9.8.4.2.19 MassUnit..................................................................................................................................... 592
9.8.4.2.20 MassValue................................................................................................................................... 592
9.8.4.2.21 Position3dVector......................................................................................................................... 593
9.8.4.2.22 thermodynamicTemperature....................................................................................................... 593
9.8.4.2.23 ThermodynamicTemperatureUnit............................................................................................... 593
9.8.4.2.24 ThermodynamicTemperatureValue............................................................................................. 594
9.8.5 SI Prefixes............................................................................................................................................................. 594
9.8.5.1 SI Prefixes Overview................................................................................................................................ 594
9.8.5.2 Elements.................................................................................................................................................... 595
9.8.6 SI........................................................................................................................................................................... 595
9.8.6.1 SI Overview............................................................................................................................................... 595
9.8.6.2 Elements.................................................................................................................................................... 596
9.8.7 US Customary Units............................................................................................................................................. 596
9.8.7.1 US Customary Units Overview................................................................................................................. 596
9.8.7.2 Elements.................................................................................................................................................... 596
9.8.8 Time...................................................................................................................................................................... 596
9.8.8.1 Time Overview.......................................................................................................................................... 596
9.8.8.2 Elements.................................................................................................................................................... 596
9.8.8.2.1 Clock............................................................................................................................................. 596
9.8.8.2.2 Date............................................................................................................................................... 596
9.8.8.2.3 DateTime....................................................................................................................................... 597
9.8.8.2.4 DurationOf..................................................................................................................................... 597
9.8.8.2.5 Iso8601DateTime.......................................................................................................................... 598
9.8.8.2.6 Iso8601DateTimeEncoding........................................................................................................... 598
9.8.8.2.7 Iso8601DateTimeStructure........................................................................................................... 599
9.8.8.2.8 timeInstant..................................................................................................................................... 599
9.8.8.2.9 TimeInstantValue.......................................................................................................................... 600
9.8.8.2.10 TimeOf........................................................................................................................................ 600
9.8.8.2.11 TimeOfDay.................................................................................................................................. 601
9.8.8.2.12 TimeScale.................................................................................................................................... 601
9.8.8.2.13 universalClock............................................................................................................................. 602
9.8.8.2.14 UTC............................................................................................................................................. 602
9.8.8.2.15 utcTimeInstant............................................................................................................................. 603
9.8.8.2.16 UtcTimeInstantValue.................................................................................................................. 603
9.8.9 Quantity Calculations............................................................................................................................................ 604
9.8.9.1 Quantity Calculations Overview............................................................................................................... 604
9.8.9.2 Elements.................................................................................................................................................... 607
9.8.10 Vector Calculations............................................................................................................................................. 607
9.8.10.1 Vector Calculations Overview................................................................................................................ 607
9.8.10.2 Elements.................................................................................................................................................. 609
9.8.11 Tensor Calculations............................................................................................................................................. 609
9.8.11.1 Tensor Calculations Overview................................................................................................................ 609
9.8.11.2 Elements.................................................................................................................................................. 611
9.8.12 Measurement Ref Calculations........................................................................................................................... 611
9.8.12.1 Measurement Ref Calculations Overview............................................................................................... 611
9.8.12.2 Elements.................................................................................................................................................. 612
A Annex: Example Model............................................................................................................................................................... 613
A.1 Introduction...................................................................................................................................................................... 613
A.2 Model Organization......................................................................................................................................................... 613
A.3 Definitions........................................................................................................................................................................ 614
A.4 Parts.................................................................................................................................................................................. 618
A.5 Parts Interconnection........................................................................................................................................................ 621

**OMG Systems Modeling Language (SysML) v2.0 Beta 1 xvii**


```
A.6 Actions............................................................................................................................................................................. 624
A.7 States................................................................................................................................................................................ 626
A.8 Requirements.................................................................................................................................................................... 629
A.9 Analysis............................................................................................................................................................................ 631
A.10 Verification.................................................................................................................................................................... 632
A.11 View and Viewpoint...................................................................................................................................................... 634
A.12 Variability...................................................................................................................................................................... 635
A.13 Individuals...................................................................................................................................................................... 636
```
**xviii OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**List of Tables**

1. Dependencies – Representative Notation...................................................................................................................................... 21
2. Annotations – Representative Notation......................................................................................................................................... 22
3. Packages – Representative Notation.............................................................................................................................................. 26
4. Definition and Usage – Representative Notation........................................................................................................................... 36
5. Attributes – Representative Notation............................................................................................................................................. 48
6. Enumerations – Representative Notation....................................................................................................................................... 50
7. Occurrences – Representative Notation......................................................................................................................................... 53
8. Items – Representative Notation.................................................................................................................................................... 59
9. Parts – Representative Notation..................................................................................................................................................... 61
10. Ports – Representative Notation................................................................................................................................................... 64
11. Connections – Representative Notation....................................................................................................................................... 68
12. Interfaces – Representative Notation........................................................................................................................................... 79
13. Allocations – Representative Notation........................................................................................................................................ 83
14. Actions – Representative Notation.............................................................................................................................................. 87
15. Control Node Definitions............................................................................................................................................................. 99
16. States – Representative Notation............................................................................................................................................... 111
17. Calculations – Representative Notation..................................................................................................................................... 119
18. Constraints – Representative Notation....................................................................................................................................... 122
19. Requirements – Representative Notation................................................................................................................................... 127
20. Analysis Cases - Representative Notation................................................................................................................................. 135
21. Verification Cases – Representative Notation........................................................................................................................... 138
22. Use Cases – Representative Notation........................................................................................................................................ 142
23. Views and Viewpoints – Representative Notation.................................................................................................................... 146
24. Diagrams – Representative Examples....................................................................................................................................... 151
25. Metadata – Representative Notation.......................................................................................................................................... 152
26. EBNF Notation Conventions..................................................................................................................................................... 158
27. Abstract Syntax Synthesis Notation........................................................................................................................................... 158
28. Grammar Production Definitions............................................................................................................................................... 159
29. Graphical BNF Conventions...................................................................................................................................................... 186
30. Implied Definition Subclassification Relationships................................................................................................................... 373
31. Implied Usage Subsetting Relationships................................................................................................................................... 374
32. Other Implied Relationships...................................................................................................................................................... 378
33. Standard View Definitions......................................................................................................................................................... 489

**OMG Systems Modeling Language (SysML) v2.0 Beta 1 xix**


**List of Figures**

1. SysML Language Architecture...................................................................................................................................................... 12
2. Elements....................................................................................................................................................................................... 236
3. Dependencies............................................................................................................................................................................... 237
4. Annotation.................................................................................................................................................................................... 237
5. Namespaces.................................................................................................................................................................................. 238
6. Imports......................................................................................................................................................................................... 239
7. Packages....................................................................................................................................................................................... 239
8. Definition and Usage................................................................................................................................................................... 240
9. Variant Membership.................................................................................................................................................................... 240
10. Attribute Definition and Usage.................................................................................................................................................. 256
11. Enumeration Definition and Usage............................................................................................................................................ 258
12. Occurrence Definition and Usage.............................................................................................................................................. 260
13. Event Occurrences..................................................................................................................................................................... 260
14. Item Definition and Usage......................................................................................................................................................... 266
15. Part Definition and Usage.......................................................................................................................................................... 268
16. Port Definition and Usage.......................................................................................................................................................... 270
17. Port Conjugation........................................................................................................................................................................ 271
18. Connectors as Usages................................................................................................................................................................ 276
19. Connection Definition and Usage.............................................................................................................................................. 276
20. Flow Connections...................................................................................................................................................................... 277
21. Interface Definition and Usage.................................................................................................................................................. 282
22. Allocation Definition and Usage............................................................................................................................................... 284
23. Action Definition and Usage..................................................................................................................................................... 286
24. Control Nodes............................................................................................................................................................................ 286
25. Performed Actions..................................................................................................................................................................... 286
26. Send and Accept Actions........................................................................................................................................................... 287
27. Assignment Actions................................................................................................................................................................... 287
28. Structured Control Actions........................................................................................................................................................ 288
29. State Definition and Usage........................................................................................................................................................ 308
30. State Membership...................................................................................................................................................................... 308
31. Exhibited States......................................................................................................................................................................... 309
32. Transition Usage........................................................................................................................................................................ 309
33. Calculation Definition and Usage.............................................................................................................................................. 322
34. Constraint Definition and Usage................................................................................................................................................ 324
35. Asserted Constraints.................................................................................................................................................................. 324
36. Requirement Definition and Usage............................................................................................................................................ 328
37. Satisfied Requirements.............................................................................................................................................................. 328
38. Concern Definition and Usage................................................................................................................................................... 329
39. Requirement Constraint Membership........................................................................................................................................ 329
40. Requirement Parameter Memberships....................................................................................................................................... 330
41. Case Definition and Usage......................................................................................................................................................... 343
42. Case Membership....................................................................................................................................................................... 343
43. Analysis Case Definition and Usage.......................................................................................................................................... 348
44. Verification Case Definition and Usage.................................................................................................................................... 351
45. Verification Membership........................................................................................................................................................... 352
46. Use Case Definition and Usage................................................................................................................................................. 355
47. Included Use Case...................................................................................................................................................................... 355
48. View Definition and Usage........................................................................................................................................................ 358
49. Viewpoint Definition and Usage............................................................................................................................................... 359
50. Rendering Definition and Usage................................................................................................................................................ 359
51. Expose Relationship................................................................................................................................................................... 360

**xx OMG Systems Modeling Language (SysML) v2.0 Beta 1**


52. View Rendering Membership.................................................................................................................................................... 360
53. Metadata Definition and Usage................................................................................................................................................. 370
54. State Space Representation action and calculation definitions.................................................................................................. 516
55. Model Organization for SimpleVehicleModel.......................................................................................................................... 613
56. Part Definition for Vehicle......................................................................................................................................................... 615
57. Part Definition for FuelTank Referencing Fuel it Stores........................................................................................................... 616
58. Axle and its Subclass FrontAxle................................................................................................................................................ 617
59. Example Definition Elements.................................................................................................................................................... 617
60. Part Usage for vehicle_b............................................................................................................................................................ 619
61. Parts Tree for vehicle_b............................................................................................................................................................. 620
62. Variant engine4Cyl.................................................................................................................................................................... 621
63. Parts Interconnection for vehicle_b........................................................................................................................................... 622
64. Action providePower................................................................................................................................................................. 624
65. Action flow for providePower................................................................................................................................................... 624
66. Action flow for transportPassenger........................................................................................................................................... 625
67. Vehicle States............................................................................................................................................................................. 627
68. Requirement Definition MassRequirement............................................................................................................................... 629
69. Requirements Group vehicleSpecification................................................................................................................................ 630
70. Analysis Case fuelEconomyAnalysis........................................................................................................................................ 631
71. Vehicle Mass Verification Test................................................................................................................................................. 633
72. Vehicle Safety View.................................................................................................................................................................. 634
73. Rendering of view vehiclePartsTree_Safety.............................................................................................................................. 635
74. Variability Model for vehicleFamily......................................................................................................................................... 635
75. Vehicle Individuals and Snapshots............................................................................................................................................ 637

**OMG Systems Modeling Language (SysML) v2.0 Beta 1 xxi**


**xxii OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 0 Preface.............................................................................................................................................................................................

### OMG

Founded in 1989, the Object Management Group, Inc. (OMG) is an open membership, not-for-profit computer
industry standards consortium that produces and maintains computer industry specifications for interoperable,
portable, and reusable enterprise applications in distributed, heterogeneous environments. Membership includes
Information Technology vendors, end users, government agencies, and academia.
OMG member companies write, adopt, and maintain its specifications following a mature, open process. OMG’s
specifications implement the Model Driven Architecture®(MDA®), maximizing ROI through a full-lifecycle
approach to enterprise integration that covers multiple operating systems, programming languages, middleware and
networking infrastructures, and software development environments. OMG’s specifications include: UML®
(Unified Modeling Language™); CORBA®(Common Object Request Broker Architecture); CWM™ (Common
Warehouse Metamodel); and industry-specific standards for dozens of vertical markets.
More information on the OMG is available athttps://www.omg.org/.

**OMG Specifications**

As noted, OMG specifications address middleware, modeling, and vertical domain frameworks. All OMG
Specifications are available from the OMG website at:https://www.omg.org/spec
All of OMG’s formal specifications may be downloaded without charge from our website. (Products implementing
OMG specifications are available from individual suppliers.) Copies of specifications, available in PostScript and
PDF format, may be obtained from the Specifications Catalog cited above or by contacting the Object Management
Group, Inc. at:
OMG Headquarters
9C Medway Road, PMB 274
Milford, MA 01757
USA
Tel: +1-781-444-0404
Fax: +1-781-444-0320
Email:pubs@omg.org
Certain OMG specifications are also available as ISO standards. Please consulthttps://www.iso.org
**Issues**
All OMG specifications are subject to continuous review and improvement. As part of this process we encourage
readers to report any ambiguities, inconsistencies, or inaccuracies they may find by completing the Issue Reporting
Form listed on the main web pagehttps://www.omg.org,under Specifications, Report an Issue.

**OMG Systems Modeling Language (SysML) v2.0 Beta 1 xxiii**


**xxiv OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 1 Scope.................................................................................................................................................................................................

The purpose of this standard is to specify the Systems Modeling Language™ (SysML), to guide the implementation
of conformant modeling tools, and to provide the basis for the development of material and other resources to train
users in the application of SysML.
SysML is a general-purpose modeling language for modeling systems that is intended to facilitate a model-based
systems engineering (MBSE) approach to engineer systems. It provides the capability to create and visualize models
that represent many different aspects of a system.This includes representing the requirements, structure, and
behavior of the system, and the specification of analysis cases and verification cases used to analyze and verify the
system. The language is intended to support multiple systems engineering methods and practices. The specific
methods and practices may impose additional constraints on how the language is used.
SysML is defined as an extension of the Kernel Modeling Language (KerML), which provides a common, domain-
independent language for building semantically rich and interoperable modeling languages. SysMLalso provides
acapability toprovide further language extensions. It is anticipated that SysML will be customized using this
language extension mechanism to model more specialized domain-specific applications, such as automotive,
aerospace, healthcare, and information systems, as well as disciplinespecific extensions such as safety and
reliability.
**Note.** Definitions of _system_ and _systems engineering_ can be found in _ISO/IEC 15288 Systems and Software
Engineering – System Life Cycle Process._

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 1**


**2 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 2 Conformance.....................................................................................................................................................................................

This specification defines the Systems Modeling Language (SysML), a language used to construct _models_ of
systems (whether they are real, planned or imagined). The specification comprises this document together with the
content of the machine-readable files listed on the cover page. If there are any conflicts between this document and
the machine-readable files, the machine-readable files take precedence.
A _SysML model_ shall conform to this specification only if it can be represented according to the syntactic
requirements specified inClause 8. The model may be represented in a form consistent with the requirements for the
SysML concrete syntax (which includes both textual and graphical notation), in which case it can be parsed (as
specified in8.2) into an abstract syntax form, or it may be represented directly in an abstract syntax form.
A _SysMLmodeling tool_ is a software application that creates, manages, analyzes, visualizes, executes or performs
other services on SysML models. A tool can conform to this specification in one or more of the following ways.

1. _Abstract Syntax Conformance._ A tool demonstrating Abstract Syntax Conformance provides a user
    interface and/or API that enables instances of SysML abstract syntax metaclasses to be created, read,
    updated, and deleted. The tool must also provide a way to validate the well-formedness of models that
    corresponds to the constraints defined in the SysML metamodel. A well-formed model represented
    according to the abstract syntax is syntactically conformant to SysML as defined above. (See8.3.)
2. _Concrete Syntax Conformance._ A tool demonstrating Concrete Syntax Conformance provides a user
    interface and/or API that enables instances of SysML concrete syntax notation to be created, read,
    updated, and deleted. Note that a conforming tool may also provide the ability to create, read, update and
    delete additional notational elements that are not defined in SysML. Concrete Syntax Conformance
    implies Abstract Syntax Conformance, in that creating models in the concrete syntax acts as a user
    interface for the abstract syntax. However, a tool demonstrating Concrete Syntax Conformance need not
    represent a model internally in exactly the form modeled for the abstract syntax in this specification. (See
    8.2.)
    There are two variants of Concrete Syntax Conformance:
       a. _Textual Notation Conformance._ A tool demonstrating Textual Notation Conformance provides
          Concrete Syntax Conformance for the SysML textual notation. (See8.2.2)
       b. _Graphical Notation Conformance._ A tool demonstrating Graphical Notation Conformance
          provides Concrete Syntax Conformance for the SysML graphical notation. As part of this, the
          tool shall also support the textual notation at least to the extent necessary to properly render text
          in the graphical notation, and may also fully support the textual notation in conjunction with the
          graphical notation. (See8.2.3.)
3. _Semantic Conformance._ A tool demonstrating Semantic Conformance provides a demonstrable way to
    interpret a syntactically conformant model (as defined above) according to the SysML semantics, e.g., via
    semantic model analysis or model execution. Semantic Conformance implies Abstract Syntax
    Conformance, in that the semantics for SysML are only defined on well-formed models represented in the
    abstract syntax. (See8.4and9.2.)
4. _Model Interchange Conformance._ A tool demonstrating model interchange conformance can import and/
    or export syntactically conformant SysML models (as defined above) as a _project interchange file_ as
    specified in [KerML, Clause 10], with the following further conditions:
       ◦ The project interchange file shall use the standard.kpar(KerML Project Archive) extension.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 3**


```
◦ All model interchange files in the project interchange file shall be SysML models. Textual
notation files shall use the extension.sysml.
◦ The metadata for the project interchange file shall identify the metamodel using the normative
SysML metamodel URI as given for this specification (i.e.,https://www.omg.org/spec/
SysML/ yymmnn , where yymmnn is the current date-based version identifier).
```
5. _Domain Library Support._ In addition to the Systems Model Library, a conformant tool may provide one or
    more of the domain model libraries specified inClause 9.
Every conformant SysML modeling tool shall demonstrate at least Abstract Syntax Conformance and Model
Interchange Conformance. In addition, such a tool may demonstrate Concrete Syntax Conformance and/or Semantic
Conformance, both of which are dependent on Abstract Syntax Conformance. The tool may also provide Domain
Library Support.

**4 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 3 Normative References......................................................................................................................................................................

The following normative documents contain provisions which, through reference in this text, constitute provisions
of this specification.
[KerML] _Kernel Modeling Language (KerML),_ Version 1.0
https://www.omg.org/spec/KerML/1.0
[MOF] _Meta Object Facility,_ Version 2.5.1
https://www.omg.org/spec/MOF/2.5.1
[OCL] _Object Constraint Language,_ Version 2.4
https://www.omg.org/spec/OCL/2.4
[SMOF] _MOF Support for Semantic Structures,_ Version 1.0
https://www.omg.org/spec/SMOF/1.0
[SysML v1] _OMG Systems Modeling Language (SysML),_ Version 1.7
https://www.omg.org/spec/SysML/1.7
[UML] _Unified Modeling Language (UML),_ Version 2.5.1
https://www.omg.org/spec/UML/2.5.1
The following references were used in the definition of the Quantities and Units model library (see9.8):
[GUM] _JCGM 100:2008 and ISO/IEC Guide 98-3, Evaluation of measurement data - Guide to the expression of
uncertainty in measurement_
https://www.bipm.org/en/publications/guides/#gum
[ISO 80000-1] _ISO 80000-1:2009, Quantities and units - Part 1: General_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-1:ed-1:v1:en
[ISO 80000-2] _ISO 80000-2:2019, Quantities and units - Part 2: Mathematical signs and symbols to be used in the
natural sciences and technology_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-2:ed-2:v1:en
[ISO 80000-3] _ISO 80000-3:2019, Quantities and units - Part 3: Space and Time_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-3:ed-2:v1:en
[ISO 80000-4] _ISO 80000-4:2019, Quantities and units - Part 4: Mechanics_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-4:ed-2:v1:en
[ISO 80000-5] _ISO 80000-5:2019, Quantities and units - Part 5: Thermodynamics_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-5:ed-2:v1:en
[IEC 80000-6] _IEC 80000-6:2008, Quantities and units - Part 6: Electromagnetism_
https://www.iso.org/obp/ui/#iso:std:iec:80000:-6:ed-1:v1:en,fr
[ISO 80000-7] _ISO 80000-7:2019, Quantities and units - Part 7: Light_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-7:ed-2:v1:en
[ISO 80000-8] _ISO 80000-8:2020, Quantities and units - Part 8: Acoustics_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-8:ed-2:v1:en

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 5**


[ISO 80000-9] _ISO 80000-9:2019, Quantities and units - Part 9: Physical chemistry and molecular physics_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-9:ed-2:v1:en
[ISO 80000-10] _ISO 80000-10:2019, Quantities and units - Part 10: Atomic and nuclear physics_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-10:ed-2:v1:en
[ISO 80000-11] _ISO 80000-11:2019, Quantities and units - Part 11: Characteristic numbers_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-11:ed-2:v1:en
[ISO 80000-12] _ISO 80000-12:2019, Quantities and units - Part 12: Solid state physics_
https://www.iso.org/obp/ui/#iso:std:iso:80000:-12:ed-2:v1:en
[IEC 80000-13] _IEC 80000-13:2008, Quantities and units - Part 13: Information science and technology_
https://www.iso.org/obp/ui/#iso:std:iec:80000:-13:ed-1:v1:en
[IEC 80000-14] _IEC 80000-14:2008, Quantities and units - Part 14: Telebiometrics related to human physiology_
https://www.iso.org/obp/ui/#iso:std:iec:80000:-14:ed-1:v1:en
[NIST SP-811] _NIST Special Publication 811, The NIST Guide for the use of the International System of Units_
(In particular its Appendix B "Conversion Factors")
https://www.nist.gov/pml/special-publication-811
[VIM] _JCGM 200:2012 and ISO/IEC Guide 99, International vocabulary of metrology - Basic and general concepts
and associated terms (VIM)_
https://www.bipm.org/en/publications/guides/#vim
[ISO 8601-1] _ISO 8601-1:2019 (First edition) Date and time — Representations for information interchange —
Part 1: Basic rules_
https://www.iso.org/standard/70907.html

**6 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 4 Terms and Definitions......................................................................................................................................................................

Various terms and definitions are specified throughout the body of this specification.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 7**


**8 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 5 Symbols............................................................................................................................................................................................

A concrete syntax for SysML is specified in subclause 8.2 of this specification.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 9**


**10 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 6 Introduction.....................................................................................................................................................................................

**6.1Document Overview**
The Systems Modeling Language (SysML) is a general-purpose modeling language for modeling systems that is
intended to facilitate a model-based systems engineering (MBSE) approach to engineer systems. This document
provides the standard specification for SysML Version 2 (SysML v2). SysML v2 is intended to enhance the
precision, expressiveness, interoperability, and the consistency and integration of the language relative to SysML
Versions 1.0 to 1.7 [SysML v1].
SysML v1 was specified as a profile of the Unified Modeling Language v2 [UML]. SysML v2, on the other hand, is
specified as a metamodel extending the Kernel metamodel from the Kernel Modeling Language [KerML]. In order
to facilitate the transition from SysML v1 to SysML v2, this standard also specifies a formal transformation from
models using the SysML v1.7 profile of UML to models using the SysML v2 metamodel (see Annex C).
This document specifies the textual and graphical concrete syntax, abstract syntax, and semantics for SysML v2.
The SysML v2 textual notation (see8.2.2) and the SysML v2 graphical notation (see8.2.3) provide the concrete
syntax representation of the SysML v2 abstract syntax (see8.3). The SysML v2abstract syntax extends the Kernel
abstract syntax, providing specialized constructs for modeling systems (as shown inFig. 1). Further, the Systems
Library (see9.2) is a model library that extends the Kernel Library to provide the semantic specification for SysML
v2 (see8.4; see also [KerML] on the use of model libraries for semantic specification). Finally, SysML v2 provides
an additional set of Domain Libraries (see9.4and following) to provide a set of reference models in various
domains important to systems modeling (such as Analysis and Quantities and Units).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 11**


**Figure 1. SysML Language Architecture**

**6.2Document Organization**
The rest of this document is organized into three major clauses.

- Clause 7describes SysML from a user point of view. Its subclauses describe the modeling constructs in
    SysML, including for each a general overview, related abstract syntax diagrams and a description of the
    textual and graphical notation. The overviews in this clause should be considered informative. The
    abstract syntax and notation subclauses, however, are normative, including descriptions of the processing
    of the textual notation and its relationship to the graphical notation and the abstract syntax.
- Clause 8provides the normative specification of the metamodel that defines the SysML language. This
    includes the concrete syntax (textual and graphical notations), the abstract syntax and the semantics for the
    language. The SysML abstract syntax and semantics are formally extensions of the Kernel abstract syntax
    and semantics provided by KerML (as discussed in6.1). However, this clause does not cover details of the
    Kernel metamodel, which are included by normative reference to the KerML specification [KerML].
- Clause 9specifies a set of model libraries defined in SysML itself. The Systems Library extends the
    Kernel Library from [KerML] in order to provide systems-modeling-specific semantics to SysML
    language constructs. The Domain Libraries provide domain-specific models on which users can draw

**12 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


when creating their own models. Each model library is described with a set of subclauses that covers each
of the top-level packages in the model library, referred to as its _library models._
These clauses are followed by informativeAnnex A, which presents an example model using the SysML language
as defined in this specification to illustrate how the language features can be used to model a system.
In addition, Clause 10 of [KerML] on Model Interchange is included by reference as a normative part of this
specification in order to define allowable methods for interchanging SysML models.

**6.3Document Conventions**
The following stylistic conventions are applied in the Notation subclauses inClause 7(Language Description), in
the abstract syntax, concrete syntax and semantics descriptions ofClause 8(Metamodel) and in the element
descriptions ofClause 9(Model Library) when model elements are referenced by name in body text paragraphs.
However, they are _not_ used in Overview subclauses ofClause 7, which are written in a more descriptive and
colloquial style, and should be considered informative rather than normative.

1. Names of metaclasses from the SysML abstract syntax model appear exactly as in the abstract syntax,
    including capitalization. When used as English common nouns, e.g., "PartDefinition, "ActionUsage", they
    referto instances of the metaclass (in models), e.g., "A PartUsage must be defined by a PartDefinition"
    refers to instances of the metaclasses PartUsage and PartDefinition that reside in models. This can be
    modified using the term "metaclass" as necessary to refer to the metaclass itself instead of its instances,
    e.g., "The PartDefinition metaclass is contained in the Parts abstract syntax package."
2. Names of properties of metaclasses in the text are styled in"code" font.When used as English common
    nouns, e.g., “anownedPartof a Definition”, "multipleownedPartsof a Definition",they refer to values
    of the properties.This can be modified using the term "metaproperty" as necessary to refer to the
    metapropertyitself instead of its values, e.g., "TheownedPartsmetapropertyis an attribute of the
    Definition metaclass."
3. Names of classes and features of elements from a SysML model are styled the same as abstract syntax
    metaclass and property names, but put in italics, and always in a "code" font. This includes elements from
    any of the SysML Model Libraries (e.g., " _Action_ " and " _quantity_ ") and elements referenced from
    sample user models (e.g., " _Vehicle_ " and " _wheels")._
In addition, the following additional conventions used in the Notation subclauses withinClause 7for the SysML
textual notation.
1. In all cases, text in the SysML textual notation is styled in a "code" font.
2. When individual keywords are referenced, they are written in boldface, e.g., "PartUsages are declared
using the **part** keyword."
3. Symbols (such as~and:>>) and short segments of textual notation (but longer than an individual name)
may be written in-line, without being italic or bold, but still in "code" font.
4. Longer samples of textual notation are written in separate paragraphs, indented relative to body
paragraphs.
The grammar of the textual notation and its mapping to the abstract syntax is specified using a specialized _extended
Backus-Naur form_ (EBNF) notation, with conventions described in8.2.2.1.1. For the graphical notation, this EBNF
notation is further extended to allow the use of graphical symbols within productions (see8.2.3.1).

**6.4Acknowlegements**
The primary authors of this specification document and the syntactic and semantic models defined in it are:

- Sanford Friedenthal, SAF Consulting

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 13**


- Ed Seidewitz, Model Driven Solutions
- Roger Burkhart, Thematix Partners
- Eran Gery, IBM
- Hisashi Miyashita, Mgnite
- Hans Peter de Koning, DEKonsult
Other contributors include:
- Oystein Haugen, Østfold University College
- Tomas Juknevicius, Dassault Systèmes
- Charles Krueger, BigLever Software
The specification was formally submitted for standardization by the following organizations:
- 88Solutions Corporation
- Dassault Systèmes
- GfSE e.V.
- IBM
- INCOSE
- Intercax LLC
- Lockheed Martin Corporation
- MITRE
- Model Driven Solutions, Inc.
- PTC
- Simula Research Laboratory AS
- Thematix Partners LLC
However, work on the specification was also supported by over 200 people in over 80 organizations that participated
in the SysML v2 Submission Team (SST), by contributing use cases, providing critical review and comment, and
validating the language design. The following individuals had leadership roles in the SST:
- Manas Bajaj, Intercax LLC (API and services development lead)
- Yves Bernard, Airbus (v1 to v2 transformation co-lead)
- Bjorn Cole, Lockheed Martin Corporation (metamodel development co-lead)
- Sanford Friedenthal, SAF Consulting (SST co-lead, requirements V&V lead)
- Charles Galey, Lockheed Martin Corporation (metamodel development co-lead)
- Karen Ryan, Siemens (metamodel development co-lead)
- Ed Seidewitz, Model Driven Solutions (SST co-lead, pilot implementation lead)
- Tim Weilkiens, oose (v1 to v2 transformation co-lead)
The specification was prepared using CATIA No Magic modeling tools and the OpenMBEE system for model
publication (http://www.openmbee.org), with the invaluable support of the following individuals:
- Tyler Anderson, No Magic/Dassault Systèmes
- Christopher Delp, Jet Propulsion Laboratory
- Ivan Gomes, Twingineer
- Doris Lam, Jet Propulsion Laboratory
- Robert Karban, Jet Propulsion Laboratory
- Christopher Klotz, No Magic/Dassault Systèmes
- John Watson, Lightstreet Consulting

**14 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The following individuals made significant contributions to the SysML v2 pilot implementation developed by the
SST in conjunction with the development of this specification:

- Ivan Gomes, Twingineer
- Hisashi Miyashita, Mgnite
- Miyako Wilson, Georgia Institute of Technology
- Santiago Leon, Tom Sawyer
- William Piers, Obeo
- Tilo Schreiber, Siemens
- Zoltán Ujhelyi, IncQuery Labs

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 15**


**16 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 7 Language Description.....................................................................................................................................................................

(Informative)

**7.1Language Overview**
The System Modeling Language (SysML) contains concepts that are used to model systems, their components, and
the external environment in a context. It extends the Kernel Modeling Language (KerML) asspecified in the KerML
specification [KerML]. SysML directly uses some elements of KerML, but most SysML elements are
specializations of KerML elements.
This clause provides an informative description of all these language concepts in their context of use in SysML.
Clause 8gives the full definition of the SysML metamodel, which is the normative specification for implementing
the language. In contrast, the description in this clause focuses on how the various constructs of the language are
used, along with the Systems Model Library (see9.2), to construct models. While non-normative, it is intended to be
precise and consistent with the normative specification of the language.
SysML directly uses the following concepts from KerML:

- _Elements_ and _relationships_ that define the basic graph structure of a model (see7.2).
- _Dependencies_ between modeling elements (see7.3).
- _Annotations_ for attaching metadata to a model, including comments and textual representations (see7.4).
- _Namespaces_ that contain and name elements, and, particularly, _packages_ used to organize the elements in
    a model (see7.5).
- _Specialization_ of elements that specify types, including subclassification, subsetting, redefinition and
    feature typing (see7.6).
- _Expressions_ can be used to specify calculations, case results, constraints and formal requirements. The full
    KerML expression sub-language is available in SysML, as described in the KerML specification. The
    description of this sub-language is not repeated in the SysML specification document.
The modeling constructs specific to SysML, as specified in subclauses7.6through7.26, are built on the
KerMLfoundation, and cover the following areas:
- Fundamental aspects of constructing a model, including:
◦ The general pattern of _definition_ and _usage_ , which is applied to many of the SysML language
constructs (see7.6). The pattern of definition and usage elementsfacilitates model reuse, such
that a concept can be defined once and then used in many different contexts. A usage element
can be further specialized for its specific context.
◦ The modeling of _variability,_ which includes the definition of _variation_ points within a
modelwhere choices can be made to select a specific _variant,_ and the selection of a particular
variant mayconstrain theallowable choices at other variation points. A system can be
_configured_ by making appropriate choices at each of the variation points of a variability model,
consistent with specified constraints. Variation points can be defined in any of the specific
modeling areas listed below, so the ability to model variability is built into the base syntax of
definitions and usages (see7.6).
- The modeling of attributive information about things, including:
◦ _Attributes_ that specify characteristics of something thatcan bedefined by simple or compound
data types,and dimensional quantities such as mass, length, etc. (see7.7).
◦ _Enumerations_ that are attributes restricted to a specified set of enumerated values (see7.8).
- The modeling of _occurrences_ with temporal and spatial extent. Temporal extent enables an occurrence to
be represented at specific points in time, over a duration in time, or over an entire lifetime. Spatial extent
enables an occurrence to be represented at a position and orientation with respect to a coordinate frame,
and to have a shape and size (see7.9).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 17**


- The modeling of _individuals_ with specific identities (see7.9).
- The modeling of _structure_ to representhow parts are decomposed, interconnected and classified, and
    includes:
       ◦ _Items_ that may flow through a process or systemor be stored by a system (see7.10).
       ◦ _Parts_ that arethe foundational units of structure, which can be composed and interconnected, to
          form composite parts and entire systems (see7.11).
       ◦ _Ports_ that define connection points on parts that enable interactions between parts (see7.12).
       ◦ _Connections_ (see7.13) and _interfaces_ (see7.14) that define how parts and ports are
          interconnected.
       ◦ _Allocations_ that assign responsibility for realizing the features of one element by another
          element (see7.15).
- The modeling of _behavior,_ which specifies how parts interact andincludes:
    ◦ _Actions_ performed by a part, including their temporal ordering, and the flows of items between
       them (see7.16).
    ◦ _States_ exhibited by a part, the allowable _transitions_ between those states, and theactions enabled
       in a state or during a transition(see7.17).
- The modeling of _calculations_ that are parameterized expressions that can be evaluated to produce specific
    results (see7.18).
- The modeling of _constraints,_ which specify conditions that can be evaluated as true or false, or asserted to
    be true or false (see7.19).
- The modeling of _requirements,_ which is a special kind ofconstraintthat a _subject_ must satisfy to be a
    valid solution (see7.20).
- The modeling of _cases,_ which define the steps required to produce a desired result relative to a _subject_ ,
    possibly also involving external _actors,_ to achieve a specific _objective_ (see7.21), including:
       ◦ _Analysis cases,_ whose steps are the _actions_ necessary to analyze asubject (see7.22).
       ◦ _Verification cases,_ whose objective is to verify how arequirement is satisfied by the subject (see
          7.23).
       ◦ _Use cases,_ that specify required behavior of the subject with the objective of providing a
          measurable benefit to one or more external actors (see7.24).
- The modeling of _viewpoint_ s that specify information of interest bya set of stakeholders, and _views_ that
    specify a query of the model, and a rendering of the query results, that is intended to satisfy a particular
    viewpoint (see7.25).
- The modeling of user-defined _metadata_ that allows for both simple tagging of elements with additional
    model-level information and more sophisticated semantic extension of the SysML language. In a similar
    way that SysML extends KerML, modelers can use this metadata capability to build domain and user-
    specific extensions ofSysML, both syntactically and semantically. This allows SysML to be highly
    adaptable for specific application domains and user needs, while maintaining a high level of underlying
    standardization and tool interoperability. (See7.26.)
It should be noted that SysML does not contain specific language constructs called system, subsystem, assembly,
component, and many other commonly used terms. An entity with structure and behavior in SysML is represented
simply as a part (see7.11). The language provides straightforward extension mechanisms to specify terminology
that is appropriate for the domain of interest.

**7.2Elements and Relationships
7.2.1Elements and Relationships Overview**
_Metamodel references:_

- _Textual notation,8.2.2.2_
- _Graphical notation,8.2.3.2_
- _Abstract syntax,8.3.2_
- _Semantics, none_

**18 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


_Elements_ are the constituents of a model. Some elements represent _relationships_ between other elements, known as
the _related elements_ of the relationship. One of the related elements of a relationship may be the _owning_ related
element of the relationship. If the owning related element of a relationship is deleted from a model, then the
relationship is also deleted. Some of the related elements of a relationship (distinct from the owning related element,
if any) may be _owned_ related elements. If a relationship has owned related elements, then, if the relationship is
deleted from a model, all its owned related elements are also deleted.
The _ownedrelationships_ of an element are all those relationships for which the element is the owning related
element. The _owned elements_ of an element are all those elements that are owned related elements of the owned
relationships of the element (notice the extra level of indirection through the owned relationships). The _owning
relationship_ of an element (if any) is the relationship for which the element is an owned related element (of which
the element can have at most one). The _owner_ of an element (if any) is the owning related element of the owning
relationship of the element (again, notice the extra level of indirection through the owning relationship).
The deletion rules for relationships imply that, if an element is deleted from a model, then all its owned relationships
are also deleted and, therefore, all its owned elements. This may result in a further cascade of deletions until all
deletion rules are satisfied. An element that has no owner acts as the _root element_ of an _ownership tree structure,_
such that all elements and relationships in the structure are deleted if the root element is deleted. Deleting any
element other than the root element results in the deletion of the entire subtree rooted in that element.
Graphically, non-relationship elements are generally represented using a box-like shape or other icon, while
relationships are shown using lines connecting the symbols for the related elements. However, in some cases,
additional shapes may be attached to relationship lines in order to present additional information. The specific
conventions for such graphical notations are covered in subsequent subclauses.

**7.2.2Elements**
Various specific kinds of model elements in SysML are described in subsequent subclauses. However, there are
certain concepts that apply to all model elements.
Every element has a unique identifier known as its _element ID_. The properties of an element can change over its
lifetime, but its element ID does not change after the element is created. An element may also have additional
identifiers, its _alias IDs,_ which may be assigned for tool-specific purposes. The SysML notation, however, does not
have any provision for specifying element or alias IDs, since these are expected to be managed by the underlying
modeling tooling. Instead, an element can be given a _name_ and/or a _short name,_ and it can also have any number of
alias names relative to one or more namespaces (see7.5).
In most cases, an element is _declared_ using a keyword indicating the _kind_ of element it is (e.g., **part def** or
**attribute** ). The declaration of an element may also specify a short name and/or name for it, in that order. The
short name is distinguished by being surrounded by the delimiting characters<and>.
**part** <'1.2.4'> myName;
While the language makes no formal distinction between names and short names, the intent is that the name of an
element should be fully descriptive, particularly in the context of the definition of the element, while the short name,
if given, should be an abbreviated name useful for referring to the element. Note also that it is not required to specify
either a name or a short name for an element. However, unless at least one of these is given, it is not possible to
reference the element using the textual notation (though it is still possible to show it in relationships on graphical
diagrams).
Names and short names can contain essentially any printable characters (and certain control characters). However,
when written in the textual notation, they must be represented with a specific lexical structure, which has two
variants.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 19**


1. A _basic name_ is one that can be lexically distinguished in itself from other parts of the textual notation.
    The initial character of a basic name must be a lowercase letter, an uppercase letter or an underscore. The
    remaining characters of a basic name can be any character allowed as an initial character or any digit.
    However, a reserved word may not be used as a name, even though it has the form of a basic name (see
    8.2.2.1.2for the list of the reserved words in SysML).
    Vehiclepower_line
2. An _unrestricted name_ provides a way to represent a name that contains any character. It is represented as a
    non-empty sequence of characters surrounded by single quotes. The name consists of the characters _within_
    the single quotes – the single quotes are _not_ included as part of the represented name. The characters
    within the single quotes may not include non-printable characters (including backspace, tab and newline).
    However, these characters may be included as part of the name itself through use of an escape sequence.
    In addition, the single quote character or the backslash character may only be included within the name by
    using an escape sequence.
    '+''circuits in line'
    'On/Off Switch''Ångström'

An _escape sequence_ is a sequence of two text characters starting with a backslash as an escape character,
which actually denotes only a single character (except for the newline escape sequence, which represents
however many characters is necessary to represent an end of line in a specific implementation). See [KerML,
8.2.2.3] for a complete description of unrestricted names and escape sequences.
In addition to its declaration, the representation for an element may also list other elements _owned_ by the containing
element. In the textual notation, such owned elements are shown represented as a _body_ delimited by curly braces
{...}, particularly when the owning element is a namespace (see7.5). In the graphical notation, owned elements may
be shown in _compartments_ within the symbol representing the owning element, particularly when the owning
element is a definition or usage (see7.6.1).

**7.2.3Relationships**
A relationship is a kind of element that relates two or more other elements. Some relationships are constrained to
have exactly two related elements (i.e., _binary_ relationships) while others may have more. The related elements of
relationships are ordered. A relationship may designate certain of its related elements as _sources_ with the rest being
_targets_. In this case, the relationship is said to be _directed_ from the sources to the targets. An _undirected_ relationship
simply designates all its related elements to be targets, with no source elements.
A relationship may also be the source or target of other relationships. In particular, a relationship may be annotated
by being the target of an annotation relationship (see7.4). In some cases, the annotating element may be owned by
the annotated relationship via the annotation relationship, particularly in the case of a documentation comment (see
8.2.2.4.2).

**7.3Dependencies
7.3.1Dependencies Overview**
_Metamodel references:_

- _Textual notation,8.2.2.3_
- _Graphical notation,8.2.3.3_
- _Abstract syntax,8.3.3_

**20 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


- _Semantics, none_
A _dependency_ is a kind of relationship between any number of client (source) and supplier (target) elements. This
implies that a change to a supplier element may result in a change to a client element. Dependencies can be useful
for representing relationships between elements in anabstract way.For example, a dependency can be used to
represent thatan upper layer ofan architecture stack may depend on alower layer ofthe stack. A dependency can
also be extended to reflect more specialized relationships, such as refinement (e.g., by using user-defined keywords,
see7.26).
**Table 1. Dependencies – Representative Notation
Element Graphical Notation Textual Notation**

```
Dependency
```
```
dependencyto Package1;Package2
```
```
Dependency - nary
```
```
dependency Package2 Package1,
to Package3, Package4;
```
**7.3.2Dependency Declaration**
A dependency is declared textually using the keyword **dependency**. The client elements of the dependency are then
given as a comma-separated list of qualified names following the keyword **from** , followed by a similar list of the
supplier elements after the keyword **to**. If no short name or name is given for the dependency, then the keyword
**from** may be omitted.
**dependencyfrom** 'Application Layer'Use **to** 'Service Layer';
// 'Service Layer' is the client of this dependency, not its name. **dependency** 'Service Layer'
**to** 'Data Layer', 'External Interface Layer';
A dependency declaration may also optionally have a body containing any annotating elements owned by the
dependency via annotation relationships (see7.4).
**dependencyto** 'Data Layer', 'External Interface Layer' {'Service Layer'
/* 'Service Layer' is the client of this dependency,* not its name. */
}

**7.4Annotations**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 21**


**7.4.1Annotations Overview**
_Metamodel references:_

- _Textual notation,8.2.2.4_
- _Graphical notation,8.2.3.4_
- _Abstract syntax,8.3.4_
- _Semantics, none_
An _annotating element_ is an element that is used to provide additional information about other elements. An
annotation is a relationship between an annotating element and an annotated element that is being described. An
annotating element can annotate multiple annotated elements, and each element can have multiple annotations.
A _comment_ is one kind of annotating element that is used to provide textual descriptions about other elements.
Comments can be members of namespaces and, therefore, can be named. Such member comments may be about the
namspace that owns them, or they may be about different elements. _Documentation_ is a distinguished kind of
comment used to document the annotated element. Documentation comments always annotate a single element,
which is their owning element.
A _textualrepresentation_ is an annotating element whose textual body provides a representation of the annotated
element in a specifically named language. This representation may be in the SysML textual notation or it may be in
another language. If the named language is machine-parsable, then the body text should be legal input text as
defined for that language. In particular, annotating a SysML model element with a textual annotation in a language
other than SysML can be used as a semantically "opaque" element specified in the other language.
It is also possible to annotate elements with user-defined _metadata,_ allowing both syntactic and semantic extension
of SysML. This capability is described in7.26.
**Table 2. Annotations – Representative Notation
Element Graphical Notation Textual Notation**
Comment /*This is a comment.*/

```
Comment comment /*This is a comment.*/Comment1
```
```
Documentation doc documentation.*//*This is
```
```
Documentation
```
```
doc /*This is<Document1>
documentation.*/
```
**22 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Textual
Representation
```
```
rep language "language1" /* body1 */
or
language body1 */"language1" /*
```
```
Annotation
```
```
comment part1::attribute1 about
/* The annotated element* is attribute1. */
```
```
Annotation-
Documentation
```
```
partdoc part1 : Part1 {/*
documentation-text */ port p1 : P1;
} port p2 : P2;
```
```
Annotation-Textual
Representation
```
```
calc defrepabout square(x);square
language /* def"Python"
square(x:float)->float:* return x**2
*/
or
calclanguagedef square(x) {"Python"
/* def square(x):* return x**2
} */
```
```
Documentation
Compartment
```
```
doc /*This is a
documentation*compartment.*/
```
**7.4.2Comments and Documentation**
The full declaration of a comment begins with the keyword **comment** , optionally followed by a short name and/or
name (see7.2). One or more qualified names of annotated elements for the comment, separated by commas, are then

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 23**


given after the keyword **about** , indicating that the comment has annotation relationships to each of the identified
elements. Thebodyof the comment is written lexically as text between/*and*/delimiters.
**itempart** A;B;
**comment** /* This is the comment body text. */Comment1 **about** A, B

If the comment is an owned member of a namespace (see7.5), then the explicit identification of annotated elements
can be omitted, in which case the annotated element is implicitly the containing namespace. Further, in this case, if
no short name or name is given for the comment, then the **comment** keyword can also be omitted.
**packagecomment** P { C /* This is a comment about P. */

} /* This is also a comment about P. */
A documentation comment is notated similarly to a regular comment, but using the keyword **doc** rather than
**comment**. The documenting element of documentation is always the owning element of the documentation.
**partdoc** X {X_Comment
**doc** /* This is a documentation comment about X. *//* This is more documentation about X. */
}
When a comment is written in the textual notation, the actualbodytext of the comment is extracted from the lexical
comment body according to the rules given in the KerML specification [KerML, 8.2.3.3.2]. The body text of a
comment can include markup information (such as HTML), and a tool may graphically display such text as rendered
according to the markup. However, marked up "rich text" for a comment is stored in the comment body in plain text
including all mark up text, with all line terminators and white space included as entered, other than what is removed
according to the rules referenced above.

**7.4.3Textual Representation**
A textual representation is notated similarly to a regular comment, but with the keyword **rep** used instead of
**comment**. As for documentation, a textual representation is always owned by its represented element. In particular,
if the textual representation is an owned member of a namespace (see7.5), then the represented element is the
containing namespace. A textual representation declaration must also specify thelanguageas a literal string
following the keyword **language**. If the textual representation has no short name or name, then the **rep** keyword
can also be omitted.
**partattributedef** C { x: Real;
**assertrep** x_constraint {inOCL **language** "ocl"
} /* self.x > 0.0 */
} **action def** setX(c : C, newX : Real) {
**language** /* c.x = newX;"alf"
* WriteLine("Set new x");*/
}

**24 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The lexical comment text given for a textual representation is processed as for regular comment text, and it is the
result after such processing that is the textual representationbodyexpected to conform to the named language.
**Note.** Since the lexical form of a comment is used to specify the textual representationbody, it is not possible to
include comments of a similar form in thebodytext.
The language name in a textual representation is case insensitive. The name can be of a natural language, but will
often be for a machine-parsable language. In particular, there are recognized standard language names.
If the language is"sysml", then the body of the textual representation must be a legal representation of the
represented element in the SysML textual notation. A tool can use such a textual representation to record the original
SysML notation text from which an element is parsed. Other standard language names that can be used in a textual
representation include"kerml","ocl", and"alf", in which case the body of the textual representation must be
written in the Kernel Modeling Language [KerML], Object Constraint Language [OCL] or the Action Language for
fUML [Alf], respectively. (This is the same set of standard language names as in [KerML, 7.2.4.3, 8.3.2.3], with the
addition of"sysml".)
However, for any other language than"sysml", the SysML specification does not define how the body text is to be
semantically interpreted as part of the model being represented. An element with no other definition than a textual
representation in a language other than SysML is essentially a semantically "opaque" element specified in the other
language. Nevertheless, a conforming SysML tool may (but is not required to) interpret such an element consistently
with the specification of the named language.

**7.5Namespaces and Packages
7.5.1Namespaces Overview**
_Metamodel references:_

- _Textual notation,8.2.2.5_
- _Graphical notation,8.2.3.5_
- _Abstract syntax,8.3.5_
- _Semantics, none_
A _namespace_ is a kind of element that can contain other elements and provide names for them. The elements
contained in a namespace are referred to as its _memberelements.Membership_ is a kind of relationship that relates a
namespace to its members. A membership relationship can specify the name by which its member element is known
relative to the containing namespace and whether the element membership is visible outside the namespace or not
(see7.5.2).
An element may be _owned_ via its membership in a namespace. When a namespace is deleted, all such owned
members will also be deleted. An element may also have a membership in a namespace without being owned by the
namespace. In this case, the membership may introduce an _alias_ name for the element relative to the namespace.
Note that it is possible for an element to have both owning and non-owning memberships with the same namespace,
but it can have at most one owning membership across all namespaces.
An _import_ relationship allows one namespace to import memberships from another namespace (see7.5.3). The
member elements from imported memberships become (unowned) members of the importing namespace in addition
to being members of the imported namespace. In particular, this allows members of the imported namespace to be
referenced in textual notations within the scope of the importing namespace without having to qualify the member
names with the name of the imported namespace. An import can also be _recursive_ , which means that, in addition to
importing members of the referenced namespace itself, all namespaces that are owned members of the imported
package are also recursively imported.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 25**


A _package_ is a kind of namespace that is used solely as a container for other elements to organize the model. In
addition, a package has the capability to _filter_ imported elements based on certain conditions (see7.5.4), usually
defined in terms of the metadata provided by annotations of those elements (see7.4and7.26). Only elements that
meet all filter conditions actually become imported members of the package. Together, recursive import and filtering
provide a general capability for specifying that a package automatically contain a set of elements identified from
across a model by their metadata.
In addition to packages, all kinds of SysML _definitions_ and _usages_ are also namespaces (see7.6and following
subclauses). All rules discussed generically for namespaces in this subclause7.5apply generically to packages,
definitions and usages (even though the examples in this subclause are given using packages).
In general, an element may have different names in different namespaces, and the same name may identify different
elements relative to different namespaces. Therefore, to unambiguously identify an element by name, the element
name must be _qualified_ by the namespace relative to which the element name is to be resolved. Such a _qualified
name_ is notated by specifying a name to identify the namespace, followed by the symbol::, followed by the
element name. Since the namespace name may also be qualified, a qualified name is most generally a sequence of
_segmentnames_ separated by::punctuation, of which all but the last must identify namespaces. An _unqualified
name_ can be considered the degenerate case of a qualified name with just one element name in its sequence, for
which the namespace to be used is implicit.
Note that qualified names do not appear in the abstract syntax. Instead, the abstract syntax representation contains
actual references to the identified elements. _Name resolution_ is the process of determining the element that is
identified by a qualified name. An unqualified name used within the body of a namespace is resolved in the context
of that namespace and, potentially, other namespaces in which the first namespace is lexically nested, taking into
account imported (see7.5.3) and inherited (see7.6) memberships. A qualified name with more than one segment is
resolved by recursively resolving the name of the qualifying namespace and then resolving the element name in that
context. The full name resolution process is specified in [KerML, 8.2.3.5].
**Table 3. Packages – Representative Notation
Element Graphical Notation Textual Notation**

```
Package (name in
body) package Package1;
```
```
Package (name in
tab) package Package1;
```
```
Package with owned
package
```
```
packagepackage Package1 {Package2;
}
```
**26 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Package with owned
members
```
```
packagepackage Package1 {Package 2;
part defpart part2 : Part2;Part2;
}
```
```
Package with alias
member (unowned)
```
```
packagepackage Package1 {Package2;
aliasfor Package2AliasPackage2;
}
```
```
Package with alias
member (unowned)
```
```
packagepackage Package1 {Package2;
aliasfor Package2AliasPackage2;
}
```
```
Package with
imported package
(nested notation)
```
```
packageimport Package1 {Package2::*;
Package3::*; private import
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 27**


```
Element Graphical Notation Textual Notation
```
```
Membership (owned
member)
```
```
packagepackage Package0 {Package1;
}
```
```
Membership
(unowned member
with alias name)
```
```
packagepackage Package0 {Package1;
aliasfor Package1AliasPackage1;
}
```
```
Import (recursive)
Note:
```
- no star is element
import
- single star is
package import
(content of package)
- double star is
recursive including
outer package

```
packageimport Package2 {
Package0::Package1::**;}
```
```
Package with
compartment
```
```
package /* members */Package1 {
}
```
```
Package with
members
compartment
```
```
packagepart Package1 { def PartDef1;
partpartdef part1 :PartDef2;
PartDef1; part part2 :
PartDef2;}
```
**7.5.2Owned Members and Aliases**
A package is declared using the keyword **package** , with the _owned members_ of the package listed in its body.
**packageattribute** Configurations { **def** ConfigEntry {
**attribute** key: String;

**28 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


} **attribute** value: String;
**itemattribute** ConfigData {entries[*]: ConfigEntry;
} }
In general, declaring an element within the body of a namespace denotes that the element is an owned
memberofthe namespace—that is, that there is an _owning membership_ relationship between the namespace and the
member element. The _visibility_ of the membership can be specified by placing one of the keywords **public** ,
**protected** or **private** before the public element declaration. If the membership is **public** (the default),then it is
visible outside of the namespace. If it is **private** _,_ then it is not visible.For namespaces other than definitions and
usages, **protected** visibility is equivalent to **private**. For definitions and usages, **protected** visibility has a
special meaning relating to member inheritance (see7.6).
**packagepublic** P { **partdef** A;
**privatepart** a : A; // public by default **attributedef** B;
}
An _alias_ for an element is a non-owning membership of the element in a namespace, which may or may not be the
same namespace that owns the element. An alias name or short name is determined only relative to itsmembership
in the namespace, and can therefore be different than the name or short name defined on the element itself. Note that
the same element may be related to a namespace by multiple alias memberships, allowing the element to have
multiple, different names relative to that namespace.
An alias isdeclared using the keyword **alias** followed by the alias short name and/or name, with a qualified
nameidentifying the element given after the keyword **for**. An alias declaration may also optionally have a body
containing annotating elements for the alias (see8.2.2.4.1). The visibility of the alias membership can be specified
as for an owned member.
**packageitem** P1 {A;
**itemalias** B;<C> CCC **for** B {
} **doc** /* Documentation of the alias. */
} **private alias** D **for** B;
A comment (see7.4), including documentation, declared within a namespace body also becomes an owned member
of the namespace. If no annotated elements are specified for the comment (with an **about** clause), then, by default,
the comment is considered to be about the containing namespace.
**packageitem** P9 {A;
**comment** /* This is a comment about item A. */Comment1 **about** A
**comment** /* This is a comment about package P9. */Comment 2
/* This is also a comment about package P9. */
**doc** P9_Doc

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 29**


} /* This is documentation about package P9. */
**7.5.3Imports**
An owned _import_ of a Namespace is denoted using the keyword **import** followed by a qualified name, optionally
suffixed by "::*" and/or "::**".
If the qualified name in an **import** does _not_ have any suffix, then this specifies a _membership import_ whose
imported membership is identified by the qualified name. Such an import results in the identified membership
becoming an _imported membership_ of the namespace owning the import. That is, the member element of this
membership becomes an _imported member_ of the importing namespace. Note that the imported membership may be
an alias membership (see7.5.2), in which case the element is imported with that alias name.
**packageimport** P2 {P1::A;
**importpackage** P1::C; // Imported with name "C".Q {
} **import** C; // "C" is re-imported from P2 into Q.
}
If the qualified name in an **import** is further suffixed by"::*", then then this specifies a _namespace import_ in
which the qualified name identifies the _imported namespace_. In this case, all visible memberships of the imported
namespace of the import become imported memberships of the importing namespace.
**package** // Memberships A, B and C are all imported from P1.P3 {
} **import** P1::*;
If the declaration of either a membership or namespace import is further suffixed by "::**", then the import
is _recursive._ Such an import is equivalent to importing memberships as described above for either an imported
membership or namespace, followed by further recursively importing from each imported member that is itself a
namespace.
**packageitem** P4 {A;
**itempackage** B;Q {
} **item** C;
} **package** P5 {
**import** // The above recursive import is equivalent to allP4::**;
// of the following taken together:// import P4;
// import P4::*;// import P4::Q::*;
} **package** P6 {
**import** // The above recursive import is equivalent to allP4::*::**;
// of the following taken together:// import P4::*;
// import P4::Q::*;

**30 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


} // (Note that P4 itself is not imported.)
The _visibility_ of an import can be specified by placing the keyword **public** or **private** before the import
declaration. If the import is **public** (the default), then all the imported memberships become public for the
importing namespace.If import is **private** , then the imported memberships become private relative to the
importing namespace. An import declaration may also optionally have a body containing annotating element owned
by the import (see8.2.2.4.1).
**packagepublic** P7 { **import** P1::A {
} /* The imported membership is visible outside P7. */
**privatedoc import** /* None of the imported memberships are visibleP4::* {
* outside of P7. */
}

**7.5.4Import Filtering**
A package may also contain _filter conditions_ that filter the imports for the package. A filter condition is a Boolean-
valued, model-level evaluable expression (see [KerML. 7.4.9]) declared using the keyword **filter** followed by a
Boolean-valued, model-level evaluable expression (see [KerML. 7.4.9]). The filter conditions of a package are
evaluated on the member elements of all memberships that are potentially to be imported into the package (see
7.5.3). Only those memberships that for which all the filter conditions evaluate to true are actually imported.
Filter conditions can, for example, be used to select which elements to import into a package based on _metadata_
applied to those elements (see also7.26on metadata).
**packagemetadata** ApprovalMetadata { **def** Approval {
**attributeattribute** approved : Boolean;approver : String;
} **attribute** level : Natural;
} ...
**packageimport** DesignModel {ApprovalMetadata::*;
**part** System {@Approval {
approved = true;approver = "John Smith";
} level = 2;
}...
}
**package** // This package imports all direct or indirect membersUpperLevelApprovals {
// of the DesignModel package that have been approved// at a level greater than 1.
**importfilter** DesignModel::**;@ApprovalMetadata::Approval **and**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 31**


ApprovalMetadata::Approval::approvedApprovalMetadata::Approval::level > 1; **and**
}
Note that a filter condition in a package will filter _all_ imports of that package. That is why full qualification is used
forApprovalMetadata::Approvalin the example above, since an imported element of theApprovalMetadata
package would be filtered out by the very filter condition in which the elements are intended to be used. This may be
avoided by combining one or more filter conditions with a _specific_ import in a _filter import_ declaration.
A filter import includes one or more filter conditions in the import declaration, listed after the imported membership
or namespacespecification, each surrounded by square brackets[...]. For such a filtered import, memberships are
imported, from that specific import, if and only if they satisfy all the given filter conditions.
**packageimport** P8 {Annotations::*;
// Only import elements of NA that are annotated as Approved. **import** NA::*[@Approved];
}
**package** // Recursively import all annotation data types and allUpperLevelApprovals {
// features of those types. **import** ApprovalMetadata::**;
// The filter condition for this import applies only to// elements imported from the DesignModel package.
} **import** DesignModel::**[@Approval **and** approved **and** level > 1];
TheSysMLpackage from the Systems Model Library (see9.2.21) contains a complete model of the SysML abstract
syntax represented in SysML itself, and it publicly imports theKerMLpackage from the Kernel Library containing
the Kernel abstract syntax model (see [KerML, 9.2.17]). When a filter condition is evaluated on an element, abstract
syntax metadata for the element can be tested as if the element had an implicit metadata usage (see7.26) defined by
the definition from theSysMLpackage corresponding to the abstract syntax metaclass of the element.
**packageimport** PackageApprovals {ApprovalMetadata::*;
**import** SysML::*;
// This imports all part definitions from the DesignModel that have// at least one owned part usage and have been marked as approved.
**import** DesignModel::**[@PartDefinition@PartDefinition::ownedPart != null **and and**
@ApprovalApproval::approved]; **and**
}
**Note.** Namespaces other than packages cannot have filter conditions (except for their special use in view definitions
and usages – see7.25). However, any kind of namespaces may have filtered imports.

**7.5.5Root Namespaces**
A _root namespace_ is a namespace that has noowner. The owned members of a root namespace are known as _top-
level elements_. Any element that is not a root namespace has an owner and, therefore, must be in the ownership tree
of a top-level element of some root namespace.

**32 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The declaration of a root namespace is implicit and no identification of it is provided in the SysML notation. Instead,
the content of a root namespace is given simply by the list of its top-level elements. For the purposes of model
interchange (see [KerML, Clause 10]), a single _project_ may contain one or more root namespace, though there is no
syntax for defining a project in the SysML syntax.
**docitem** /* This is a model notated in SysML textual notation. */ **def** I;
**attributeitem** i: I; **def** A;
**package** P;
While a root namespace has no explicit owner, it is considered to be within the scope of a single _global namespace._
This global namespace may contain several root namespaces (such as those being managed as a project), and always
contains at least all of the KerML and SysML model libraries (see [KerML, Clause 9] andClause 9). Any root
namespace within the global namespace may refer to the name of a top-level element of any other root namespace
using an unqualified name (since root namespaces are themselves never named).

**7.6Definition and Usage
7.6.1Definition and Usage Overview**
_Metamodel references:_

- _Textual notation,8.2.2.6_
- _Graphical notation,8.2.3.6_
- _Abstract syntax,8.3.6_
- _Semantics,8.4.2_
**Definitions and Usages**
The modeling capabilities of SysMLfacilitate reuse in different contexts. Definition and usage elements provide a
consistent foundation for many SysML language constructs to provide this capability, including attributes,
occurrences, items, parts, ports, connections, interfaces, allocations, actions, states, calculations, constraints,
requirements, concerns, cases, analysis cases, verification cases, use cases, views, viewpoints and renderings.
In general, a _definition_ element classifiesa certain kind of element (e.g., a classification of attributes, parts,actions,
etc.). A _usage_ element is ausageof a definition element in a certain context. A usage must always be defined by at
least one definition element that corresponds to its usage kind. For example, a part usage is defined by a part
definition, and an action usage is defined by an action definition. If no definition is specified explicitly, then the
usage is defined implicitly by the most general definition of the appropriate kind from the Systems Library (see
9.2). For example, a part usage is implicitly defined by the most general part definitionPartfrom the model library
packageParts.
**Features**
A definition may have owned usage elementsnested in it, referred to as its _features_. A usage may also have nested
usage elements as features. In this case, the context for the nested usages is the containing usage. A simple example
is illustrated by a parts tree that is defined by a hierarchyof part usages. Avehicleusage defined by
Vehiclecould contain part usages forengine,transmission,frontAxle,andrearAxle. Each part usage has
its own (implicit or explicit) part definition.
A feature relates instances of its featuring definition or usage to instances of its definition. For example, a _mass_
feature with definitionMassValue, featured by the definitionVehicle, relates each specific instance ofVehicle
to the specificMassValuefor that vehicle, known as the _value_ of the _mass_ feature of the vehicle.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 33**


A usage can also be contained directly in an owning package. In this case, the usage element is considered to be an
implicit feature of the most general kernel typeAnything. That is, a package-level usage is essentially a generic
feature that can be applied in any context, or further specialized in specific contexts (as described under
Specialization below).
A usage may have a _multiplicity_ that constrains its cardinality, that is, the allowed number of values it may have for
any instance of its featuring definition or usage. The multiplicity is specified as a range, giving the lower and upper
bound expressions that are evaluated to determine the lower and upper bounds of the specified range. The bounds
must be natural numbers. The lower bound must be finite, but the upper bound may also have the infinite value*.
An upper bound value of*indicates that the range is unbounded, that is, it includes all numbers greater than or
equal to the lower bound value. If a lower bound is not given, then the lower bound is taken to be the same as the
upper bound, unless the upper bound is*, in which case the lower bound is taken to be 0. For example, aVehicle
definition could include a usage element calledwheelswith multiplicity 4 , meaning eachVehiclehas exactly four
wheels. A less restrictive constraint, such as a multiplicity of4..8, means eachVehiclecan have 4 to 8 wheels.
Ausage may be _referential_ or _composite._ A referential usage represents a simple reference between a featuring
instance and one or more values. A composite usage, on the other hand, indicates that the related instance is integral
to the structure of the containing instance. As such, if the containing instance is destroyed, then any instances related
to it by composite usages are also destroyed. For example, aVehiclewould have a composite usage of its
wheels _,_ but only a referential usage of the _road_ on which it is driving.
**Note.** The concept of composition only applies to occurrences that exist over time and can be created and destroyed
(see7.9). Attribute usages are always referential and any nested features of attributes definitions and usages are also
always referential (see7.7).
**Specialization**
Definition and usage elements can be specialized using several different kinds of _specialization_ relationships.
A definition is specialized using the _subclassification_ relationship. The specialized definition inherits thefeatures of
the more general definition element and can add other features. For example, ifVehiclehas a feature calledfuel,
that is defined byFuel,andTruckis a specialized kind ofVehicle, thenTruckinherits the featurefuel.An
inherited featurecan be subsetted or redefined as describedbelow. TheTruckdefinition can also add its own
features such ascargoSize.
A definition can specialize more than one other definition, in which case the definition inherits the features from
each of the definitions it specializes. All inherited features must have names that are distinct from each other and
any owned features of the specializing definition. Name conflicts can be resolved by redefining one or more of the
otherwise conflicting inherited features (see below).
A usage inherits the features from its definition in the same way that a specialized definition inherits from a more
general definition element. For example, if apart usagevehicleis defined by apart definitionVehicle, and
Vehiclehas amassdefined byMassValue, thenvehicleinherits the featuremass_._ In some cases, a usage may
have more than one definition element, in which case the usage inherits the features from each of its definition
elements, with the same rules for conflicting names as described above for subclassification. A usage can also add
its own features, and subset or redefine itsinherited features. This enables each usage to be modifiedfor its context.
A usage can be specialized using the _subsetting_ relationship. A subsetting usage has a subset of the values of the
subsetted usage. The subsetting usage may further constrain its definition and multiplicity. For the example
above,Truckinherits the featurewheelswith multiplicity4..8fromVehicle. The part usagetruckfurther
inheritswheelswith multiplicity4..8fromTruck.The part usagetruckcansubsetwheelsby defining
frontLeftWheel,frontRightWheel,rearLeftwheel1, andrearRightWheel1, each with multiplicity 1..1,

**34 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


together giving the minimum total multiplicity of 4. Thetruckusage can then define additional subsets ofwheels,
such asrearLeftwheel2, andrearRightwheel2, with multiplicity 0..1, indicating they are optional.
_Redefinition_ is a kind of subsetting. While, in general, a subsetting usage is an additional feature to the subsetted
usage, a redefining usage _replaces_ the redefined usage in the context of redefining usage. For the example above,
Vehiclecontains a feature calledfuelthat is defined byFuel.TruckinheritsfuelfromVehicle. The part
usagetruckwould then normally inheritfuelas defined byFuelfromTruck. However,truckcan instead
redefinefuelto restrict its definition toDieselFuel, a subclassification ofFuel. In this case, the new redefining
feature replaces thefuelfeature that would otherwise be inherited, meaning that thefuelof thetruckpart must
be defined byDieselFuel.
A usage, particularly one with nested usages, can be reused by subsetting it. For example, subsetting the part usage
vehicleis analogous to specializingthe part definitionVehicle. Supposevehicle1is a part usage that subsets
vehicle, with the parts-tree decomposition described above. This enablesvehicle1to inherit the features and
structure ofvehicle. Thepart usagevehicle1can be further specialized by adding other part usagesto it, such as
abodyandchassis, and it can redefine parts fromvehicleas needed_._ For example,vehicle1may redefine
engineto be a4-cylinder engine.The original partvehicleremains unchanged, butvehicle1is a unique
design configuration that specializesvehicle. Other part usages, such asvehicle2, could be created in a similar
way to represent other design configurations.
**Note.** If the part definitionVehicleis modified, the modification will propagate down through the specializations
described above. However, it is expected that ifVehicleis baselined in a configuration management tool, then a
change toVehicleis a new revision, and it is up to the modelers to determine whether to retain the previous
version ofVehicleor move to the next revision.
**Variability**
_Variation_ and _variant_ are used to model variability typically associated with a family of design configurations. A
variation (sometimes referred to as a _variation point_ ) identifies an element in a model that can vary from one design
configuration to another. One example of a variationis an engine in a vehicle.For each variation, there are design
choices called variants. For this example, where the _engine_ feature is designated as a point of variation, the design
choicesarea4-cylinder enginevariant or a6-cylinder enginevariant.
Variation can apply to any kind of definition or usage in the model (except for enumeration, see7.8). The variation
element then specifies all possible variants (i.e., choices) for that variation point. For example, the specified variants
for theenginevariation are the4-cylinder engineand the6-cylinder engine.
Variants are usage elements. If the containing variation is a definition, then each of its variants is implicitly defined
by the variation definition. If the containing variation is a usage, then each of its variants implicitly subsets the
variation usage. For example, the4-cylinder engineand the6-cylinder engineare subsets of all possible
engines.
Variations can be nested within other variations, to any level of nesting. For example, the6-cylinder engine
variant may in turn contain cylinders with a variation forbore diameterthat includes variants forsmall-bore
diameterandlarge-bore diameter. Alternatively, thebore diametervariation could beappliedmore
generallyto thecylinderof _engine_ , enabling both the4-cylinder engineand the6-cylinder engineto
have this variation point.
A model with variability can be quite complex since the variation can extend to many other aspects of the model
including its structure, behavior, requirements, analysis, and verification. Also, the selection of a particular
variantoften impactsmany other design choices that include other parts, connections, actions, states, and attributes.
Constraints can be used to constrain the available choices for a given variant. For example, the choice of a
6-cylinder enginemay constrainthe choice oftransmissionto be anautomatic transmission, whereas

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 35**


the choice of a4-cylinder enginemay allow for both anautomatic transmissionoramanual
transmission.
Variations and variants are used to construct amodelthat is sometimes referred to as a superset model,
whichincludes the variants to configure all possible design configurations. A particular configuration is selected by
selecting a variant for each variation. SysML provides validation rules that can evaluate whether a particular
configuration is a valid configuration based on the choices and constraints provided in the superset model.
Variability modeling in SysML can augment other external variability modeling applications, which provide robust
capabilities for managing variability across multiple kinds of models such as CAD, CAE, and analysis models, and
auto-generating the variant design configurations based on the selections.
**Note.** The approach to variability modeling in SysML is intended to align with industry standards such as _ISO/IEC
26580:2021 Software and systems engineering — Methods and tools for the feature-based approach to software and
systems product line engineering._
**Graphical Compartments**
The graphical notation for a definition or usage may include one or more _compartments_ , which show member
elements (if any) using textual or graphical notation. In the graphical symbols in all Representative Notation tables
inClause 7, the term _compartment stack_ is a placeholder for any valid compartment for themodel element.
**Table 4. Definition and Usage – Representative Notation
Element Graphical Notation Textual Notation**

```
Name Compartment
```
- Definition (without
and with short name)

```
part def PartDef1;
part def <PD2> PartDef2;
```
```
Name Compartment
```
- Definition

```
abstract part def PartDef1 :> PartDef0;
packagealias P {PartDefAlias1
} for PartDef1;
packagealias Q {PartDefAlias2
} for PartDef1;
```
```
Name Compartment
```
- Definition
(qualified name)

```
packagepackage Package1 {Package2 {
} part def PartDef3;
}
```
**36 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
Name Compartment
```
- Definition
(abstract)

```
abstract part def PartDef1;
```
```
Name Compartment
```
- Definition
(variation)

```
variation part def PartDef1;
```
```
Name Compartment
```
- Usage (without and
with short name)

```
part part1 : PartDef1;
part PartDef2;<'p#2'> part2 :
```
```
Name Compartment
```
- Usage

```
partpart part1 {part2 {
PartDef3; part part3 :
} }
```
```
Name Compartment
```
- Usage (abstract)

```
abstract part PartDef1 ; package part1 :P {
aliasfor part1;partAlias1
} package Q {
aliasfor part1;partAlias2
}
```
```
Name Compartment
```
- Usage (variation)

```
variation part PartDef1 ; part1 :
```
```
Name Compartment
```
- Usage (variant)

```
variant part PartDef1 ; part1 :
```
```
Name Compartment
```
- Inherited Usage No textual notation.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 37**


```
Element Graphical Notation Textual Notation
```
```
Name Compartment
```
- Subsetted Usage

```
part [m] part1S : PartDef1S
subsets part1;
```
```
Name Compartment
```
- Redefined Usage
(with binding)

```
part [m] part1R : PartDef1R
part2; redefines part1 =
```
```
Subclassification
```
```
part defattribute Part2 {attribute1
: Attribute1; perform action
action1 : Action1;}
part def Part2 { Part2S :>
: Attribute2; attribute attribute2
[0..*]; item item1 : Item1
}
or
part defspecializes Part2SPart2 {
} ...
```
**38 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Usage Definition
```
```
part defattribute Part1 {attribute1
: Attribute1; perform action
action1 : Action1;}
partattribute part1 : Part1 {attribute2
: Attribute2; part part2 : Part2
[0..*];}
or
partdefined by part1 Part1 {
} ...
```
```
Subsetting
```
```
partattribute part1 : Part1 {attribute2
: Attribute2; part part2 : Part2
[0..*];}
partattribute part1S :> part1 {attribute3
: Attribute3; part part3 : Part3
[0..*];}
or
partsubsets part2Spart1 {
} ...
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 39**


```
Element Graphical Notation Textual Notation
```
```
Redefinition
```
```
part [0..*] {part1 : Part1
[0..*]; part part2 : Part2
}
part [1] :> part1 {part1S : Part1S
:>> part2; part part2R : Part2R
}
or
part [1] subsets part1S : Part1Spart1 {
redefinespart part2R : Part2Rpart2;
}
```
```
Feature Membership
(isComposite=true)
```
```
part defpart part2 : Part2PartDef1 {
[0..*];}
```
```
Feature Membership
(isComposite=true)
```
```
part [0..1] {part1 : Part1
[0..*]; part part2 : Part2
}
```
```
Feature Membership
(isComposite=false)
```
```
part [0..1] {part1 : Part1
Part2 [0..*]; ref part part2 :
}
```
**40 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Variant Membership
```
```
variation Part1 { part part1 :
: Part1a; variant part part1a
: Part1b; variant part part1b
}
```
```
Variants
Compartment
```
```
variation item itemChoice : ItemDef {
variantvariant part1;item1;
}
```
```
Variant Parts
Compartment
```
```
variation part partChoice : PartDef {
PartDef1; variant part part1 :
PartDef2; variant part part2 :
}
```
```
Relationships
Compartment No specific textual notation
```
**7.6.2Definitions**
There is a basic common notation for all kinds of definitions, as described here in subclause7.6, with additional
special notations for certain kinds of definitions described in the later subclauses specifically related to those kinds
of definitions. As a kind of Namespace (see7.5), the representation of a definition includes a _declaration_ and a
_body._
A definition is declared using a keyword specific to the kind of definition (e.g., **item** , **part** , **action** , etc.) followed
by the keyword **def**. One or more owned subclassifications may also optionally be included in the declaration of a

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 41**


definition by giving a comma-separated list of qualified names of the general definitions after the keyword
**specializes** (or the symbol:>). A definition is specified as _abstract_ by placing the keyword **abstract** before its
kind keyword.
**abstractpartdef part** Automobile **def** Vehicle; **specializes** Vehicle;
**partdef** Truck :> Vehicle;
A definition that is not abstract is called a _concrete_ definition. Declaring a definition to be abstract means that all
instances of the definition must also be instances of at least one concrete definition or usage that directly or
indirectly specializes the abstract definition.
The body of a definition is specified generically as for any namespace. In the textual notation, this is done by listing
the members and imports between curly braces{...}(see7.5), or alternatively by a semicolon;if the definition has
no members or imports. Usages declared within the body of a definition are owned usages that specify _features_ of
the Definition.
**itemprivatedef** Super { **package** N {
} **itemdef** Sub **specializes** Super;
} **item** f : N::Sub;
**7.6.3Usages**
There is a basic common notation for all kinds of usages, as described here in subclause7.6, with additional special
notations for certain kinds of usage described in the later subclauses specifically related to those kinds of usages. As
a kind of namespace (see7.5), the representation of a usage includes a _declaration_ and a _body._
A usage is declared using a keyword specific to the kind of usage (e.g., **item** , **part** , **action** , etc.). One or more
owned specializations may also optionally be included in the declaration of a usage. There are three kinds of
specializations relevant to usages:

1. _Feature typings_ specify the definitions of a usage (also known as its _types_ ). Textually, they are declared by
    giving a comma-separated list of the qualified names of the definition elements after the keyword
    **defined by** (or the symbol:). The definitions given must be consistent with the kind of usage being
    defined.
2. _Subsettings_ specify other usages subsetted by the owning usage. Textually, they are declared by giving a
    comma-separated list of the qualified names of the subsetted usages after the keyword **subsets** (or the
    symbol:>).
3. _Redefinitions_ specify other usages redefined by the owning usage. Textually, they are declared by giving a
    comma-separated list of the qualified names of the redefined usages after the keyword **redefines** (or the
    symbol:>>). (Note that redefinition is a kind of subsetting, so the owned redefinitions of a usage will be a
    subset of the owned subsettings in the abstract syntax.)
**item** x : A, B :> f :>> g;
// Equivalent declaration: **item** x **definedby** A **definedby** B **subsets** f **redefines** g;

The _multiplicity_ of a usage can be given in square brackets[...]after the name part of the declaration of a usage (if
it is named) or after one of the owned specialization clauses in the declaration (but, in all cases, only one multiplicity
may be specified). (This allows for a notation style consistent with previous modeling languages, in which the
multiplicity is always placed after the declared type.)

**42 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


A _multiplicity range_ is written in the form[ _lowerBound_ .. _upperBound_ ],where each of _lowerBound_ and
_upperBound_ is either a literal or the identification of a usage. Literals can be used to specify a multiplicity range
with fixed lower and/or upper bounds. The values of the bounds of a multiplicity range must be natural numbers. If
only a single bound is given, then the value of that bound is used as both the lower and upper bound of the range,
unless the result is the infinite value*, in which case the lower bound is taken to be 0. If two bounds are given, and
the value of the first bound is*, then the meaning of the multiplicity range is not defined.
**item defref item** Person {parent[2] : Person;
**ref itemattribute** mother : Person[1..1]numberOfChildren : Natural; **subsets** parent;
} **ref item** children[0..numberOfChildren] : Person;
**item defref item redefines** ChildlessPersonchildren[0]; **specializes** Person {
}
A multiplicity may be optionally followed by one or both of the following keywords (in either order), or they can be
used without giving an explicit muiltiplicity, at any place in the declaration a multiplicity would be allowed.

- **nonunique** – If a usage is _non-unique,_ then the same value may appear more than once as a value of the
    usage. The default is that the usage is _unique,_ meaning that no two values of the usage may be the same.
- **ordered** – If a usage is _ordered,_ then the values of the usage can be placed in order, indexed from 1 to the
    number of values. The default is that the feature is _unordered._
If a multiplicity is not declared for a usage, then the usage inherits the multiplicity constraints of any other usages it
subsets or redefines. If no tighter constraint is inherited, the effective default is the most general multiplicity
[0..*]. However, a tighter default of[1..1]is implicitly declared for the usage if all of the following conditions
hold:
1. The usage is an attribute usage, an item usage (including a part usage, except if it is a connection usage),
or a port usage.
2. The usage is owned by a definition or another usage (not a package).
3. The usage does not have any _explicit_ owned subsettings or owned redefinitions.
There are a number of additional properties of a usage that can be flagged by adding specific keywords to its
declaration. If present these are always specified in the following order, before the kind keyword in the usage
declaration.
1. **in** , **out** or **inout** – Specifies that the Usage is a _directed feature_ with the indicated direction_._
2. **abstract** – Specifies that the usage is _abstract_.
3. **readonly** – Specifies that the usage is _read only_. Once such a usage is given a value, it cannot later be
changed.
4. **derived** – Specifies that the usage is _derived_.
5. **end** – Specifies that the usage is an _end feature_. See9.2.6for further discussion on end features of
connection definitions and usages.
6. **ref** – Specifies that the usage is _referential (non-composite)_.
1. **in** , **out** , **inout** – Specifies a _directed usage_ with the indicated _direction_ , which determineswhat things
are allowed to change its values relative to its featuring instance.
◦ **in** – Things "outside" the featuring instance. These usages identify things inputto an instance.
◦ **out** – The featuring instance itself or things "inside" it. These usages identify things output by
an instance.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 43**


```
◦ inout – Both things "outside" and "inside" the featuring instance. These usages identify things
that are both input to and output by an instance.
```
2. **abstract** – Specifies that the usage is _abstract_. A usage that is not abstract is called a _concrete_ usage.
    Similarly to an abstract definition (see7.6.2), declaring a usage to be abstract means that any value of the
    usage must also be a value of some concrete usage that directly or indirectly specializes (subsets or
    redefines) the abstract usage.
3. **readonly** – Specifies that the usage is _read only._ Values of read only usage are the same during the entire
    existence of that featuring instance.
4. **derived** – Specifies that the usage is _derived._ Such a feature is typically expected to have a bound value
    expression that completely determines its value at all times (see also7.13.3on binding a usage to a value).
5. **end** – Specifies that the usage is an _end feature_ of its owning definition or usage.See9.2.6for further
    discussion on end features of connection definitions and usages.
6. **ref** – Specifies that the usage is _referential_. A usage that is not referential is _composite._ Values of a
    composite usage, for each featuring instance, cannot exist after the featuring instance ceases to exist. This
    only applies to values at the time the instance goes out of existence, not to other things that may have been
    values of the usage before that, but are not any longer. (Note also that a directed usage is always
    referential, whether or not the keyword **ref** is also given explicitly in its declaration.)
**abstract part defabstract refitem** Container {content;
} **part def** Tank :> Container {
**in itemref item** fuelFlow : Fuel;fuel : Fuel :>> content;
}
The body of a usage is specified generically as for any namespace. In the textual notation, this is done by listing the
members and imports between curly braces{...}(see7.5), or alternatively by a semicolon;if it has no members or
imports. Usages declared within the body of another Usage are owned ( _nested_ ) usages that specify _features_ of the
owning usage.
**partpart** vehicle : Vehicle {wheelAssembly[2] {
**partpart** axle : Axle;wheel : Wheel;
} }
**7.6.4Reference Usages**
A _reference usage_ is a usage that is declared without any kind keyword. Unlike other kinds of usages, the definitions
(types) of a reference usage are not restricted to be of a particular kind. The declaration of a reference usage may,
but is not required, to include the **ref** keyword. However, a reference usage is always, by definition, referential. A
reference usage is otherwise declared like any other usage, as given above.
**abstractabstract refpartdef** content : Base::Anything;Container {
} **part def** OrderedContainer {
// By default, the following is a reference usage.orderedContent **ordered** :>> content;
}

**44 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**7.6.5Effective Names**
If a name and/or short name are declared for an element, these are used in the name resolution process to identify the
element (as discussed in7.6.1). However, if neither a name or a short name are given in the declaration of a usage
with an owned redefinition, then its _effective_ name and short name are implicitly determined by the name and short
name of the redefining usage of its first owned redefinition (which may itself be an implicit name, if the redefined
usage is itself a redefining usage). This is useful when redefining a usage in order to constrain it, while maintaining
the same naming as for the original usage.
**partpartdef** Engine {cylinders : Cylinder[2..*];
} **part def** FourCylinderEngine :> Engine {
// This redefines Engine::cylinders with a// new usage, restricting the multiplicity
// to 4. It's declared name is empty,// but its effective name is "cylinders".
} **partredefines** cylinders[4];
**partpart redefinesdef** SixCylinderEngine :> Engine {cylinders[6];
}
Certain other kinds of usages (such as perform action usages) specify an alternate effective name rule, as described
in the subclauses relevant to those usages (e.g.,7.16.6describes the rule for perform action usages).

**7.6.6Feature Chains**
A _feature chain_ is a textual notation specified as a sequence of two or more qualified names separated by dot (.)
symbols. Each qualified name in a feature chain must resolve to a Usage (or, more generally, a KerML Feature). The
first qualified name in a feature chain is resolved in the local namespace as usual (see7.6.1). Subsequent qualified
names are then be resolved using the previously resolved usage (feature) as the context namespace, but considering
only public memberships.
A feature chain is similar to a qualified name but, unlike a qualified name, the path of usages (features) in the chain
is recorded in the abstract syntax, not just the reference to the final usages. This means that different paths to the
same usage can be distinguished in the abstract syntax representation of a model. Feature chains can be used to
specify the target for most kinds of relationships involving usages, including subsetting and redefinition. However,
their use is particularly important when specifying the related features of a connection usage that are more deeply
nested than the connection usage itself (see7.13). (See also [KerML, 7.3.4.6].)
**itemitem** unclescousins **subsetsredefines** parents.siblings;parents.siblings.children;
**connect** vehicle.wheelAssembly.wheels **to** vehicle.road;
In general, when a textual notation is described as including the _identification_ of a usage, this can be done by using
either a qualified name or a feature chain.

**7.6.7Variations and Variants**
A definition or usage is specified as a _variation_ by placing the keyword **variation** before its kind keyword. A
variation is always abstract, so the **abstract** keyword is not used on a variation.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 45**


All usages declared within the body of a variation definition or usage are declared as _variant_ usages by placing the
keyword **variant** at the beginning of their declarations. Variant usages may only be declared within a variation.
The kind of a variant usage must be consistent with the kind of its owning variation.
**variation part defvariantpart** manual : ManualTransmission;TransmissionChoices :> Transmission {
} **variant part** automatic : AutomaticTransmission;
A non-variant usage can also be declared to act as a variant of a variation by not including a kind keyword in the
variant declaration and, instead, following the **variant** keyword with the identification of a separately declared
usage. Such a variant declaration may also optionally further constrain the variant usage by including a multiplicity
and/or further specializations.
// These are non-variant usages. **part** smallEngine : FourCylinderEngine;
**part** bigEngine : SixCylinderEngine;
**part defvariation part** Vehicle {engine : Engine {
// These are variant usages within the variation part "engine",// based on the referenced non-variant usages.
**variantvariant** smallEngine;bigEngine;
} }
**7.6.8Implicit Specialization**
The meaning or _semantics_ of a definition is given by what things it classifies relative to the system being modeled.
Specific kinds of definitions are already restricted to classifying specific kinds of things. E.g., an attribute definition
classifies attributive values, a part definition classifies systems and parts of systems, etc.
The Systems Model Library (see9.2), which is based on the KerML Kernel Semantic Library (see [KerML, 9.2]) is
a set of _ontological_ SysML models that define the basic kinds of things relevant for systems modeling. The
semantics of definition elements in SysML is given by requiring that each such element (directly or indirectly)
specialize the corresponding _basedefinition_ from the Systems Model Library (or base classifier from the Kernel
Semantic Library) corresponding to its kind.
At the highest level, every definition element must directly or indirectly specialize the most general classifier
Anythingfrom theBasemodel in the Kernel Semantic Library (see [KerML, 9.2.2]). Specific kinds of definition
then have more specific requirements for what more specific base definition they must specialize. For example, an
attribute definition must specialize the base attribute definitionAttributeValuefrom theAttributesmodel in
the Systems Model Library, while a part definition must specialize the base part definitionPartfrom theParts
model.
The Systems Model Library also includes a parallel hierarchy of _base usages_ (or base features in the Kernel
Semantic Library). So, every usage element must directly or indirectly specialize (subset) the most general feature
_things_ from the from theBasemodel in the Kernel Semantic Library. And specific kinds of usage then also have
more specific requirements for what more specific base usage they must specialize. For example, an attribute usage
must subset the base attribute usageattributeValuesfrom theAttributesmodel in the Systems Model
Library, while a part usage must subset the base part usagepartsfrom thePartsmodel. In general, each base
usage is defined by the corresponding base definition. E.g., the base usagepartsis defined by the base definition
Part, so that every part usage is ultimately a direct or indirect usage ofPart.

**46 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


These and other _semantic constraints_ are fully described in8.4. However, it is not generally necessary for a modeler
to explicitly satisfy these constraints when constructing a model. Rather, the violation of a semantic constraint
_implies_ the need for a specific relationship, which may then be added to the model automatically by tooling (see also
[KerML, 8.4.2]). In particular, if a definition or usage, as explicitly declared, does not directly or indirectly
specialize the required base definition or usage, then the declaration is considered to include an _implicit_
subclassification or subsetting of the appropriate base definition or usage.
**attributepartdef** P { **def** A; // Implicitly subclassifies Attributes::AttributeValue.// Implicitly subclassifies Parts::Part.
**refattribute** x; a : A; // Implicitly subsets Attributes::attributeValues.// Implicitly subsets Base::things.
**partpart** p;q :> p; // Implicitly subsets Parts::parts.// No implicit specialization.
} **part def** Q :> P; // No implicit specialization.

**7.7Attributes
7.7.1Attributes Overview**
_Metamodel references:_

- _Textual notation,8.2.2.7_
- _Graphical notation,8.2.3.7_
- _Abstract syntax,8.3.7_
- _Semantics,8.4.3_
An _attribute definition_ defines a set of data values, such as numbers, quantitative values with units,
qualitativevalues such as text strings, or data structures of such values. An _attribute usage_ is a usage ofan attribute
definition. An attribute usage is always referential and any nested features of an attribute definition or usage must
also be referential (see also7.6on referential and composite usages).
The data values of anattribute usageare constrained to be in the range specified by its definition. The range of data
values for an attribute definition can be further restricted using constraints (see7.19). An enumeration definition is a
specialized kind of attribute definition that further restricts the values of the data type to a discrete set of data values
(see7.8).
Attribute usages can be defined by KerML data types as well as SysML attribute definitions. This allows them to be
typed by primitive data types from the Kernel Data Type Library (see [KerML, 9.3]), such asString,Boolean,
and numeric types includingInteger,Rational,RealandComplex. The Kernel Data Type Library also includes
basic structured data types for collections.
Attribute usages representing quantities with units are defined using the SysML Quantities and Units Domain
Library or extensions of the elements in thislibrary (see9.8). The library provides base attribute definitions for
scalar, vector and tensor quantity values, along with other models that specifythe full set of international standard
quantity kinds and units. Fundamental to this approach is the principle that only the kind of unit (e.g.,MassUnit,
LengthUnit,TimeUnit, etc.) is associatedwith an attribute definition, while a specific unit (e.g.,kg,m,s, etc.) is
only given with an actual quantity value. This means that an attribute usage for a quantity value is independent of
the specific units used, allowing for automatic conversion and interoperability between different units ofthe same
kind (e.g., kilograms and pounds mass, meters and feet, etc.).
The values of an attribute usage are data values, whether primitive values like integers or structured values with
nested attributes, that do not themselves change over time. However, the owner of an attribute usage may be an
occurrence definition or usage (or a specialized kind of occurrence, such as an item, part or action). In this case, the
value of the attribute usage may vary over the lifetime of its owning occurrence, in the sense that it can have

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 47**


different values at different points in time, reflecting the changing condition of the occurrence over time. (See also
the discussion in7.9.)
**Table 5. Attributes – Representative Notation
Element Graphical Notation Textual Notation**

```
Attribute Definition
```
```
attribute def AttributeDef1;
attribute def AttributeDef1 {
}/* members */
```
```
Attribute
```
```
attribute AttributeDef1;attribute1 :
attribute AttributeDef1 {attribute1 :
}/* members */
```
```
Attributes
Compartment
```
```
{ attribute attribute1
: Attribute1Def
[1..*] ordered unique ;
} /* ... */
```
**7.7.2Attribute Definitions and Usages**
An attribute definition is declared as described in7.6.2, using the kind keyword **attribute**. An attribute definition
may only specialize other attribute definitions (including enumeration definitions) or KerML data types (see
[KerML, 7.4.2]). An attribute usage may be declared as described in7.6.3, using the kind keyword **attribute**. An
attribute usage may only be defined by attribute definitions or KerML data types. (See also7.8on enumeration
definitions and enumeration usages.

**48 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


An attribute usage is always referential, whether or not the **ref** keyword (see7.6.3) is used explicitly in its
declaration. The default multiplicity of an attribute usage is[1..1], under the conditions described in7.6.3. In
general, any kind of usage may be declared in the body of an attribute definition or attribute usage, but all such
usages shall be referential. (There are further restrictions on what can be nested in an enumeration definition – see
7.8.)
**attribute defref part** sensor : Sensor;SensorRecord {
} **attribute** reading : Real;
The base attribute definition isAttributeValuefrom theAttributeslibrary model (see9.2.2), which is simply
an alias for the data typeDataValuefrom the KerMLBaselibrary model (see [KerML, 9.2.2]). The base attribute
usage isattributeValuesfrom theAttributeslibrary model, which is simply an alias for the feature
dataValuesfrom the KerMLBaselibrary model.

**7.8Enumerations
7.8.1Enumerations Overview**
_Metamodel references:_

- _Textual notation,8.2.2.8_
- _Graphical notation,8.2.3.8_
- _Abstract syntax,8.3.8_
- _Semantics,8.4.4_
An enumeration definition is a kind of attribute definition (see7.7) whose instances are limited to specific set of
_enumerated values._ An _enumeration usage_ is an attribute usage that is required to have a single definition that is an
enumeration definition.
An enumeration usage is restricted to only the set of enumerated values specified in its definition. Since an
enumeration definition is a kind of attribute definition, it can also be used to define a regular attribute usage. Even if
the attribute usage is not syntactically an enumeration usage, it is still semantically restricted to take on only the
values allowed by its enumeration definition.
An enumeration definition can specialize an attribute definition that is not itself an enumeration definition. In this
case, the enumerated values of the enumeration definition will be a subset of the attribute values of the specialized
attribute definition. Which enumerated values correspond to which attribute values may be specified by binding the
enumerated values to expressions that evaluate to the desired values of the specialized attributed definition (see also
7.13on binding usages to values). In this case, the results of all the expressions must be distinct (typically they will
just be literals).
For example, an enumeration definitionDiameterChoicesmay specialize the attribute definitionLengthValue.
DiameterChoicesmay include literals that are equal to 60 mm, 80 mm, and 100 mm. An attribute usage called
cylinderDiametercan be defined byDiameterChoices, and its value can equal one of the three enumerated
values.
An enumeration definition may not contain anything other than the declaration of its enumerated values. However, if
the enumeration definition specializes an attribute definition with nested usages, then those nested usages will be
inherited by the enumeration definition, and they may be bound to specific values within each enumerated value of
the enumeration definition.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 49**


An enumeration definition may not specialize another enumeration definition. This is because the semantics of
specialization require that the set of instances classified by a definition be a subset of the instances of classified by
any definition it specializes. The enumerated values defined in an enumeration definition, however, would _add_ to the
set of enumerated values allowed by any enumeration definition it specialized, which is inconsistent with the
semantics of specialization.
**Table 6. Enumerations – Representative Notation
Element Graphical Notation Textual Notation**

```
Enumeration
Definition
```
```
enum def EnumerationDef1;
enum def EnumerationDef1 {
}/* members */
```
```
Enums Compartment
```
```
enum def EnumerationDef1 {
enumenum enum1;enum2;
}
or
enum def enum1;EnumerationDef1 {
} enum2;
```
```
Enums Compartment
```
```
enum def EnumerationDef1 {
[unit1]; enum = value1
[unit2]; enum = value2
}
or
enum def = value1 [unit1];EnumerationDef1 {
} = value2 [unit2];
```
**7.8.2Enumeration Definitions and Usages**
An enumeration definition is declared as described in7.6.2, using the kind keyword **enum** , with the additional
restrictions described below. As a kind of attribute definition, an enumeration definition may generally subclassify

**50 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


other attribute definitions or KerML data types. However, an enumeration definition must not subclassify another
enumeration definition. An enumeration usage is declared as described in7.6.3, using the kind keyword **enum**.
Any owned members declared in the body of an enumeration definition must be enumeration usages, which are the
_enumerated values_ of the enumeration definition. An enumeration definition is always considered to be a variation
and its enumerated values are its variants. The keywords **abstract** and **variation** may not be used with an
enumeration definition. The declaration of an enumeration usage as an enumerated value of an enumeration
definition may not include the keyword **variant** nor any of the other property keywords given in7.6.3(i.e, any
direction keywords, **abstract** , **derived** , etc.).
Since the body of an enumeration definition may only declare enumeration usages, the declaration of an enumerated
value may omit the **enum** keyword. An enumerated usage declared as an enumerated value is considered to be
implicitly defined by its owning enumeration definition and, therefore, may not have any explicitly declared
definition other than that enumeration definition (and need not have any explicitly declared definition at all).
**enum defattribute def** ConditionColor { red; green; yellow; }ConditionLevel {
} **attribute** color : ConditionColor;
**enum defenum** RiskLevel :> ConditionLevel {low { color = ConditionColor::green; }
**enumenum** medium { color = ConditionColor::yellow; }high { color = ConditionColor::red; }
}
There are no special restrictions on the declaration of an enumeration usage outside the body of an enumeration
definition, other than as for an attribute usage in general (see9.2.2), except that such an enumeration usage must be
explicitly defined by a single enumeration definition. As a kind of attribute usage, an enumeration usage is always
referential, whether or not **ref** is included in its declaration, and all the nested usages of an enumeration usage must
also be referential.
**enum** // The following feature is added for this usage.assessedRisk : RiskLevel {
// It is legal, since all attribute usages are// referential.
} **attribute** assessment : String;

**7.9Occurrences
7.9.1Occurrences Overview**
_Metamodel references:_

- _Textual notation,8.2.2.9_
- _Graphical notation,8.2.3.9_
- _Abstract syntax,8.3.9_
- _Semantics,8.4.5_
**Occurrences**
An _occurrence definition_ is a definition of a class of occurrences that have an extent in time and may have spatial
extent. An _occurrence usage_ is a usage of an occurrence definition.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 51**


The extent of an occurrence in time is known as its _lifetime,_ which covers the period in time from the occurrence's
creation to its destruction. An occurrence maintains its identity over its lifetime, while the values of its features may
change over time. The lifetime of an occurrence begins when the identity of the occurrence is established, and the
the lifetime ends when the occurrence loses its identity. For example, the lifetime of a car could begin when it leaves
the production-line, or when a vehicle identification number is assigned to the car. Similarly, the lifetime of a car
could end when the car is disassembled or demolished.
The performance of a behavior is also an occurrence that takes place over time. The lifetime of a behavior
performance begins at the start of the performance and ends when the performance is completed. Structural and
behavioral occurrences are often related. For example, a machine on an automobile assembly line, during its
lifetime, will repeatedly perform a behavioral task, each performance of which has its own respective lifetime,
which then affects the construction of some car being assembled on the line.
If an occurrence definition or usage has nested composite features, then those features must also be usages of
occurrence definitions (including the various specialized kinds of occurrences, such as parts, items and actions). If
an occurrence has values for any composite features at the end of its lifetime, then the lifetime of those composite
values must also end. However, if a composite suboccurrence is removed from its containing occurrence before the
end of the lifetime of the containing occurrence, then the former suboccurrence can continue to exist. For example,
if a wheel is attached to a car when the car is destroyed, then the wheel is also destroyed. However, if the wheel is
removed before the car is destroyed, then the wheel can continue to exist even after the car is destroyed. (See also
7.6on referential and composite usages.)
**Time Slices and Snapshots**
The lifetime of an occurrence can be partitioned into _time slices_ which correspond to some duration of time.These
time slices represent periods or phases of a lifetime, such as the deployment or operational phase. Time slices can be
further partitioned into othertime slices. For example, the lifetime of a car might be divided into time slices
corresponding to its assembly, being in inventory before being sold, and then sequential periods of ownership with
different owners.
A time slice with zero duration is a _snapshot_. Start, end and intermediate snapshots can be defined for any time slice
to represent particular instants of time in an occurrence's lifetime. For example, the start snapshot of each ownership
time slice of a car corresponds to the sale of the car to a new owner, which happens at the same time as the end
snapshot of the previous ownership (or inventory) time slice.
**Individuals**
Any kind of occurrence definition can be restricted to define a class that represents an _individual_ , that is, a single
realor perceived object with a unique identity. For example, consider the part definitionCarmodeling the class of
all cars (parts are kinds of items which are kinds of occurrences, see7.11). An individual car calledCar1with a
unique vehicle identification number can then be modeled as an individual part definition that is a subclassification
of the general part definitionCar. As such,Car1inherits all the features ofCar(such as its partsengine,
transmission,chassis,wheels, etc.), but has individual values for each of those features (individualengine,
individualtransmission, individualchassis, four individualwheels, etc.), each of which is itself a uniquely
identifiable subclassification of a more general part definition (Engine,Transmission,Chassis,Wheel, etc.).
An occurrence usage can also be restricted to be the usage of a single individual. In this case, exactly one of the
definitions of the occurrence usage must be an occurrence definition for that individual. Such an individual usage
can be used to model a role that an individual plays for some period of time. For example, the individual part
definitionCar1can be used in different contexts, such as the usage ofCar1when it is in for service and the usage
ofCar1when it is used for normal operations. Letcar1InServicebe the usage ofCar1when it is in for service
to have its tires rotated. For this usage,car1InServicehas fourwheelsthat play different roles, including front-
left, front-right, rear-left, and rear-right. The four wheels ofCar1are individualWheelusages defined by the
individual definitionsWheel1,Wheel2,Wheel3, andWheel4. Eachof these individual definitions is a

**52 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


subclassification ofWheel. Whencar1InServiceenters the shop, thefront-left wheelindividual usage is
initially defined by the individual definitionWheel1, but after the tires are rotated, thefront-left wheelis
defined by the individual definitionWheel2.
The lifetime of an individual and any of its time slices can be actual or projected. For example, theindividual car
Car1may be purchased as a used car.Car1has had an actual lifetime up to that time. A mechanic may
performdiagnostics andobtain some measurements,and may estimate the remaining life of the car or its parts based
on themeasurements. For example, the mechanic may estimate the remaining lifetime of the tires, based on the tread
measurements and the estimated tire wear rate.
At a given point in time, the condition of an individual (sometimes called its "state", which should not be confused
with a behavioral state usage, as described in7.17) can be specified by the values of its attributes. As an example,
the condition ofcar1inOperationat different points in time can be specified in terms of itsacceleration,
velocity, andposition. In addition, its finite (i.e., discrete) state (in the sense that can be modeled with state
definitions and usages, see7.17) can be specified at different points in time asofforon, and any nested state such
asforwardorreverse. The condition of the car can continue to change over its lifetime, and can be specified as a
function of discrete and/or continuous time.
**Events**
An _event_ is a reference from one occurrence to another occurrence that represents some relevant happening during
the lifetime of the first occurrence. Such an event model makes no commitment as to how the event actually
happens. Different specializations of the containing occurrence may realize the modeled event in different ways.
In particular, occurrences may collaborate by transferring information between each other via _messages_ (see7.13).
The sending of such a message is an event in the lifetime of the sending occurrence, while the receipt of such a
message is an event in the lifetime of the receiving occurrence. These events can possibly be realized as the
performance of a send action and corresponding accept action, respectively, with the message being the resulting
transfer between them (see7.16). However, it could also be realized as the start and end of an explicitly modeled
flow connection (see7.13on flow connections and messages).
**Table 7. Occurrences – Representative Notation
Element Graphical Notation Textual Notation**

```
Occurrence
Definition
```
```
occurrence def OccurrenceDef1;
occurrence def OccurrenceDef1 {
}/* members */
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 53**


```
Element Graphical Notation Textual Notation
```
```
Occurrence
```
```
occurrence : OccurrenceDef1;occurrence1
occurrence : OccurrenceDef1 {occurrence1
}/* members */
```
```
Individual
Occurrence
Definition
```
```
individual def 'OccurrenceDef1-1'
:> OcurrenceDef1;
```
```
Individual
Occurrence
```
```
individual : occurrence1
:> occurrence1;'OccurrenceDef1-1'
```
```
Timeslice timeslice OccurrenceDef1;timeslice1 :
```
```
Snapshot snapshot OccurrenceDef1;snapshot1 :
```
```
Portion Membership
```
```
individual individual1 : part
Individual1 { timeslice timeslice1
{ snapshot
snapshot1; snapshot
snapshot2;}
} timeslice timeslice2;
```
**54 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Occurrences
Compartment
```
```
{ occurrence occur1 :
OccurDef [1..*] ordered nonunique ;
/* ... */
}
```
```
Individuals
Compartment (parts)
```
```
{ individual part
part1 :PartDef1_1 [1..*]
/* ... */ ordered nonunique ;
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 55**


```
Element Graphical Notation Textual Notation
```
```
Timeslices
Compartment
```
```
{ timeslice state
state1; timeslice
part1_timeslice1 :PartDef1 [1..*]
/* ... */ ordered nonunique ;
}
```
```
Snapshots
Compartment
```
```
{ snapshot state state1;
part1_snapshot1 : snapshot
ordered nonunique PartDef1 [1..*];
/* ... */
}
```
**7.9.2Occurrence Definitions and Usages**
An occurrence definition or usage (that is not of a more specialized kind) can be declared as described in7.6.2and
7.6.3, using the kind keyword **occurrence**. An occurrence usage may only be defined by occurrence definitions (of
any kind) or KerML classes (see [KerML, 7.4.3]).
**occurrence defref part** aircraft : Aircraft;Flight {
}

**56 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The base definition for occurence definitions is the classOccurrencefrom theOccurrencesmodel in the Kernel
Semantic Library (see [KerML, 9.2.4]). The base usage for occurrence usages is the featureoccurrencesfrom the
Occurrencesmodel_._

**7.9.3Time Slices and Snapshots**
An occurrence usage (of any kind) can be declared as a _time slice_ or a _snapshot_ using the keyword **timeslice** or
**snapshot** , respectively, placed immediately before the kind keyword of the declaration (after any of the other
usage property keywords described in7.6.3). Alternatively, **timeslice** or **snapshot** may be used in place of the
kind keyword, in which case the declaration is equivalent to **timeslice occurrence** or **snapshot occurrence**
(that is, an occurrence usage not of a more specialized kind, but declared as a time slice or snapshot, respectively).
**occurrence defref part** aircraft : Aircraft;Flight {
}// The following are time slices of Flight.
**timeslicetimeslice** preflight : Flight;inflight : Flight;
**timeslice** postflight : Flight;
**part** // The following are snapshots of the part aircraft.aircraft : Aircraft;
**snapshotsnapshot partpart** aircraftTakeOff :> aircraft;aircraftLanding :> aircraft;

A time slice or snapshot is normally considered to represent a portion of the lifetime of instances of its defining
occurrence definition(s). However, if such an occurrence usage has no explicitly declared definition, but is declared
in the body of an occurrence definition, then it is considered to implicitly represent a portion of instances of the
containing occurrence definition. If it is declared in the body of another occurrence usage, then it is considered to
implicitly represent a portion of the instances of the definition(s) of that containing occurrence usage.
**occurrence defref part** aircraft : Aircraft;Flight {
// The following are time slices of Flight. **timeslice** preflight;
**timeslicetimeslice** inflight;postflight;
}
**part** // The following are snapshots of the part aircraft.aircraft : Aircraft {
**snapshotsnapshotpartpart** aircraftTakeOff;aircraftLanding;
}
**7.9.4Individual Definitions and Usages**
An occurrence definition (of any kind) can be declared as an _individual definition_ using the keyword **individual** ,
placed immediately before the kind keyword of the declaration. Alternatively, **individual** may be used in place of
the kind keyword, in which case the declaration is equivalent to **individual occurrence** (that is, an occurrence
usage not of a more specialized kind, but representing an individual).
**individual defindividual part def** Flight_248 :> Flight;TestPlane_1 :> Aircraft;

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 57**


An occurrence usage (of any kind) is considered to be an _individual usage_ if it has a definition that is an individual
definition. An occurrence usage must not have more than one definition that is an individual definition. An
occurrence usage may also be explicitly declared to be an individual usage using the keyword **individual** , placed
after any of the other usage property keywords described in7.6.3, but before a **timeslice** or **snapshot** keyword
(if any). In this case, the occurrence usage must have exactly one definition that is an individual definition. If the
declaration of an occurrence usage includes the the keyword **individual** (and, possibly, **timeslice** or
**snapshot** ), but no kind keyword, then this is equivalent to having included the **occurrence** keyword (that is, an
occurrence isage not of a more specialized kind, but representing an individual, and, possibly, a time slice or
snapshot).
**individualindividual part** flightRecord : Flight_248 { **redefines** aircraft : TestPlane_1;
**individual timesliceindividual timesliceredefinesredefines** preflight;inflight;

} **individual timesliceredefines** postflight;
**7.9.5Event Occurrence Usages**
An _event occurrence usage_ is declared like an occurrence usage, as described in7.9.2,7.9.3, and7.9.4, but using the
kind keyword **event occurrence** instead of just **occurrence**. It is related to another occurrence usage,
representing the occurring event, by a _reference subsetting_ relationship, which is a special kind of subsetting
relationship specified using the keyword **references** or the symbol::>. Or, if the event occurrence usage has no
such reference subsetting, then the referenced event occurrence is the event occurrence usage itself.
**partevent occurrence** client { request[1] **references** subscriptionMessage.source;
} **event occurrence** delivery[*] ::> publicationMessage.target;
An event occurrence usage may also be declared using just the keyword **event** instead of **event occurrence**. In
this case, the declaration does not include either a name or a short name. Instead, the referenced event occurrence of
the event occurrence usage is identified by giving a qualified name or feature chain immediately after the **event**
keyword.
**partevent** client {subscriptionMessage.source[1];
} **event** publicationMessage.target[*];
The **ref** keyword may be used in the declaration of an event occurrence usage, but an event occurrence usage is
always referential, whether or not **ref** is included in its declaration.

**7.10Items
7.10.1Items Overview**
_Metamodel references:_

- _Textual notation,8.2.2.10_
- _Graphical notation,8.2.3.10_
- _Abstract syntax,8.3.10_
- _Semantics,8.4.6_

**58 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


An _item definition_ is a kind of occurrence definition (see7.9) that defines a class of identifiable objects that may be
acted on over time, but which do not necessarily perform actions themselves. An _item usage_ is a usage of one or
more item definitions.
Item usages can be used to represent inputs and outputsto actions such as water, fuel, electrical signals and data.
Item usages, such as fuel, may flow through a system and be stored by asystem. An item may have attributes (see
7.7), states (see7.17), and nested item usages.
An item that performs actions is normally modeled as a part (see7.11). All parts are items, but not all items are
necessarily parts. An item may also be considered to be a part during some time slices of its lifetime but not others.
For instance, an engine being assembled can be modeled as an item moving along an assembly line. However, once
the engine assembly is completed, the engine can be considered to be a part that may be installed into a car, where it
is expected to perform the action providing power to propel the car. But later it may be removed from the car and
again be considered only an inactive item in a junkyard.
Items may also have an extent in space as well as time. The _shape_ of an item is its boundary in three-dimensional
space. Items without shapes are _closed_ enabling them to be boundaries of other items (for example, a two-
dimensional sphere has no boundary, but it is the shape of a three-dimensional ball). The Geometry Domain Library
(see9.7) includes a model of basic kinds of geometric shapes that can be composed to construct compound spatial
items.
An item can also identify other items as _enveloping_ shapes, which are closed items that are the boundary of a
hypothetical item occupyingthe same or larger space as the enveloped item. Some of these can be _bounding_ shapes,
which overlap the bounded item on all sides. The spatial boundaries of items can break into separate closed items,
such as the inside and outside of an egg shell. These inner boundaries can be the boundary of a hypothetical item,
the interior of which is a _void_ of the item. Items with no voids are _solid_.
**Table 8. Items – Representative Notation
Element Graphical Notation Textual Notation**

```
Item Definition
```
```
item def ItemDef1;
item def /* members */ItemDef1 {
}
```
```
Item
```
```
item item1 : ItemDef1;
item /* members */item1 : ItemDef1 {
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 59**


```
Element Graphical Notation Textual Notation
```
```
Items Compartment
```
```
{ item item1 :
ItemDef1 [1..*] ordered nonunique ;
/* ... */
}
```
**7.10.2Item Definitions and Usages**
An item definition or usage (that is not of a more specialized kind) is declared as a kind of occurrence definition or
usage (see7.9.2), using the kind keyword **item**. An item usage must only be defined by item definitions (of any
kind) or KerML structures (see [KerML, 7.4.4]). The default multiplicity of an item usage is[1..1], under the
conditions described in7.6.3.
**item defattribute** Fuel {pressure : PressureValue;
} **ref item** impurities[0..*] : Material;
The base item definition and usage areItemanditemsfrom theItemslibrary model (see9.2.3). (For other
semantic constraints on item usages, see8.4.6).

**7.11Parts
7.11.1Parts Overview**
_Metamodel references:_

- _Textual notation,8.2.2.11_
- _Graphical notation,8.2.3.11_
- _Abstract syntax,8.3.11_
- _Semantics,8.4.7_
A _part definition_ represents a modular unit of structure such as a system, system component, or external entity that
may directly or indirectly interact with the system. Apart definition is a kind of item definition (see7.10) and, as
such, defines a class of part objects that are occurrences with temporal (and possibly spatial) extent.A part usage is
a kind of item usage that is a usage of one or more part definitions, but may also be a usage of item definitions that
are not part definitions. This allows a partto be treatedlike anitem in some cases (e.g., when an engine under
assembly flows through an assembly line) and as a part in other cases (e.g., when an assembled engine is installed in
a vehicle).

**60 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


A system is modeled as a composite part, and its part usagesmay themselveshave further composite structure. The
parts of a system may have attributes (see7.7) that represent different performance, physical and other quality
characteristics. The parts may have ports (see7.12) that define the points at which those parts may be interconnected
(see7.13and7.14). Parts may also _perform_ actions (see7.16) resulting in items flowing across the connections
between them, and _exhibit_ states (see7.17) that enable different actions.
A partcan represent any level of abstraction, such as a purely logical component withoutimplementation
constraints, or a physical component with a part number, or some intermediate abstraction. Parts can also be used to
represent different kinds of system components such as hardware components, software components, facilities,
organizations, or users of a system.
**Table 9. Parts – Representative Notation
Element Graphical Notation Textual Notation**

```
Part Definition
```
```
part def PartDef1;
part def /* members */PartDef1 {
}
```
```
Part
```
```
part part1 : PartDef1;
part /* members */part1 : PartDef1 {
}
```
```
Part with Ports
```
```
partport part1 {p0 :
NestedPortDef0 { port p1 :
PortDef1; port p2 :
PortDef2; port p3 :
PortDef3;}
portport p4 : PortDef4;p5 : PortDef5;
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 61**


```
Element Graphical Notation Textual Notation
```
```
Part with Graphical
Compartment
showing a standard
interconnection view
of part1.
```
```
partport part1 : Part1{p1 : P1Def;
port p6 : P6Def;
partpart part2:Part2;part3:Part3;
bindconnect p1 = part2.p2;part2.p3 to
part3.p4; bind part2.p5 = p6;
}
Part performs a
reference action
(action1) that can
subset or bind to
another action, and
an anonymous
reference action
(action2) that subsets
another action.
```
```
partperform action part0 {
action1; perform action2;
} action action2;
```
```
Part performs a
reference action
(action1) that
references and
subsets another
action (action3)
```
```
action Action3;action3 :
partperform action part0 {
action1action3; references
}
```
```
Part with Graphical
Compartment with
perform actions and
flows between them.
This is informally
referred to as a swim
lane.
```
```
partperform part2 : PartDef2 { action
action2; thenperformaction
action3;}
```
**62 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Parts Compartment
```
```
{ part part1 :
PartDef1 [1..*] ordered nonunique ;
/* ... */
}
```
**7.11.2Part Definitions and Usages**
A part definition or usage (that is not of a more specialized kind) is declared as a kind of occurrence definition or
usage (see7.9.2), using the kind keyword **part**. As a kind of item usage (see7.10), a part usage must only be
defined by item definitions (including part definitions) or KerML structures (see [KerML, 7.4.4]). The default
multiplicity of a part usage is[1..1], under the conditions described in7.6.3.
**item defpart def** Person;Vehicle {
**ref partpart** engine : Engine;driver[0..1] : Person;
} **part** wheels[4] : Wheel;
The base part definition and usage arePartandpartsfrom thePartslibrary model (see9.2.4). (For other
semantic constraints on part usages, see8.4.7).
**Note.** Because the base usage of a part usage is the part usagepartsdefined by the base part definitionPart, every
part usage is always directly or indirectly defined by at least one part definition, implicitly if not explicitly, in
addition to any other item definitions.

**7.12Ports
7.12.1Ports Overview**
_Metamodel references:_

- _Textual notation,8.2.2.12_
- _Graphical notation,8.2.3.12_
- _Abstract syntax,8.3.12_
- _Semantics,8.4.8_
A _port definition_ is a kind of occurrence definition (see7.9) that defines a connection point to enable interactions
between occurrences (most commonly parts). A _port usage_ is a kind of occurrence usage definition that is a usage of
a port definition.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 63**


A port usage may be connected to one or more other port usages (see7.14). Such connections enable interactions
between the occurrences that own the ports. The features of the port usages (whether inherited from its definition or
declared locally for the usage) specify what can be exchanged in such interactions. Since ports are themselves kinds
of occurrences, port definitions and usages can contain nested port usages.
A feature of a port may be _directed,_ with one of the _directions_ **in** _,_ **out** _,_ or **inout** (see also7.6.3)_._ Connected ports
must _conform:_ each feature of a port at one end of a connection must have a matching feature on a port at the other
end of the connection. Two features match if they have conforming definitions and either both have no direction or
they have conjugate directions. The _conjugate_ of direction **in** is **out** and vice versa, while direction **inout** is its
own conjugate. A transfer can occur from the **out** features of one port usage to the matching **in** features of
connected port usages. Transfers can occur in both directions between matching **inout** features.
Each port definition has a _conjugated_ port definition whose directed features are conjugate to those of the original
port definition. A conjugated port usage is a usage of a conjugated port definition. A conjugated port usage
automatically conforms to a usage of the corresponding original port definition.
**Table 10. Ports – Representative Notation
Element Graphical Notation Textual Notation**

```
Port Definition
```
```
port def PortDef1;
port def /* members */PortDef1 {
}
```
```
Port
```
```
port port1 : PortDef1;
port /* members */port1 : PortDef1 {
}
```
**64 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Ports Compartment
```
```
{ port port1 :
PortDef1 [1..*] ordered nonunique ;
/* ... */
}
```
```
Directed Features
Compartment
```
```
{ in attribute1 :
AttributeDef1; out attribute2 :
AttributeDef2; inout attribute3 :
AttributeDef3; in item1 : ItemDef1;
outinout item2 : ItemDef2;item3 :
ItemDef3;}
```
**7.12.2Port Definitions and Usages**
A port definition or usage is declared as a kind of occurrence definition or usage (see7.9.2), using the kind keyword
**port**. A port usage must only be defined by port definitions. The default multiplicity of a port usage is[1..1],
under the conditions described in7.6.3. All the features of a port definition or port usage, other than any nested port
usages, must be referential (non-composite).
**port defattribute** FuelingPort {flowRate : Real;
**outin** fuelReturn : Fuel;fuelOut : Fuel;
} **part def** FuelTank {
} **port** fuelOutPort : FuelingPort;
The base port definition and usage arePortandportsfrom thePortslibrary model (see9.2.5). (For other
semantic constraints on port usages, see8.4.8.)

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 65**


**7.12.3Conjugated Port Definitions and Usages**
Every port definition also implicitly declares a single, nested _conjugated port definition,_ which has the same features
as its original port definition, except that any directed features have conjugated directions (i.e., **in** and **out** are
reversed, with **inout** unchanged). The name of the conjugated port definition is always given by the name of the
original port definition with the character~prepended, in the namespace of the original port definition. For
example, if a port definition has the name _P_ , then its conjugated port definition has the name _P::'~P'_.
A _conugated port usage_ is a shorthand for declaring a port usage defined by a conjugated port definition. With this
shorthand, rather than using the actual name of the conjugated port definition, the name of the original port
definition can be used, preceded by the symbol~. For example,
**port** p : ~P;
is equivalent to
**port** p : P::'~P';
Since the symbol~is _not_ considered part of a name when used in a conjugated port usage, it does not have to be
placed within quotes, while quotes _do_ have to be used to represent the actual name of the conjugated port definition
as a lexical unrestricted name (see7.2.2). Note that, if the original port definition itself has a name that is itself
lexically represented as an unrestricted name, such as _'P-1',_ then its conjugated port definition has the (qualified)
name _'P-1'::'~P-1'_ , but the corresponding conjugated port usage is
**port** p1 : ~'P-1'
where the ~ is _not_ placed inside the quotes.

**7.13Connections
7.13.1Connections Overview**
_Metamodel references:_

- _Textual notation,8.2.2.13_
- _Graphical notation,8.2.3.13_
- _Abstract syntax,8.3.13_
- _Semantics,8.4.9_
**Connection Definition and Usage**
A _connection definition_ is both a relationship and a kind of part definition (see7.11) that classifies connections
between related things, such as items and parts. At least two of the owned features of a connection definition must
be _connection ends,_ which specify the things that are related by the connection definition. Connection definitions
with exactly two connection ends are called _binaryconnection definitions_ , and they classify _binary connections._
The features of a connection definition that are not connection ends characterize connections separately from the
connected things. Since a connection is a part, values of these non-end features can potentially change over the
lifetime of the connection. However, the values of connection ends (i.e., the things that are actually connected) do
not change over time (though they can potentially be occurrences that themselves have features whose values
change over time).
A connection usage is a part usage (see7.11) that is a usage of a connection definition, connecting usage elements
such as item and part usages. A connection usage redefines the connection ends from its definition, associating those

**66 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ends with the specific usage elements that are to be connected. For example, a connection definition could have
connection ends that are part usages defined by part definitionsPumpandTank. A usage of this connection
definition would then associate corresponding connection ends with specificpumpandtankpart usages. Supposing
that thepumpandtankpart usages have multiplicity 1 , then this means that the single value of thepumpusage is to
be connected to the single value of thetankusage.
A connection usage that connects parts is often a logical connection that abstracts away details of how the parts are
connected. For example, plumbing that includes pipes and fittings may be used to connect a pump and a tank. It is
sometimes desired to model the connection of the pump to the tank at a more abstract level without including the
plumbing. This is viewed as a logical connection between the pump and the tank.
Alternatively, the plumbing can be modeled as a part (informally referred to as an _interface medium_ ) where the
pump connects to the plumbing, and the plumbing connects to the tank. As a part itself, a connection can contain the
plumbing either as a composite feature, or as a reference to the plumbing that is owned by a higher level pump-tank
system context. In this way, the logical connection without structure can be transformed into a physical connection.
**Bindings and Successions**
Bindings and successions are special kinds of connections. They are usages, but, unlike regular connection usages,
they are _not_ part usages. The connections specified by bindings and successions are not occurrences and are not
created and destroyed. Rather, they assert specific relationships between the features that they connect, which must
be true at all times.
A _binding_ is a binary connection that requires its two related usages to have the same values. A binding can also be
used to bind a referential feature in one context to a composite feature in another context to assert they are the same
thing. For example, the steering wheel in a car may be considered part of the interior of the car, while at the same
time it is considered part of the steering subsystem. The steering wheel can be a composite part usage of the interior,
and a reference part usage of the steering subsystem, and these two usages can be bound together to assert that they
are the same part.
A _feature value_ is a shorthand for initializing or binding a usage to the result of an _expression_ (see7.18) as part of
the declaration of the usage. There are two types of feature value binding.

- A _fixed_ feature value establishes the binding of the usage to the result of evaluating the given expression at
    the point of declaration of the usage. Such a binding cannot be overridden in a redefinition of the usage
    because, once asserted, a binding must be true for all instances of the usage.
- A _default_ feature value also includes an expression, but it does not immediately establish the binding of
    the usage. Instead, the evaluation of the expression and the binding of the usage is delayed until the
    instantiation of a definition or usage that features the original usage. Unlike a fixed feature value, a default
    feature value can be overridden in a redefinition of its original feature with a new feature value (fixed or
    default). In this case, the new overriding feature value is used instead of the original feature value for
    binding the redefining usage.
A _succession_ is a binary connection that requires its two related usages to have values that are occurrences that
happen completely separated in time, with the first occurrence happening before the second. Successions can be
used to assert the ordering of any kind of occurrences in time, but are particularly useful for event occurrences (see
7.9) and performances of actions (see7.16).
**Flow Connection Usages**
A _flow connection usage_ is a connection usage that also represents the performance of a _transfer_ of some _payload_
between the values of connected usages, which must be occurrences. The transferred payload can be anything
(attribute value, item, part, etc.). The transfer is directed from the first connection end (the _source_ ) to the second
connection end (the _target_ ). There are three kinds of flow connections.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 67**


1. A _message_ is modeled as a flow connection usage that specifies that some transfer happens between the
    source and target ends, and can define the _payload_ that is to be transferred. However, a message does not
    specify how the payload is to be obtained from the source or delivered to the target.
2. A _streaming flow connection_ is modeled as a flow connection usage that not only specifies the source and
    target of a transfer (and, optionally, the payload), but also identifies the _source output_ feature of the source
    usage from which the payload is obtained and the _target input_ feature of the target usage to which the
    payload is to be delivered.
3. A _succession flow connection_ is modeled as a _succession flow connection usage,_ which is both a
    connection usage and a succession. A succession flow connection is specified in the same way as a
    streaming flow connection, but it adds the further constraint that the transfer source must complete before
    the transfer starts, and the transfer must complete before the target can start.
Messages are typically used to model abstract logical interaction between part usages in a certain context, which
may be realized in a more detailed model using streaming or succession flow connections (or transfers from send
actions to accept actions, see7.16).
**Table 11. Connections – Representative Notation
Element Graphical Notation Textual Notation**

```
Connection
Definition
```
```
connection def ConnectionDef1 {
endend end1 : Part1;end2 : Part2;
}
connection def ConnectionDef1 {
}/* members */
```
```
Connection
Definition
```
```
connection def ConnectionDef1 {
Part1[0..1]; end end1 :
Part2[1..*]; end end2 :
}
```
```
Connection
Definition (n-ary
with 3 ends)
```
```
connection def ConnectionDef1 {
Part1[0..1]; end end1 :
endend end2 : Part2;end3 : Part3;
}
```
**68 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Connection
```
```
connection : ConnectionDef1 {connection1
endend end1 ::> part1;end2 ::> part2;
}
connection : ConnectionDef1 {connection1
}/* members */
```
```
Connection
```
```
connection : ConnectionDef1connection1
part2; connect part1 to
```
```
Connection (n-ary
with 3 ends)
```
```
connection : ConnectionDef1connection1
part2, part3); connect (part1,
```
```
Nested Connection
```
```
part defpart part2 : Part2 {Part1 {
Part4; part part4 :
} part part3 : Part3 {
Part5; part part5 :
} connection
connection1 :ConnectionDef1
part2.part4 connect
} to part3.part5;
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 69**


```
Element Graphical Notation Textual Notation
```
```
Proxy Connection
```
```
part defpart part2 : Part2 {Part1 {
Part4; part part4 :
} part part3 : Part3 {
Part5; part part5 :
} connection
connection1 :ConnectionDef1
part2.part4 connect
} to part3.part5;
Connections
Compartment
```
```
Binding Connection
```
```
partpart part1 : Part1 {part2 : Part2 {
Part4; ref part part4R :
} part part3 : Part3 {
Part4; part part4 :
} bind part2.part4R =
} part3.part4;
```
```
Binding Connection
```
```
part defpart part2:part2 {Part1 {
part4R:Part4; ref part
} part part3:part3 {
} part part4:Part4;
bind part2.part4R =part3.part4;
}
```
**70 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Flow
```
```
actionout action1:Action1 {item1:Item1;
} action action2:Action2 {
} in item1:Item1;
flowto action1.item1action2.item1;
```
```
Message
```
```
partport part1:Part1 {p4:P4;
} part part2:Part2 {
} port p2:P2;
messagefrom part1.p4 of item1:Item1
to part2.p2;
```
```
Interface as Node
```
```
port defoutitem Pa {item1 :
Item1; port p1 : P1 { out
itemport item1_1 }p2 : P2 { out
itemport item1_2 }p3 : P3 { out
item } item1_3 }
part defport pa : Pa;Part1 {
} part def Part2 {
} port pb : ~Pa;
interface def InterfaceDef2 {
endend source : Pa;target : ~Pa;
} part part1 : Part1;
partinterface part2 : Part2;interface2 :
InterfaceDef2 connect source :>
part1.pa to target :> part2.pb;
/*...*/
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 71**


```
Element Graphical Notation Textual Notation
```
```
Flow as Node
```
```
action Action1 {action1 :
} out item1 : Item1;
action Action2 {action2 :
} in item2 : Item1;
flowfrom flow1_2source :>
action1.item1 to target :>
action2.item2 { flow
source.item1.item1_1 to
target.item2.item2_1; flow
source.item1.item1_2 to
target.item2.item2_2; flow
source.item1.item1_3 to
target.item2.item2_3;}
```
```
Flows Compartment
```
```
{ flow action1.output
action2.input; to
action1.output succession flow
/* ... */ to action2.input;
}
```
**72 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Message
```
```
occurrence defpart a1 : PartDef1 {{
msg1_source; event occurrence
} part a2 : PartDef2 {
msg1_target; event occurrence
} message msg1
a1.msg1_source from
a2.msg1_target; to
}
```
**7.13.2Connection Definitions and Usages**
A connection definition or usage (that is not of a more specialized kind) is declared as a kind of occurrence
definition or usage (see7.9.2), using the kind keyword **connection**. A connection usage must only be defined by
connection definitions (of any kind) or KerML association structures (see [KerML, 7.4.5]).
Unless it is abstract, a connection definition or usage must have at least two end features (which may be owned or
inherited). A _binary_ connection definition or usage is one that has exactly two end features. The end features of a
connection definition or usage are always considered referential (non-composite), whether or not their declaration
explicitly includes the **ref** keyword. (See also7.6.3on the notation for end features.)
Connection definitions and usages are also relationships. For a connection definition, its related elements are given
by the definitions of its end features. For a connection usage, its related elements are the features associated to each
of its end features via _reference subsetting_ relationships, whose textual notation is the keyword **references** or the
equivalent symbol::>.(See also7.2on Relationships.)
// The related elements of this connection definition// are the part definitions Hub and Device.
**connectionendpartdef** hub : Hub[1];DeviceConnection {
**endpart** devices : Device[0..*];
// This is a non-end feature of the connection definition. **attribute** bandwidth : Real;
}
// The related elements of this connection usage// are the part usages mainSwitch and sensorFeed.
**connectionendpart** connection1 : DeviceConnection {hub ::> mainSwitch[1];
} **endpart** device ::> sensorFeed[1];
There are two shorthand textual notations for connection usages.
Rather than using explicit end feature declarations in the body of a connection usage, the related features of the
connection usage may be identified in a comma-separated list, between parentheses(...), preceded by the keyword

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 73**


**connect** , placed after the connection usage declaration and before its body. The identification of a related feature
may optionally be preceded by an end feature name followed by the keyword **references** or the symbol::>, and/
or followed by a multiplicity. If the declaration part of the connection usage is empty when using this notation, then
the keyword **connection** may be omitted.
**connection** hub ::> mainSwitch[1], device ::> sensorFeed[1]connection1 : DeviceConnection **connect** (
);
// This is a ternary connection.// It is equivalent to " **connectionconnect** (item1, item2, item3);"
**connect** (axle, wheel1, wheel2);
If the connection usage is binary, then a further special notation may be used in which the source related feature is
identified directly after the keyword **connect** and the target related feature is identified after the keyword **to**. As
above, if the declaration part of the connection usage is empty, then the keyword **connection** may be omitted.
**connectionconnect** connection1 : DeviceConnectionhub ::> mainSwitch[1] **to** device ::> sensorFeed[1];
**connect** leftWheel **to** leftHalfAxle;
The base connection definition and usage areConnectionandconnectionsfrom theConnectionslibrary (see
9.2.6). For a binary connection definition or usage, the base definition and usage are further restricted to
BinaryConnectionandbinaryConnections, which enforce that the connection has exactly two ends.
If a connection definition has a single owned superclassification relationship with another connection definition, it
may inherit end features from this general connection definition. However, if it declares any owned end features,
then each of these must redefine an end feature of the general connection definition, in order, up to the number of
end features of the general connection definition. If no redefinition is given explicitly for an owned end feature, then
it is considered to implicitly redefine the end feature at the same position, in order, of the general connection
definition, if any.
// Implicitly specializes Connections::BinaryConnection by default. **connectiondef** Ownership {
**attributeenditem** owner[1..*] : LegalEntity; // Implicitly redefines BinaryConnection::source.valuationOnPurchase : MonetaryValue;
} **enditem** ownedAsset[*] : Asset; // Implicitly redefines BinaryConnection::target.
**connectionenditemdef** owner[1]; // Implicitly redefines Ownership::owner.SoleOwnership **specializes** Ownership {
} // ownedAsset is inherited.
Note that any specialization of a binary connection definition must also be binary. That is, it can inherit or redefine
the two end features from the general connection definition, but it cannot add more end features than two.
If a connection definition has more than one owned superclassification with other connection definitions, then it
_must_ declare a number of owned end features at least equal to the maximum number of end features of any of the
general connection definitions. Each of these owned end features must then redefine the corresponding end feature
(if any) at the same position, in order, of each of the general connections, either explicitly or implicitly.
Similar rules hold for the end features of a connection usage that is defined by one or more connection definitions
and/or subsets or redefines one or more connection usages.

**74 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
connectionendpart connection1 : DeviceConnection {hub ::> mainSwitch[1]; // Implicitly redefines DeviceConnection::hub.
} endpart device ::> sensorFeed[1]; // Implicitly redefines DeviceConnection::device.
```
**7.13.3Bindings as Usages**
A binding can be declared as a usage as described in7.6.3, using the kind keyword **binding**. Note that a binding is
not a kind of occurrence usage (unlike a regular connection usage), so the notations for time slices, snapshots and
individuals (described in7.9) do _not_ apply to it. Further, the two related features of a binding are specified using a
special notation.
The two related features of a binding are identified after its declaration part and before its body, following the
keyword **bind** and separated by the symbol=. If the declaration part is empty, then the keyword **binding** may be
omitted. The end features of a binding always have multiplicity[1..1].
**part defpart** Vehicle {fuelTank {
} **out** fuelFlowOut : Fuel;
**partin** engine {fuelFlowIn : Fuel;
} **binding** fuelFlowBinding
**bind** fuelTank.fuelFlowOut = engine.fuelFlowIn;
// The following is equivalent to the above, but// without the name.
} **bind** fuelTank.fuelFlowOut = engine.fuelFlowIn;
The base usage for a binding is the the KerML featureselfLinksfrom theLinksmodel in the Kernel Semantic
Library (see [KerML, 9.2.3]).

**7.13.4Feature Values**
A _feature value_ is a relationship between an owning usage and a _value expression,_ whose result provides values for
the feature. The feature value relationship is specified as either _bound_ or _initial,_ and as either _fixed_ or _default._ A
usage can have at most one feature value relationship.
A fixed, bound feature value relationship is declared using the symbol=followed by a representation of the value
expression (using the expression notation from [KerML, 7.4.9]). This notation is appended to the declaration of the
usage being bound by the feature value. Usages that have a feature value relationship of this form implicitly have a
nested binding between the feature and the result of the value expression.
**attributeitem def** TestRecord {monthsInYear : Natural = 12;
**attributederivedattribute** scores[1..*] : Integer;averageScore[1] : Rational = sum(scores)/size(scores);
} **attribute** cutoff : Integer default = 0.75 * averageScore;
**Note.** The semantics of binding mean that such a feature value asserts that a feature is _equivalent_ to the result of the
value expression. To highlight this, a feature with such a feature value can be flagged as **derived** (though this is not
required, nor is it required that the value of a **derived** feature be computed using a feature value – see also7.6.3).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 75**


A fixed, initial feature value relationship is declared as above but using the symbol:=instead of=. In this case, the
usage also has an implicit nested binding, but the binding only applies to the _starting snapshot_ of the owning
definition or usage of the bound usage (which means that that the owner must be a kind of occurrence definition or
usage, see7.9). That is, the result of the value expression gives the initial values of the declared feature but, unlike
in the case of a bound value, these initial values may subsequently change.
**part defattribute** Counter {count[1] : Natural := 0;
}
A default feature value relationship is declared similarly to the above, but with the keyword **default** preceding the
symbol=or:=, depending on whether it is bound or initial. However, for a default, bound feature value, the symbol
=may be elided.
**part defattribute** Vehicle {mass : Real **default** 1500.0;
} **feature** engine[1] : Engine **default** := standardEngine;
**itemattributedef** TestWithCutoff :> TestRecord {cutoff : Rational **default** = 0.75 * averageScore;
}
For a default feature value relationship, no implicit binding is added to the usage declaration, but the default will
apply when an instance of the owning definition or usage is constructed, if no other explicit values are given for the
defaulted usage.

**7.13.5Successions as Usages**
A succession can be declared as a usage as described in7.6.3, using the kind keyword **succession**. Note that a
succession is not a kind of occurrence usage (unlike a regular connection usage), so the notations for time slices,
snapshots and individuals (described in7.9) do _not_ apply to it. Further, the two related features of a succession are
specified using a special notation.
The two related features of a succession are identified after its declaration part and before its body, following the
keyword **succession** and separated by the keyword **then**. If the declaration part is empty, then the keyword
**succession** may be omitted. The related features of a succession must be occurrence usages. As for regular
connection usages, constraining multiplicities can also be defined on the end features of a succession.
**partactiondef** Camera {focus[*] : Focus;
**action** // Each focus may be preceded by a previous focus.shoot[*] : Shoot;
**successionfirst** focus[0..1]multiFocusing **then** focus[0..1];
// Each shoot must follow a focus. **first** focus[1] **then** shoot[0..1];
// The Camera can be focused after shooting. **first** shoot[0..1] **then** focus;
}
If a succession is placed lexically directly between the two occurrence usages that are its related elements, then the
declaration of the succession can be shortened to just the keyword **then** , prepended to the declaration of the second
occurrence usage. A multiplicity for the source end of the succession can optionally be placed directly after the
**then** keyword.

**76 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**occurrencetimeslicedef** preflight[1];Flight {
**then timeslicethentimeslice** inflight[1];postflight[1];
}
// The above is equivalent to the following. **occurrencedef** Flight {
**timeslicefirst** preflightpreflight[1]; **then** inflight;
**timeslicefirst** inflightinflight[1]; **then** postflight;
} **timeslice** postflight[1];
**Note.** There are additional shorthands for the use of successions within the bodies of action definitions and usages
(see7.16.4).
The base usage for a succession is the KerML featurehappensBeforeLinksfrom theOccurrencesmodel in the
Kernel Semantic Library (see [KerML, 9.2.4]).

**7.13.6Flow Connection Usages and Messages**
A flow connection usage may be declared as either a message, a streaming flow or a succession flow.
A flow connection usage is declared as a message similarly to a regular connection usage (see7.13.2), but with the
kind keyword **message**. In addition, the declaration of a message may also optionally include an explicit
specification of the name, type (definition) and/or multiplicity of the payload of the message, after the keyword **of**.
The payload name is followed by the keyword **defined by** (or the symbol:), but this keyword (or the symbol) is
omitted if the name is omitted. In the absence of a payload specification, the message declaration does not constrain
what kinds of values may be transferred between the source and target of the message.
A message is always abstract (whether or not the **abstract** keyword is included explicitly in its declaration), so its
declaration may or may not include identification of source and target related features. If they are included, then
they follow the payload specification (if any), with the source related feature identified after the keyword **from** ,
followed by the target related feature after the keyword **to**. Alternative, if the source and target identification is _not_
included, then the message declaration may include a feature value (see7.13.4) to provide a value for the message.
**partattribute defdef** Vehicle {ControlSignal;
**partpart** controller;engine;

} **messageof** ControlSignal **from** controller **to** engine;
A streaming flow is declared similarly to a message, but with the kind keyword **flow**. However, instead of
identifying the source and target features of the flow, such a flow declaration must identify(after the keyword **from** )
the output feature of the source from which the flow receives its payload and (after the keyword **to** ) the input
feature of the target to which the flow delivers the payload. This is done by giving a feature chain with at least two
features, the last of which identifies the output or input feature, with the preceding part of the chain identifying the
source or target of the flow. If no declaration part or payload specification is included in the flow declaration, then
the **from** keyword may also be omitted.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 77**


**part defpart** Vehicle {fuelTank {
} **out** fuelOut : Fuel;
**partin** engine {fuelIn : Fuel;
}// This flow connection usage actually connects the fuelTank to the
// engine. The transfer moves Fuel from fuelOut to fuelIn. **flow** fuelFlow **of** flowingFuel : Fuel
**from** fuelTank.fuelOut **to** engine.fuelIn;
// The following is equivalent to the above, except without// the name and leaving the payload implicit.
} **flow** fuelTank.fuelOut **to** engine.fuelIn;
A succession flow is declared like a flow declaration above, but using the keyword **succession flow**.
**action defaction** TakePicture {focus : Focus {
} **out** image : Image;
**actionin** shoot : Shoot {image : Image;
}// The use of a succession flow connection usage means that focus must
// complete before the image is transferred, after which shoot can begin. **succession flow** focus.image **to** shoot.image;
}
The base flow connection usages are from theConnectionslibrary model (see7.13):

- messageConnectionsfor a message.
- flowConnectionsfor a streaming flow.
- successionFlowConnectionsfor a succession flow.

**7.14Interfaces
7.14.1Interfaces Overview**
_Metamodel references:_

- _Textual notation,8.2.2.14_
- _Graphical notation,8.2.3.14_
- _Abstract syntax,8.3.14_
- _Semantics,8.4.10_
An _interface definition_ is a kind of connection definition (see7.13) whose ends are restricted to be port definitions
(see7.12). An _interface usage_ is a kind of connection that is usage of an interface definition. The ends of an
interface usageare restricted to be port usages.
An interface is simply a connection all of whose ends are ports. As such, an interface facilitates the specification and
reuse of compatible connections between parts. For example, consider a _Power_ interface definition between an
_Appliance_ and _Wall Power_ .The _power_ port on one end of the interface represents the _Appliance_ connection

**78 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


point, and the _outlet_ port on the other end represents the _Wall Power_ connection point. This interface can then be
used for connecting many different appliances to wall power.
When modeling physical interactions, an interface definition or usage can contain constraints (see7.19) toconstrain
the values of the features of the ports on its ends. For example, such features may be _across_ and _through_ variables,
which are constrained by conservation laws across the interface (e.g., Kirchhoff’s Laws). When specifying
aninterface between electrical components, theacross and through variables are port features defined as _Voltage_
and _Current_ quantities, respectively. The feature values on either port are constrained such that the voltages must
be equal, and the sum of the currents must equal zero.
**Table 12. Interfaces – Representative Notation
Element Graphical Notation Textual Notation**

```
Interface Definition
```
```
interface def InterfaceDef1 {
endend port1:Port1;port2:Port2;
}
interface def InterfaceDef1 {
}/* members */
```
```
Interface
```
```
interface InterfaceDef1 {interface1 :
endend port1 :> pa;port2 :> pb;
}
interface InterfaceDef1 {interface1 :
}/* members */
```
```
Interfaces
Compartment
```
```
{ interface interface1
: InterfaceDef1 [1..*]; interface interface2
: InterfaceDef2;/* ... */
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 79**


```
Element Graphical Notation Textual Notation
```
```
Interface
```
```
partport part1:Part1 {p4:P4;
} part part2:Part2 {
} port p2:P2;
interface InterfaceDef1interface1 :
connectto part2.p2;part1.p4
```
**80 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Interface as Node
(with flow)
```
```
partport part1 : Part1 {pa : Pa;
} part part2 : Part2 {
} port pb : ~Pa;
interface : InterfaceDef2interface2
part1.pa connect source :>
part2.pb { to target :>
partpart partN:PartN {partx;
partpart party;partz;
} message of item1 :
Item1 from source to
target { message
Item1_1 of item1_1 :
fromto partN.partx;source.p1
messageof item1_2 :
Item1_2 from source.p2
messageto partN.party;
Item1_3 of item1_3 :
fromto partN.partz;source.p3
messageof item1_1 :
Item1_1 from
partN.partx to target.p1 ;
messageof item1_2 :
Item1_2 from
partN.party to target.p2;
messageof item1_3 :
Item1_3 from
partN.partz to target.p3;
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 81**


```
Element Graphical Notation Textual Notation
```
```
} }
```
**7.14.2Interface Definitions and Usages**
An interface definition or usage is declared like a connection definition or usage (see7.13.2), but using the kind
keyword **interface**. An interface usage must only be defined by interface definitions. All the end features of an
interface definition or usage must be port usages, so the use of the **port** keyword is optional on such end features.
The shorthand notations for connection usages described in (see7.13.2) may also be used for interface usages.
However, if the declaration part of an interface usage is empty, then the **interface** keyword is still included, but
the **connect** keyword may be omitted.
**port defout** fuel : Fuel;FuelingPort {
} **interface def** FuelingInterface {
**endend** fuelOutPort : FuelingPort;fuelInPort : ~FuelingPort;
} **interface** fuelLine : FuelingInterface
// The following is equivalent to the above, except **connect** fuelTank.fuelingPort **to** engine.fuelingPort;
// for not using a specialized interface definition. **interface** fuelTank.fuelingPort **to** engine.fuelingPort;

The base interface definition and usage areInterfaceandinterfacessfrom theInterfacesslibrary (see
9.2.7). For a binary interface definition or usage, the base definition and usage are further restricted to
BinaryInterfaceandbinaryInterfaces, which enforce that the interface has exactly two ends.

**7.15Allocations
7.15.1Allocations Overview**
_Metamodel references:_

- _Textual notation,8.2.2.15_
- _Graphical notation,8.2.3.15_
- _Abstract syntax,8.3.15_
- _Semantics,8.4.11_
An _allocation definition_ is a _connection definition_ (see7.13) that specifies that a target element is responsible for
realizing some or all of the intent of the source element. An _allocation usage_ is a usage of one or more allocation
definitions. An allocation definition or usage can be further refined using nested allocation usages that provide a
finer-grained decomposition of the containing allocation.
As used by systems engineers, an allocation denotes a "mapping" across the various structures and hierarchies of a
system model. This concept of "allocation" requires flexibility suitable for abstract system specification, rather than
a particular constrained method of system or software design. System modelers often associate various elements in a
user model in abstract, preliminary, and sometimes tentative ways. Allocations can be used early in the design as a
precursor to more detailed rigorous specifications and implementations.

**82 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Allocations can provide an effective means for navigating a model by establishing cross relationships and ensuring
that various parts of the model are properly integrated. Since these relationships are instantiable connections, they
can also be semantically related to other such relationships, including satisfying requirements (see7.20), performing
actions (see7.16) and exhibiting states (see7.17). Modelers can also create specialized allocation definitions to
reflect conventions for allocation on specific projects or within certain system models.
**Table 13. Allocations – Representative Notation
Element Graphical Notation Textual Notation**

```
Allocation Definition
```
```
allocation def AllocationDef1;
allocation def AllocationDef1 {
}/* members */
```
```
Allocation
```
```
allocation : AllocationDef1;allocation1
allocation : AllocationDef1 {allocation1
}/* members */
```
```
Allocated
Compartment
```
```
partallocate part3 {part1 to
part3; allocate part3 to
part2;}
```
```
Allocation
```
```
partpart part1 : Part1;part2 : Part2;
allocate part1 to part2;
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 83**


```
Element Graphical Notation Textual Notation
```
```
Allocation (with sub
allocation)
```
```
partperform part1 : Part1 {action1;
} part part2 : Part2 {
} perform action2;
allocate { part1 to part2
part1.action1 allocate
} to part2.action2;
```
**7.15.2Allocation Definitions and Usages**
An allocation definition or usage is declared like a connection definition or usage (see7.13.2), but using the kind
keyword **allocation**. An allocation usage must only be defined by allocation definitions. Allocation definitions
and usages are always binary, having exactly two end features, even if abstract.
Shorthand notations similar to those for connection usages, as described in see7.13.2, may also be used for
allocation usages, but using the keyword **allocate** instead of **connect**. If the declaration part of the allocation
usage is empty when using this notation, then the keyword **allocation** may be omitted.
**part defpart** LogicalSystem {component : LogicalComponent;
} **part def** PhysicalDevice {
} **part** assembly : PhysicalAssembly;
**allocation defendpart** logical : LogicalSystem;LogicalToPhysicalAllocation {
**end part** physical : PhysicalDevice;
// This is a nested sub-allocation. **allocate** logical.component **to** physical.assembly;
} **part** system : LogicalSystem;
**partallocation** device : PhysicalDevice;systemToDevice : LogicalToPhysicalAllocation
**allocate** logical ::> system **to** physical ::> device;
The base allocation definition and usage areAllocationandallocationsfrom theAllocationslibrary
model (see9.2.8).

**7.16Actions
7.16.1Actions Overview**
_Metamodel references:_

- _Textual notation,8.2.2.16_
- _Graphical notation,8.2.3.16_
- _Abstract syntax,8.3.16_

**84 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


- _Semantics,8.4.12_
**Action Definition and Usage**
An _action definition_ is a kind of occurrence definition (see7.9) that classifies action performances. An _action usage_
is a kind of occurrence usage that is a usage of one or more action definitions.
An action definition may have features with directions **in** , **out** or **inout** that act as the _parameters_ of the action.
Features with direction **in** or **inout** are input parameters, and features with direction **out** or **inout** are output
parameters. An action usage inherits the parameters of its definitions, if any, and it can also define its own
parameters to augment or redefine those of its definitions.
Actions are occurrences over time that can coordinate the performance of other actions and generate effects on items
and parts involved in the performance (including those items' existence and relation to other things). The features of
an action definition or usage that are themselves action usages specify the performance of the action in terms of the
performances of each of the subactions. If an action has parameters, then it may also transform the values of its input
parameters into values of its output parameters.
Action definitions and usages follow the same patterns that apply to structural elements (see7.6). Action definitions
and action usagescan be decomposed into lower-level action usagesto create an action tree, and action usagescan
be referenced by other actions. In addition, an action definition can be subclassified, and an action usage can be
subsetted or redefined. This provides enhanced flexibility to modify a hierarchy of action usagesto adapt to its
context.
**Performed Actions**
A _perform action usage_ is an action usage that specifies that an action is performed by the owner of the performed
action usage. A perform action usage is referential, which allows the performed action behavior to be defined in a
different context than that of the performer (perhaps by an action usage in a functionally decomposed action tree).
However, if the owner of the perform action usage is an occurrence, then the referenced action performance must be
carried out entirely within the lifetime of the performing occurrence.
In particular, a perform action usage can be a feature of a part definition or usage, specifying that the referenced
action is performed by the containing part during its lifetime. A perform action usage can also be a feature of an
action definition or usage. In this case, the perform action usage represents a "call" from the containing action to the
performed action.
**Sequencing of Actions**
Since action usages are kinds of occurrence usages, their ordering can be specified using successions (see7.13).
However, a succession between action usages may, additionally, have a _guard condition,_ represented as a Boolean
expression (see7.18). If the succession has a guard, then the time ordering of the source and target of the succession
is only asserted when the guard condition evaluates totrue.
The sequencing of action usagesmay be further controlled using _control nodes_ , which are special kinds of action
usages that impose additional constraints on action sequencing. Control nodes are always connected to other actions
usages by incoming and outgoing successions (with or without guards). The kinds of control nodes include the
following.
- A _fork node_ has one incoming succession and one or more outgoing successions. The actions connected to
the outgoing successions cannot start until the action connected to the incoming succession has completed.
- A _join node_ has one or more incoming successions and one outgoing succession. The action connected to
the outgoing succession cannot start until all the actions connected to the incoming successions have
completed.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 85**


- A _decision node_ has one incoming succession and one or more outgoing successions. Exactly one of the
    actions connected to an outgoing succession can start after the action connected to the incoming
    succession has completed. Which of the downstream actions is performed can be controlled by placing
    guards on the outgoing successions.
- A _merge node_ has one or more incoming successions and one outgoing succession. The action connected
    to the outgoing succession cannot start until any one of the actions connected to an incoming succession
    has completed.
**Bindings and Flows Between Actions**
An output parameter of one action usage may be _bound_ to the input parameter of another action usage (see7.13on
binding). Such a binding indicates that the values of the target input parameter will always be the same as the values
of the source output parameter. If the two actions are performed concurrently, then this equivalence will be
maintained over time throughout their performances. An input parameter of an action definition or usage can also be
bound to the input parameter of a nested action usage, passing the values of the input parameter into the nested
action, and an output parameter of a nested action usage can be bound an output parameter of a containing action
definition or usage, passing the values of the output parameter out.
The binding of action parameters, however, does not model the case when there is an actual _transfer_ of items
between the actions that may itself take time or have other modeled properties. Such a transfer can be more properly
modeled using a flow connection between the two action usages (see7.13), in which the transfer source output is an
output parameter of the source action usage and the transfer target input is the input parameter of the target action
usage. A streaming flow connection represents a flow in which the transfer can be ongoing while both the source
and target action are being performed. A succession flow connection represents a flow that imposes the additional
succession constraint that the transfer cannot begin until the source action completes and the target action cannot
start until the transfer has completed.
Transfers can also be performed using _sendandaccept action usages_. In this case, the source and target of the
transfer do not have to be explicitly connected with a flow. Instead, the source of the transfer is specified using a
send action usage contained in some some sourcepart or action, while the target is given by an accept action usage
in some destination part or action (which may be the same as or different than the source). A send action usage
includes an expression that is evaluated to provide the values to be transferred, and it specifies the destination to
which those values are to be sent (possibly delegated through a port and across one or more interfaces – see also
7.12and7.14on interfaces between ports). An accept action usage specifies the type of values that can be received
by the action. When a send action performed in the source is matched with a compatible accept action performed in
the destination, then the transfer of values from the origin to the destination can be completed.
**Assignment Actions**
An _assignment action usage_ is used to change the value of a _referent_ feature of a _target_ occurrence. The target is
specified as the result of an expression and the referent is specified as a feature chain relative to that target. The new
value for the feature is determined as the result of a different expression. When the assignment action usage
completes, the referent feature has the new assigned value for the target occurrence.
Note that the target must be an occurrence, because the values of the features of attributes do not change over time
(see also7.7on attributes and7.9on occurrences). If the referent feature has a multiplicity upper bound other than 1,
then an assignment action can assign multiple values to it, consistent with the multiplicity of the feature. The values
are all assigned atomically, at the same time.
A _initializing feature value_ can be used as a shorthand for assigning an initial value to a usage as part of the
declaration of the usage that is a feature of an occurrence definition or usage. Unlike when feature is a bound using a
feature value (as described in7.13), the initial value of a feature can be later assigned a different value.
As for a binding feature value, there are two types of initializing feature value.

**86 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


- A _fixed_ feature value assigns the result of evaluating the given expression to a usage at the point of
    declaration of the usage. Such an assignment cannot be overridden in a redefinition of the usage because,
    once asserted, it would be indeterminate which initialization is to be used.
- A _default_ feature value also includes an initial-value expression, but it does not immediately assign an
    initial value to the usage. Instead, the evaluation of the expression and the assignment of its result to the
    usage is delayed until the instantiation of a definition or usage that features the original usage. Unlike a
    fixed feature value, a default feature value can be overridden in a redefinition of its original feature with a
    new feature value (fixed or default). In this case, the new overriding feature value is used instead of the
    original feature value for initializing the redefining usage.
**Structured Control Actions**
_Structured controlaction usages_ are used to control the performance of nested action usages in a structured way.
There are three kinds of structured control action usages:
1. An _if action usage_ evaluates a _condition expression_ and then performs a _then clause_ action usage if the
expression evaluates to true, or, optionally, an _else clause_ action usage if the expression evaluates to false.
2. A _while loop action usage_ performs a _body clause_ action usage iteratively, as long as its _while expression_
continues to evaluate to true and its _until expression_ continues to evaluate to false.
3. A _for loop action usage_ performs a _body clause_ action usage iteratively, assigning a _loop variable_
successively for each iteration to the values resulting from the evaluation of a _sequence expression._
**Table 14. Actions – Representative Notation
Element Graphical Notation Textual Notation**

```
Action Definition
```
```
action def ActionDef1;
action def /* members */ActionDef1 {
}
```
```
Action
```
```
action ActionDef1;action1 :
action ActionDef1 {action1 :
}/* members */
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 87**


```
Element Graphical Notation Textual Notation
```
```
Action with
Parameters
```
```
item defin item ItemDef1 {'item1.1';
outin itemitem 'item1.3';'item1.2';
} action action1 {
:ItemDef1; inout param1
ItemDef2; out param2 :
}
```
```
Action with
Graphical
Compartment
showing standard
action flow view
```
```
action Action1 {action1 :
inbind input1;input1 =
action2.input2; action action2 :
Action2 { in input2;
} out output2;
flowto action2.output2
action3.input3; action action3 :
Action3 { in input3;
} out output3;
= output1; bind action3.output3
} out output1;
```
**88 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Actions
Compartment
```
```
{ action action1 :
ActionDef1 [1..*] ordered nonunique ;
/* ... */ performaction
action10; action action11 {
'action11.1'; action
'action11.2'; action
} }
```
```
Perform Actions
Compartment
```
```
{ perform action
action1 :ActionDef1 [1..*]
/* ... */orderednonunique;
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 89**


```
Element Graphical Notation Textual Notation
```
```
Perform Actions
Swimlanes
```
```
Note. In View2, part0 has been elided.
```
```
packagepart def SwimLanes {Part0;
part defpart def Part1;Part2;
PartDef0 { part part0 :
performpart part1 :action0;
PartDef1 { perform
action0.action1; perform
action0.action4;}
PartDef2 { part part2 :
action0.action2; perform
action0.action3; perform
} }
actionaction action0 {action1;
actionaction action2;action3;
action action4;
action1; first start then
then action2; first action1
then action3; first action2
then action4; first action3
then done; first action4
} }
```
**90 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Parameters
Compartment
```
```
{ in param1 : ParamDef
[1..*] nonuniqueordered ;
} /* ... */
```
```
Actions with and
without Conditional
Succession
```
```
action Action1;action1 :
action Action2;action2 :
successionif guard1action1 then
action2;
or
action Action1;action1 :
ifaction guard1action2 : then action2;
Action2;
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 91**


```
Element Graphical Notation Textual Notation
```
```
Actions with Control
Nodes
```
```
firstthenfork start;fork1;
thenthen action1;action2;
actionthen action1;join1;
actionthen action2;join1;
jointhen join1; decide decision1;
action3; if guard2 then
action4; if guard1 then
actionthen action3;merge1;
actionthen action4;merge1;
mergethen done;merge1;
```
```
Performed By
Compartment No textual notation
```
**92 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Action with Loop
(body in textual
notation)
```
```
packageaction Loop {
actionWithLoop { attribute
x:Integer := 1; attribute
increment:Integer = 1; attribute
y:Integer; loopaction loop1
{ assign y :=
2*x; thenassign x
:= x+increment;} until x >= 10;
} then done;
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 93**


```
Element Graphical Notation Textual Notation
```
```
Action with Loop
(body in graphical
notation)
```
```
packageaction Loop {
actionWithLoop { attribute
x:Integer := 1; attribute
increment:Integer = 1; attribute
y:Integer; loopaction loop1
{ assign y :=
2*x; thenassign x
:= x+increment;} until x >= 10;
} then done;
}
```
**94 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Accept Action
```
```
portitem def viewPort;Scene;
action Triggertrigger1 : accept scene :
Scene via viewPort;
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 95**


```
Element Graphical Notation Textual Notation
```
```
Send Action
```
```
item defitem picture : Picture;Picture;
port displayPort;
action defaction send1 : Send1Send1;
send displayPort;Show(picture) via
```
**96 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Accept and Send
Action Flow
```
```
partport camera {viewPort;
port displayPort;
TakePicture { action takePicture :
acceptaction scene : Scenetrigger
via viewPort; thenaction focus
: Focus { initem scene
= trigger.scene; out item image;
} flow from
focus.imageshoot.image; to
: Shoot { then action shoot
flow fromin item focus.image;image
picture; out item
} then send
Show(shoot.picture)displayPort; via
} }
partport screen {displayPort;
}
calc defin item Show {picture;
processedPicture; item
*//* process picture
processedPicture; return
}
```
**7.16.2Action Definitions and Usages**
An action definition or usage (that is not of a more specialized kind) can be declared as a kind of occurrence
definition or usage (see7.9.2), using the kind keyword **action**. An action usage must only be defined by action
definitions (of any kind) or KerML behaviors (see [KerML, 7.4.7]).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 97**


Any directed features declared in the body of an action definition or usage are considered to be owned parameters of
the action. Features with direction **in** are input parameters, those with direction **out** are output parameters, and
those with direction **inout** are both input and output parameters.
**action** // The following two features are considered parameters. **def** TakePicture {
**inout** scene : Scene;picture : Picture;
**bindaction** focus.scene = scene;focus : Focus ( **in** scene, **out** image);
**firstflow** focus.imagefocus **then** shoot; **to** shoot.image;
**actionbind** picture = focus.picture;shoot : Shoot ( **in** image, **out** picture);
}
If an action definition has superclassification relationships (implicit or explicit) with other action definitions (or
KerML behaviors), then each of the owned parameters of the specialized action definition must redefine, in order,
the parameter at the position of each of the general action definitions. The redefining parameters must have the same
direction as the redefined parameters.
**actionaction defdef** A {B { **inin** a1;b1, **outout** a2; }b2; }
**actionindef** c1 **redefines** C **specializes** a1 **redefines** A, B { b1;
} **out** c2 **redefines** a2 **redefines** b2;
If an action definition has a single superclassification, then the specialized action definition may declare fewer
owned parameters than the general action definition, inheriting any additional parameters from the general definition
(which are considered to be ordered after any owned parameters). If there is more than one superclassification, then
every parameter from every general action definition must be redefined by an owned parameter of the specialized
action definition. If the required redefinitions are not explicitly declared for a parameter, then the parameter is
considered to implicitly have redefinitions sufficient to meet the stated requirements.
**actionaction defdef** A1 :> A {B1 :> B { **inin** aa; } // aa redefines A::a1, A::a2 is inherited.b1; **out** b2; **inout** b3); // Redefinitions are implicit.
**action def** C1 :> A1, B1 { **in** c1; **out** c2; **inout** c3; }
If an action usage has any type of specialization relationship (i.e., feature typing, subsetting or redefinition, implicit
or explicit) with an action definition or usage (or KerML behavior or step), the rules for the redefinition of the
parameters of the general definitions and usages are the same as given for the redefinition of parameters of an action
definition above.
**action** // Parameters redefine parameters of Focus.focus : Focus {
**inout** scene;image;
}
**action** refocus **subsets** focus; // Parameters are inherited.
Binding and flow connection usages (see7.13.3and8.4.9.6) can be used to connect subactions in the body of an
action definition or usage. In addition, the feature value shorthand for binding (see7.13.4) is often useful for action
parameters.

**98 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**actionin** providePower : ProvidePower {fuelCmd : FuelCmd;
**actionin** generatePower : GeneratePower {fuelCmd : FuelCmd = providePower::fuelCmd;
} **out** generatedTorque : Torque;
**flowto** transmitPower.generatedTorque;generatePower.generatedTorque
**actionin** transmitPower : TransmitPower {generatedTorque : Torque;
// ... **out** transmittedTorque;
}
The base action definition and usage areActionandactionsfrom theActionslibrary model (see9.2.9). (For
other semantic constraints on action usages, see8.4.12.)

**7.16.3Control Nodes**
A _control node_ is a special syntactic notation for an action usage whose definition is a concrete specialization of the
abstract action usageControlActionfrom theActionslibrary model (see9.2.9). A control node is declared like
a normal action usage (see7.16.2), but using one of the keywords shown inTable 15instead of thekeyword
**action**. A control node can only be declared in the body of an action definition or usage and implicitly subsets the
action usage shown in the table corresponding to its keyword, thereby inheriting the corresponding definition. A
control node is always composite, so the **ref** keyword is never used in a control node declaration. A control node
declaration can have a body, but only containing annotating elements related to it via annotation relationships (see
8.2.2.4.1).
**Table 15. Control Node Definitions
Keyword Subsetting Definition
merge** Actions::Action::merges Actions::MergeAction
**decide** Actions::Action::decisions Actions::DecisionAction
**join** Actions::Action::joins Actions::JoinAction
**fork** Actions::Action::forks Actions::ForkAction

Control nodes are used to control the sequencing of other action usages connected to them via sucessions. The
following rules apply to these connections.

1. Incoming successions to a **merge** node must have source multiplicity 0..1 and subset the
    incomingHBLinkfeature inherited byMergeActionfrom the Kernel Semantic Library Behavior
    ControlPerformances::MergePerformance(see [KerML, 9.2.9]).
2. Outgoing successions from a **decide** node must have target multiplicity 0..1 and subset the
    outgoingHBLinkfeature inherited from the Kernel Library Behavior
    ControlPerformances::DecisionPerformance(see [KerML, 9.2.9]).
3. Incoming successions to a **join** node must have source multiplicity 1..1.
4. Outgoing successions from a **fork** node must have target multiplicity 1..1.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 99**


These rules shall be enforced in the abstract syntax, even if not shown explicitly in the concrete syntax notation for a
model. (See also8.4.12.4on the semantic constraints related to control nodes.)
// Both action1 and action2 will proceed concurrently// after fork1.
**forkfirst** fork1;fork1 **then** action1;
**first** fork1 **then** action2;
**actionaction** action1;action2;
// join1 will be performed after both action1// and action2 have completed.
**firstfirst** action1action2 **thenthen** join1;join1;
**join** join1;
**first** join1 **then** decision1;
// One of action3 or action4 will be chosen// (non-deterministically) to be performed after decision1.
**decidefirst** decision1decision1; **then** action3;
**first** decision1 **then** action4;
**actionaction** action3;action4;
// merge1 will be performed after either action3// or action4 have completed.
**firstfirst** action3action4 **thenthen** merge1;merge1;
**merge** merge1;
**7.16.4Succession Shorthands**
The basic notation for successions (see7.13.5) may be used to specify the sequencing of action usages within the
body of an action definition or usage. There are also additional textual notation shorthands that may be used _only_
within the body of an action definition or usage, as described below. Further, every action inherits the features
startanddonefrom the base action definitionActions::Action, which represent the start and end snapshots of
the action.
The source of a succession may be specified separately from the target by using the keyword **first** followed by a
qualified name or feature chain for the source action usage. Similarly, the target of a succession may be specified
separately from the source by using the keyword **then** followed by a qualified name or feature chain for the target
action usage.
**firstthen** action2;action1;
// The above two declarations are together// equivalent to the following single succession.
**first** action1 **then** action2;
The **then** keyword may also be followed by a complete action usage declaration, rather than just the name.

**100 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
firstthenaction action1;action2;
// The above two declarations are together// equivalent to the following.
firstaction action1action2; then action2;
```
The **then** shorthand can be used lexically following any action usage, not just following a **first** declaration, with
the preceding action usage becoming the source of the succession. This is particularly useful when a sequence of
actions is to be performed successively or in a loop.
**firstthenmerge** start;loop;
**thenthenactionaction** initialize;monitor;
**thenthenaction** loop; finalize;

The source of a succession must be an occurrence usage. Therefore, the source of a succession represented using the
**then** shorthand is actually determined as the nearest occurrence lexically previous to the **then** , skipping over any
intervening non-occurrence usages (and conditional successions, see7.16.5. Since a succession is not an occurrence
usage, this allows several **then** successions to be placed in a sequence after a common source action usage. This is
particularly useful for specifying multiple successions outgoing from **fork** and **decide** nodes.
// The two successions following fork1 both have// fork1 as their source.
**forkthen** fork1;action1;
**then** action2;
**actionthen** action1;join1;
**actionthen** action2;join1;
**join** join1;
// The two successions following decision1 both have// decision1 as their source.
**then decidethen** action3;decision1;
**then** action4;
**actionthen** action3;merge1;
**actionthen** action4;merge1;
**merge** merge1;

**7.16.5Conditional Successions**
A succession within the body of an action definition or usage may be given a _guard_ condition. A guard is given as a
Boolean-valued expression preceded by the keyword **if.** It is placed in the declaration of the succession (see7.13.5)
after the specification of the source of the succession and before the specification of the target.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 101**


```
successionfirst initializeconditionalOnActive if isActive then monitor;
```
Such a conditional succession actually declares a special transition usage (see also7.17.3on transition usages in
state models), which is a kind of action usage defined by the action definitionDecisionTransitionActionfrom
theActionsmodel library (see9.2.9). The transition usage performs the evaluation of the guard expression and, if
true, asserts the existence of the succession. (See8.4.12.3on the semantic constraints related to decision transition
usages used for conditional successions.)
As usual, if the declaration part is empty, the keyword **succession** may be omitted. The source for the succession
may then be further omitted, in which case the source is identified from a lexically previous action usage, as for the
**then** shorthand described in7.16.4. Further, the keyword **else** may be used in place of a guard expression to
indicate a succession to be taken if the guards evaluate to false on all of an immediately preceding set of conditional
successions. However, the target of a conditional succession _must_ be specified as a qualified name or feature chain
and cannot be a full action usage declaration, even when the shorthand notation is used.
The conditional succession shorthand notation is particularly useful for notating several conditional successions
outgoing from a **decide** node.
**mergeaction** loop;checkLevel { **out** level; }
**decideif** ;level <= refillLevel **then** refill;
**ifelse** level >= maxLevelcontinue; **then** drain;
**actionthen** loop;refill;
**actionthen** loop;drain;
**action** continue;

**7.16.6Perform Action Usages**
A _perform action usage_ is declared as an action usage (see7.16.2) but using the kind keyword **perform action**
instead of just **action**. A perform action usage is a kind of event occurrence usage (see7.9.5) for which the event
occurrence is an action usage, known as the _performed action._ As for an event occurrence usage, the performed
action is related to the perform action usage by a _reference subsetting_ relationship, specified textually using the
keyword **references** or the symbol::>. Or, if the perform action usage has no such reference subsetting, then the
performed action is the perform action usage itself.
**partperform actiondef** Vehicle {powerVehicle **references** VehicleActions::providePower;
} **abstract perform action** moveVehicle; // Performed action is itself.
A perform action usage may also be declared using just the keyword **perform** instead of **perform action**. In this
case, the declaration does not include either a name or short name. Instead, the performed action of the perform
action usage is identified by giving a qualified name or feature chain immediately after the **perform** keyword.
**part** // The performed action is VehicleActions::move.vehicle : Vehicle {

**102 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


} **perform** VehicleActions::move :> Vehicle::moveVehicle;
If a perform action usage is used in the body of a part definition or usage, then the part is considered to be the
_performer_ of the performed action (see also8.4.12.10on the semantics of perform action usages). A perform action
usage may also be used in the body of another action definition or usage, in which case it acts like a referential "call"
of the performed action by the containing action.
**actionin** initialization { **item** device;
**performin** component = device;Utility::startUpCheck {
} **out** status;
} ...
The **ref** keyword may be used in the declaration of a performed action usage, but a perform action usage is always
referential, whether or not **ref** is included in its declaration.

**7.16.7Send Action Usages**
A _send action usage_ is declared as an action usage (see7.16.2) implicitly defined by the action definition
SendActionfrom theActionslibrary model (see9.2.9). ASendActionhas three input parameters:

1. a set of _payload_ values
2. a _sender_ occurrence
3. a _receiver_ occurrence
The behavior of aSendActionis to _transfer_ the payload from the sender to the receiver.
In the textual notation for a send action usage, values for the threeSendActionparameters are given after the
action declaration part, identified by the keywords **send** (payload), **via** (sender) and **to** (receiver). If the declaration
part is empty, then the **action** keyword may be omitted.
**partaction** monitor {sendReadingTo {
**inpart** destination;
**perform** getReading { **out** reading : SensorReading; }
// Send a reading from the monitor to the destination. **action** sendReading
**send** getReading.reading **via** monitor **to** destination;
// The following send action is equivalent to the// one above, but without a name.
} **send** getReading.reading **via** monitor **to** destination;
}
A send action usage can specify both a sender ( **via** ) and receiver ( **to** ), but it will generally give only one or the
other. When a send action usage is directly or indirectly a composite feature of a part definition or usage, then the
default for the sender ( **via** ) of the send action usage is the containing part, not the send action itself. This is known
as the default _sending context._

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 103**


**partaction** monitor {sendReadingTo {
**inpart** destination;
**perform** getReading { **out** reading : SensorReading; }
// The sender for the following send action is, by default,// the sending context, which is the part "monitor".
} **send** getReading.reading **to** destination;
}
If a send action usage is _not_ in the composition hierarchy of a part definition or usage (or any item definition or
usage), then the sending context is the highest-level containing action usage. Note that a perform action usage is
always referential, so that the sending context for subactions of a perform action usage is the perform action usage
itself, _not_ the containing performing part.
**partref part** monitor {destination;
**perform actionperform** getReading {sending { **out** reading : SensorReading; }
// The sender for the following send action is, by default,// the sending context, which is the action "sending",
// not the part "monitor". **send** getReading.reading **to** destination;
} }
When sending through a port (see7.12on ports), the port usage will usually be the sender ( **via** ), with the actual
receiver determined by interface connections having the port usage as their source (see7.14).
**part defport** MonitorDevice {readingPort;
**actionperform** monitoring {getReading { **out** reading : SensorReading; }
} **send** getReading.reading **via** readingPort;
}
A send action usage must be one of the following:

1. An owned feature of an action definition or usage.
2. The owned **entry** , **do** or **exit** action of a state definition or usage (see7.17).
3. The owned **effect** action of a transition usage (see7.17).
The base send action usage issendActionsfrom theActionslibrary model (see9.2.9), which is defined by
SendAction. (See8.4.12.5for additional semantic constraints on send action usages.)

**7.16.8Accept Action Usages**
An _accept action usage_ is declared as an action usage (see7.16.2) implicitly defined by the action definition
AcceptActionfrom theActionslibrary model (see9.2.9). AnAcceptActionhas two parameters:

1. an output parameter for a set of _payload_ values
2. an input parameter giving a _receiver_ occurrence

**104 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The behavior of anAcceptActionis to accept the _transfer_ of a payload received by the given receiver, and then
output that payload.
The textual notation for an accept action usage includes special notation for declaring a usage-specific payload
parameter and giving a value for the receiver parameter. The payload parameter declaration is identified by the
keyword **accept** , and the expression giving the transfer receiver is identified by the keyword **via**. If the action
declaration part is empty, then the **action** keyword may be omitted.
The payload parameter declaration for an accept action usage identifies the type of values accepted by the accept
action. It is declared as a reference usage (see7.6), but without the **ref** keyword or any body. If the payload
parameter declaration has the form of a single qualified name (and, optionally, a multiplicity), then the qualified
name is interpreted as the definition (type) of the payload parameter ( _not_ its name).
**partaction** controller {accepting {
// ... **action** acceptReading
**accept** reading : SensorReading **via** controller;
// The following accept action is equivalent to the// one above, but it does not name the accept action or
// the payload parameter. **accept** SensorReading **via** controller;

} // ...
}
A payload parameter declaration can also include a feature value (see7.13.4). In this case, the accept action usage
will only accept exactly the value that is the result of the feature value expression. The following special notations
can also be used for the feature value of a payload parameter:

- _Change trigger._ A change trigger is notated using the keyword **when** followed by an expression whose
    result must be aBooleanvalue. A change trigger evaluates to aChangeSignal(as defined in the
    Observationmodel from the Kernel Semantic Library Library [KerML, 9.2.13]) that is sent when the
    result of the given expression changes fromfalsetotrue(or sent immediately if the expression istrue
    when first evaluated).
- _Absolute time trigger._ An absolute time trigger is notated using the keyword **at** followed by an expression
    whose result must be aTimeInstantValue(see9.8.8). An absolute time trigger evaluates to a
    TimeSignal(as defined in theTriggermodel from the Kernel Semantic Library Library [KerML,
    9.2.14]) that is sent when the current time (relative to thedefaultClock, see9.8.8) reaches the
    TimeInstantValuethat is the result of the given expression.
- _Relative time trigger._ A relative time trigger is notated using the keyword **after** followed by an
    Expression whose result must be aDurationValue(see9.8.8). A relative time trigger evaluates to a
    TimeSignal(as defined in theTriggermodel from the Kernel Semantic Library Library [KerML,
    9.2.14]) that is sent when the current time (relative to thedefaultClock, see9.8.8) reaches the
    TimeInstantValuethat is computed as the result of the given expression added to the time at which the
    time trigger is evaluated.
**partin** controller {level : Real;
**attribute** threshold : Real;
**action** // Both of the following accept actions trigger (once) when the{

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 105**


// given expression becomes true. **accept** : ChangeSignal = Triggers::triggerWhen({ level > threshold });
**accept when** level > threshold;
// The following accept action triggers at the given date and time. **accept at** Iso8601DateTime("2024-02-01T00:00:00Z");
// The following accept action triggers 30 seconds after the evaluation// of its time trigger.
} **accept after** 30 [s];
}
When an accept action usage is directly or indirectly a composite feature of a part definition or usage, then the
default for the receiver ( **via** ) of the accept action usage is the containing part, not the accept action itself. This is
known as the default _accepting context._
**partaction** controller {accepting {
// The receiver for the following accept action is, by default,// the accepting context, which is the part "controller".
**accept** SensorReading;
} // ...
}
If an accept action usage is _not_ in the composition hierarchy of a part definition or usage (or any item definition or
usage), then the accepting context is the highest-level containing action usage. Note that a perform action usage is
always referential, so that the accepting context for subactions of a perform action usage is the perform action usage
itself, _not_ the containing performing part.
**partperform action** controller { accepting {
// The receiver for the following accept action is, by default,// the accepting context, which is the "accepting" action,
// not the part "controller". **accept** reading : SensorReading;

} // ...
}
When accepting through a port (see7.12on ports), the port usage is the receiver ( **via** ).
**part defport** ControllerDevice {sensorPort;
**actionaccept** control {reading : SensorReading **via** sensorPort;
} }
An accept action usage must be one of the following:

1. An owned feature of an action definition or usage.
2. The owned **entry** , **do** or **exit** action of a state definition or usage (see7.17).
3. The owned **effect** action or **accept** action of a transition usage (see7.17).

**106 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The base accept action usage isacceptActionsfrom theActionslibrary model (see9.2.9), which is defined by
AcceptAction. (See8.4.12.6for additional semantic constraints on accept action usages.)

**7.16.9Assignment Action Usages**
An _assignment action usage_ is declared as an action usage (see7.16.2) that is implicitly defined by the action
definitionAssignmentActionfrom theActionsmodel (see9.2.9). AnAssignmentActionsets a _referent_
feature of a _target_ occurrence to a new _assigned value_. In the textual notation for an assignment action usage, these
three things are specified in an _assignment part_ between the usual action declaration part and the action body (if
any). An assignment part consists of the keyword **assign** followed by an expression that evaluates to the target and
a feature chain identifying the referent, separated by a dot (.), followed by the symbol:=and an expression whose
result is the assigned value. If the declaration part is empty, then the **action** keyword may be omitted.
**actionindefpart** UpdateVehiclePosition {sim : Simulation;
**inattribute** deltaT : TimeDurationValue;
// The target of the assignment below is "sim".// The referent feature chain is "vehicle.position".
**assign** sim.vehicle.position + sim.vehicle.velocity * deltaT;sim.vehicle.position :=
// After the above assignment "sim.vehicle.position" has the// value of the result of the assigned value expression,
} // evaluated at the time of the assignment.
**actionindefitem** RecordNames {record : Record;
**initem** entries : Entry[1..*];
// "entries.name" evaluates to the names of all entries.// These values are assigned to the "names" feature of "record".
} **assign** record.names := entries.name;
If the target expression of an assignment action usage is omitted, then the target is implicitly the occurrence owning
the assignment action usage.
**action** // This attribute is initialized using a feature value.counter {
**attribute** count : Natural := 0;
// The target of the following assign action usage is// implicitly the action "counter".
**assign** // ...count := count + 1;
}
Every assignment action usage must be one of the following:

1. An owned feature of an action definition or usage.
2. The owned **entry** , **do** or **exit** action of a state definition or usage (see7.17).
3. The owned **effect** of a transition usage (see7.17).
The base assignment action usage isassignmentActionsfrom theActionslibrary model (see9.2.9). (See
8.4.12.7for other semantic constraints on assignment action usages.)

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 107**


**7.16.10If Action Usages**
An _if action usage_ is an action usage that is implicitly defined by one of the action definitionsIfThenActionor
IfThenElseActionfrom theActionsmodel (see9.2.9). In the textual notation, an if action usage can have a
typical action declaration (see7.16.2), but _without_ the usual action body. Instead, the action declaration part is
followed by the keyword **if** , which introduces a Boolean-valued _condition expression,_ followed by a _then clause_
and, for anIfThenElseAction, the keyword **else** and an _else clause._ The behavior of an if action usage is to first
evaluate the condition expression. If the result is true, then the then-clause is performed, otherwise the else-clause is
performed, if there is one.
Each of the then-clause and the else-clause is itself notated as an action usage, but with the body required to be
given using curly braces{...}, with a semicolon not allowed for an empty body.
**actionaction** testincrease : IncreaseSpeed { } **if** speed < lowerLimit
**elseaction** main : MaintainSpeed { }

If the if action usage does not include a declaration part, the leading **action** keyword can be omitted. If either or
both of the clauses have no declaration part, then the **action** keyword can be omitted for them, too, leaving only
their bodies surrounded by curly braces.
**if** selectedSensor != **assign** reading := selectedSensor.reading; **null** {
} **elseassign** { reading := undefinedValue;
}
With one except, only the basic form of action declaration can be used for the clauses of an if action usage, not the
special notations for perform action usages, send action usages, etc. The except is that, if the else-clause is itself an
if action usage, then the special if action usage notation can be used. This allows for a typical "else if" structure for
expressing the performance of a sequence of multiple tests.
**if** threat.level == high **action** soundAlarm(threat); **then** {
} **elseactionif** threat.level == mediumsendNotification(threat); **then** {
} **elseaction** { beginMonitoring(threat);
}

**7.16.11Loop Action Usages**
A _loop action usage_ is an action usage that is implicitly defined by one of the concrete specializations of the abstract
action definitionLoopActionfrom theActionsmodel (see9.2.9). There are two forms of loop action usages, the
_while loop action usage_ and the _for loop action usage._ In the textual notation, both kinds of loop action can have a
typical action declaration (see7.16.2), but _without_ the usual action body. Instead, the body is replaced with special
notations specific to each kind ofLoopAction.
**While Loops**
A while loop action usage is implicitly defined by theWhileLoopActionspecialization ofLoopAction. For a
while loop action usage, the action declaration part is followed by the keyword **while** , which introduces a Boolean-
valued _while expression,_ followed by a _body clause,_ and then, optionally, the keyword **until** , which introduces a

**108 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Boolean-valued _until expression_ terminated with a semicolon. The behavior of the while loop action usage is to
repeatedly perform the body clause as long as the while expression evaluates to true and the until expression (if there
is one) evaluates to false. The while expression is evaluated before the first iteration of the body clause, but the until
expression is not evaluated for the first time until after the first iteration of the body clause (if the while expression
evaluates to true).
Similarly to the then and else clauses of an if action usage (see7.16.10), the body clause is itself notated as an action
usage, but with its body required to be given using curly braces{...}, with a semicolon not allowed for an empty
body.
**actionaction** advancestep { **while** t < endTime
**perform** :>> stateVector = systemState;advanceState {
} :>> deltaT = dt;
} **untilthen assign** stateVector.position >= endPosition;t := t + dt;
The **action** keyword can be omitted for the while loop action usage itself and/or for the body clause, if they have
no action declaration part.
**whileassignnot** ready {ready := poll(device);
}
The keyword **loop** may be used as a shorthand for **while** true. This is useful for a while loop that is designed to
be non-terminating or will be terminated with just an until expression.
**loopassign** { charge := MonitorBattery();
**thenactionif** charge < 100 {AddCharge;
} **until** } charge >= 100;
**For Loops**
A for loop action usage is implicitly defined by theForLoopActionspecialization ofLoopAction. For a for loop
action usage, the action declaration part is followed by the keyword **for** , which introduces a _loop variable
declaration_ followed by the keyword **in** and a _sequence expression,_ and, after that, a _body clause._ The behavior of
the for loop action usage is to first evaluate the sequence expression, which should result in a sequence of values.
The body clause is then performed iteratively, with the loop variable assigned to each value sequentially for each
iteration.
As for a while loop action usage, the body clause is itself notated as an action usage, but with its body required to be
given using curly braces{...}, with a semicolon not allowed for an empty body.
**actionfor** dynamicScenariopower : PowerValue **in** powerProfile
**actionassign** dynamicsStep {position := ComputeDynamics(position, power);
}
The **action** keyword can be omitted for the for loop action usage itself and/or for the body clause, if they have no
action declaration part.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 109**


**for** power : PowerValue **assign** position := ComputeDynamics(position, power); **in** powerProfile {
}
The..operator can be used to construct a sequence of Integer values between two bounds (inclusive), which can be
useful as the sequence expression of a for loop (especially for indexing).
**for** i **assignin** 1..scenario->size() {positionList :=
**assign** positionList->including(scenario.postion#(i));velocityList :=
} velocityList->including(scenario.velocity#(i));

**7.17States
7.17.1States Overview**
_Metamodel references:_

- _Textual notation,8.2.2.17_
- _Graphical notation,8.2.3.17_
- _Abstract syntax,8.3.17_
- _Semantics,_ 8.4.13
**States**
A _state definition_ isa kind of action definition (see7.16) thatdefines the conditions under which other actions can
execute.A state usage is a usage of a state definition. State definitions and usages are used to describestate-based
behavior,where the execution of any particular state is triggered by events.
A state definition or usage can contain specially identified action usages that are only performed whilethe state is
activated.
- An _entryaction_ starts when the state is activated.
- A _do action_ starts after the entry action completes and continues while the state is active.
- An _exit action_ starts when the state is exited, and the state becomes inactive once the exit action is
completed.
State definitions and usages follow the same patterns that apply to structural elements (see7.6). States can be
decomposed into lower-level states to create a hierarchy of state usages, and states can be referenced by other states.
In addition, a state definition can be specialized, and a state usage can be subsetted and redefined. This provides
enhanced flexibility to modify a state hierarchyto adapt to its context.
**Exhibited States**
A state usage can be a feature of apart definition or a part usage, which can exhibit a state by referencingthestate
usageor by containingan owned state usage. Whether owned or referenced, the state usage that the part exhibits
can represent a top state in a hierarchy of state usages.
An _exhibit state usage_ is a state usage that specifies that a state is exhibited by the owner of the exhibit state usage.
An exhibit state usage is referential, which allows the exhibited state behavior to be defined in a different context
than that of the exhibitor (perhaps by a state usage in a state decomposition hierarchy). However, if the owner of the
exhibit state usage is an occurrence, then the referenced state performance must be carried out entirely within the
lifetime of the performing occurrence.

**110 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


In particular, an exhibit state usage can be a feature of a part definition or usage, specifying that the referenced state
is exhibited by the containing part. Typically, the exhibited state and its substates will reflect conditions of the
exhibiting part, such as the operating states of a vehicle. The values of the exhibit state usage are then references to
occurrences of the state when the exhibiting part is "in" that state.
**Transitions**
State usages can be connected by _transition usages_ , which can activate and deactivate the state usages. The
triggering of a transition usage from its source state usage to its target state usage deactivates the source state and
activates the target state. The trigger of a transition usage is an accept action usage (see7.16), which accepts an
incoming transfer. The transition usage can contain a _guard condition_ , which is a Boolean expression (see7.18) that
must evaluatetotruefor the transition to occur. In addition, a transition usage may specify an _effect action usage_
that starts if the transition is triggered, after the source state is deactivated, and must complete before the target state
is activated. If the triggering transfer of a transition has a payload, then this payload is available for use in the guard
condition and effect action of the transition, and after the transition completes.
**Parallel State** **_s_**
A _parallel state_ is one whose substates are performed concurrently. As such, no transitions are allowed between the
substates of a parallel state. In contrast, if a non-parallel state has substates then, exactly one of the substates shall be
active at any point in time in the lifetime of the containing state after completion of the entry action (if any).
**Table 16. States – Representative Notation
Element Graphical Notation Textual Notation**

```
State Definition
```
```
state def StateDef1;
state def /* members */StateDef1 {
}
```
```
State
```
```
state StateDef1;state1 :
state StateDef1 {state1 :
}/* members */
```
```
State with entry, do
and exit actions.
```
```
stateentry state1 {actio1;
doexit action2;action3;
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 111**


```
Element Graphical Notation Textual Notation
```
```
State with Graphical
Compartment with
standard state
transition view
(sequential states)
```
```
stateentry compositeState1 {; then state1;
statetransition state1;
firstaccept state1trigger1
ifdo guard1action1
statethen state2;state2;
} then done;
```
```
State with Graphical
Compartment with
standard state
transition view
(parallel states)
```
```
stateparallel compositeState2{
stateentry state1 {; then
'state1.1'; state 'state1.1';
} state state2 {
'state2.1'; entry ; then
} state 'state2.1';
}
```
```
Transition
```
```
statestate state1 : State1;state2 : State2;
transitionfirst state1
acceptif guard1trigger1
dothen action1state2;
or
stateaccept state1 : State1;trigger1
ifdo guard1action1
statethen state2 : State2;state2;
```
**112 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Exhibit
```
```
partexhibit part1 : Part1 {state1;
}
```
```
Exhibit State
```
```
partexhibit state part1 : Part1 {state1
: State1; }
```
```
States Compartment
```
```
{ state state1 :
StateDef [1..*] ordered nonunique ;
/* ... */ exhibit state
state10; state state11 {
statestate 'state11.1';'state11.2';
} }
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 113**


```
Element Graphical Notation Textual Notation
```
```
Exhibit States
Compartment
```
```
{ exhibit state state1
: StateDef [1..*]
/* ... */ ordered nonunique;
}
```
```
Exhibited By
Compartment No textual notation
```
**7.17.2State Definitions and Usages**
A state definition or usage is declared as an action definition or usage (see7.16.2), but using the keyword **state**
instead of **action**. In addition, entry, do and exit actions can be declared (at most one of each) in the body of a state
definition or usage, using the keywords **entry action** , **do action** , and **exit action** , followed by an action
declaration and body, in the usual form.
**state defentry action** Exercising {warmup : WarmUp;
**doactionaction** exercise : Exercise {strengthTraining;
} **then action** cardioTraining;
} **exit action** cooldown : Cooldown;
In addition to the generic **action** notation as above, the special notations for send action usages (see7.16.7), accept
action usages (see7.16.8), and assignment action usages (see7.16.9) can be used for entry, do, and exit actions.
**state defentry assign** Operating {stateCode := StateCodes::Operating;
} **dosend** ReadySignal() **to** Controller;

**114 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The **entry** , **do** , and **exit** keywords can also be used without any **action** keyword. If the keyword is immediately
followed by a semicolon;, then they are empty actions. If they are followed by a qualified name or feature chain for
an action usage, then this is a shorthand for relating the entry, do, or exit action to the identified action usage via
_reference subsetting_ (see also7.13.2).
**actionstate def** monitorTemperature;TurnedOn {
// This is an empty entry action. **entry** ;
// The following is equivalent to// **doaction references** monitorTemperature;
} **do** monitorTemperature;
A state definition or usage may hierarchically contain state usages in its body. By default, these substate usages are
considered to be _exclusive,_ that is, their performances do not overlap in time. However, if the keyword **parallel** is
added to a state definition or usage, just before the body part, then the containing state definition or usage becomes a
parallel state, and its contained state usages can be performed in parallel. (However, no transitions are allowed
between concurrent states; see7.17.3.)
**state def** // These substates are performed concurrently.VehicleStates **parallel** {
**statestate** OperationalStates;HealhStates;
}
The base state definition and usage areStateandstatesfrom theStateslibrary model (see7.17). (For other
semantic constraints on state usages, see8.4.13.)

**7.17.3Transition Usages**
A transition usage is also a kind of action usage (see7.16.2) that can be used within non-parallel states. (A parallel
state with concurrent substates is not allowed to have transitions to or from its substates.) A transition usage is
implicitly defined by the action definitionStateTransitionActionfrom theStateslibrary model (see7.17). A
transition usage also relates a _source_ state usage to a _target_ state usage, declaring that it is possible to transition from
a performance of the source state to a new performance of the target state.
In addition, a transition usage can have an entry or exit action as a source or target. Indeed, for a non-parallel state
definition or usage with nested state usages, the initial state usage is indicated by a transition from the entry action to
that state usage, representing that this is the state that is entered on completion of the entry action.
A transition usage is identified with the keyword **transition**. The source and target states are identified using the
same keywords as for a succession (see7.13.5), **first** and **then**.
**stateentry actiondef** OnOff1 {init;
**transitionfirst** init **then** off;
**statestate** off;on;
**transitiontransition** off_onon_off **firstfirst** offon **thenthen** off;on;
}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 115**


A transition usage can also have a Boolean-valued guard expression. The guard expression is evaluated during the
performance of thesource, and the transition usage is only enabled to possibly cause a transition out of the source
state when the guard evaluates to true. In the textual notation, the guard expression is given after the keyword **if** ,
between the source and target parts.
**stateindefattribute** OnOff2 {isInitOff;
**in attribute** isEnabled;
**entry actiontransitionfirst** init;init **if** isInitOff **then** off;
**transitionfirst** init **if not** isInitOff **then** on;
**statestate** off;on;
**transitiontransition** off_onon_off **firstfirst** offon **ifif** isEnabledisEnabled **thenthen** off;on;
}
A transition usage can also have an _accepter,_ which is an accept action usage use to trigger the transition. The
accepter action for a transition usage is placed after the guard expression and notated using the **accept** keyword,
with its payload and receiver parameters specified exactly as discussed in7.16.8. Transition usages from the entry
action are not allowed to have accepters.
**item defstatedef** TurnOn;OnOff3 {
**inin attributeattribute** isInitOff;isEnabled;
**port** commPort;
**entry actiontransitionfirst** init;init **if** isInitOff **then** off;
**transitionfirst** init **if not** isInitOff **then** on;
**statestate** off;on;
**transitionfirst** offoff_on
**ifaccept** isEnabledTurnOn **via** commPort
**transitionthen** on;on_off
**firstif** isEnabledon
**acceptthen** off; **after** 5[min]
}
Finally, a transition usage can have an _effect action_ ,which is an action usage that is performed if the transition usage
is triggered. An effect action is notated using the keyword **do** in the same way as a do action on a state definition or
usage (see7.17.2). In the textual notation for a transition usage, it is also placed between the source and target parts,
after the guard and accepter (if the transition usage has those).
**action defitem def** TimeoutSignal;PowerUp;

**116 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**stateindefattribute** OnOff4 {isInitOff;
**in attribute** isEnabled;
**port** commPort;
**entry actiontransitionfirst** init;init **if** isInitOff **then** off;
**transitionfirst** init **if not** isInitOff **then** on;
**statestate** off;on;
**transitionfirst** offoff_on
**ifaccept** isEnabledTurnOn **via** commPort
**do actionthen** on; powerUp : PowerUp;
**transitionfirst** onon_off
**ifaccept** isEnabled **after** 5[min]
**dothensend** off;TimeoutSignal() **via** commPort
}
In the textual notation, there is also a shorthand for a transition usage without a declaration part, in which both the
**transition** keyword _and_ the source part can be omitted. In this case, the source is taken to be the closest lexically
previous state usage, which means the transition usages out of a certain state usage need to be placed essentially
immediately after their source states. This notation can also be used when the transition source is the entry action,
which is particularly useful, because it means the entry action does not need to be named.
**stateindefattribute** OnOff5 {isInitOff;
**in attribute** isEnabled;
**port** commPort;
**entryif** ;isInitOff **then** off;
**ifnot** isInitOff **then** on;
**stateif** off;isEnabled
**acceptdo action** TurnOnpowerUp : PowerUp; **via** commPort
**then** on;
**stateif** on;isEnabled
**acceptdosendafter** TimeoutSignal()5[min] **via** commPort
} **then** off;
In summary, the guard and accepter of a transition action usage determine whether a transition usage is triggered:

1. A transition usage can only be triggered during a performance of its source.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 117**


2. If a transition usage has a guard expression, it can only be triggered if the guard expression evaluates to
    true.
3. If a transition has an accepter, and it meets the above conditions, then it is triggered if the accepter can
    accept in incoming transfer via its receiver parameter, in which case the accepter is performed as described
    in7.16.8(see also8.4.12.6).
If a transition usage is triggered, then it establishes a succession relationship between the source performance and a
new performance of the target, and a transition is performed as follows:
1. If the source state has a do action that is still being performed, that is interrupted.
2. Then, if the source state has an exit action, that is performed.
3. Once that completes, if the transition usage has an effect action, that is performed.
4. Once that completes, if the target state has an entry action, that is performed.
5. Once that completes, if the target state has a do action, that is performed.

**7.17.4Exhibit State Usages**
An _exhibit state usage_ is declared as a state usage (see7.17.2) but using the kind keyword **exhibit state** instead
of just **state**. An exhibit state usage is a kind of perform action usage (see7.16.6) for which the action usage is a
state usage, known as the _exhibited state._ As for a perform action usage, the exhibited state is related to the exhibit
state usage by a _reference subsetting_ relationship, specified textually using the keyword **references** or the symbol
::>. Or, if the exhibit state usage has no such reference subsetting, then the exhibited state is the exhibit state usage
itself.
**partexhibit statedef** Vehicle {operatingState **references** VehicleStates::operating;
} **abstract exhibit state** monitoringState; // Exhibited state is itself.
An exhibit state usage may also be declared using just the keyword **exhibit** instead of **exhibit state**. In this
case, the declaration does not include either a name or short name. Instead, the exhibited state of the exhibit state
usage is identified by giving a qualified name or feature chain immediately after the **exhibit** keyword.
**part** // The exhibited state is VehicleActions::monitoring.vehicle : Vehicle {
} **exhibit** VehicleStates::monitoring :> Vehicle::monitoringState;
If an exhibit state usage is used in the body of a part definition or usage, then the part is considered to be the
_performer_ of the exhibit state usage (see also8.4.13.4on the semantics of exhibit state usages). The **ref** keyword
may be used in the declaration of a exhibit state usage, but a exhibit state usage is always referential, whether or not
**ref** is included in its declaration.

**7.18Calculations
7.18.1Calculations Overview**
_Metamodel references:_

- _Textual notation,8.2.2.18_
- _Graphical notation,8.2.3.18_
- _Abstract syntax,8.3.18_
- _Semantics,8.4.14_

**118 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


A _calculation definition_ is a kind of action definition (see7.16) that has a distinguished parameter with direction
**out** called the _result_ parameter (which is usually the only **out** parameter). A calculation definition specifies a
reusable computation that returns a result in the result parameter. A _calculation usage_ is an action usage that is a
usage of a calculation definition.
In addition to its parameters, a calculation definition or usage may have features that are calculation or action usages
that carry out steps in the computation of the result of the calculation. The calculation may also have other features
that are used to record intermediate results in the computation. The final result is specified as an _expression_ written
in terms of the input parameters of the calculation and any intermediate results.
KerML includes extensive syntax for constructing expressions, including traditional operator notations for functions
in the Kernel Function Library, which is adopted in its entirety into SysML. In addition, a calculation definition is
also a KerML function, and a calculation usage is itself a KerML expression. This allows a calculation definition or
usage to also be invoked using the notation of a KerML invocation expression. (See the KerML Specification
[KerML, 7.4.9] for a complete description of the KerML expression sublanguage.)
Calculation definitions are often used to definemathematical functions, in which case the defined computation
should be _pure_. A pure calculation has the following properties:

1. Two invocations of the calculation definition with the same values for the input parameters always
    produce the same values for the result parameter.
2. The performance of the calculation does not produce any side effects (that is, it does not effect any
    occurrence that is not a composite part of its performance or that of a subaction or subcalculation).
Any subcalculations or subactions of a pure calculation must also be pure, including the final expression computing
the result. Further, the inputs of a pure calculation should either be attributes or the calculation should not rely on
features of input occurrences that may change from one invocation of the calculation definition to another.
**Table 17. Calculations – Representative Notation
Element Graphical Notation Textual Notation**

```
Calc Definition
```
```
calc def expression1CalcDef1 {
}
calc def /* members */CalcDef1 {
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 119**


```
Element Graphical Notation Textual Notation
```
```
Calc
```
```
calc expression1calc1 : CalcDef1 {
}
calc /* members */calc1 : CalcDef1 {
}
```
**7.18.2Calculation Definitions and Usages**
A calculation definition or usage is declared as an action definition or usage (see7.16.2), but using the keyword
**calc** instead of **action**. As for an action definition or usage, directed usages declared in the body of a calculation
definition or usage are consider to be parameters. In addition, the result parameter for a calculation definition or
usage can be declared as an out parameter using the keyword **return** instead of **out**. Note that a calculation
definition or usage always has a result parameter, inherited if not owned.
**calc defin** v_i : VelocityValue;Velocity {
**inin** a : AccelerationValue;dt : TimeValue;
} **return** v_f : VelocityValue;
If a calculation definition has superclassification relationships (implicit or explicit) with action definitions (or
KerML behaviors), then the rules for the redefinition of the non-result parameters of the calculation definition are
the same as for an action definition (see7.16.2). In addition, if a calculation definition specializes other calculation
definitions (or KerML functions), then its result parameter redefines the results parameters of the calculation
definitions it specializes, regardless of the positions of those parameters.
**calc defin** initialState : DynamicState;Dynamics {
**inreturn** time : TimeValue;: DynamicState;
} **calc def** VehicleDynamics **specializes** Dynamics {
// Each parameter redefines the corresponding parameter of Dynamics **in** initialState : VehicleState;
**inreturn** time : TimeValue;: VehicleState;
}
If a calculation usage has any type of specialization relationship (i.e., feature typing, subsetting or redefinition,
implicit or explicit) with an action definition or usage (or KerML behavior or step), the rules for the redefinition of
the parameters of the general definitions and usages are the same as given for the redefinition of parameters of a
calculation definition above.
**calc** // Parameters redefine parameters of Dynamics.computation : Dynamics {

**120 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**inin** initialState;time;
} **return** result;
**calc** // Input parameters are inherited, result is redefined.vehicleComputation **subsets** computation {
} **return** : VehicleState;
The body of a calculation definition or usage is like the body of an action definition or usage (see7.16.2), with the
optional addition of the declaration of a result expression at the end, using the expression sublanguage from
[KerML, 7.4.9]. The result of the result expression is implicitly bound to the result parameter of the containing
calculation definition or usage..
**calc defin** scores[1..*] : Rational;Average {
**return** : Rational;
} sum(scores) / size(scores)
**Note.** A result expression is written _without_ a final semicolon.
The result of a calculation definition or usage can also be explicitly bound, particularly using a feature value on the
result parameter declaration (see7.13.4). In this case, the body of the calculation definition or usage should _not_
include a result expression.
**calc defin** scores[1..*] : Rational;Average {
} **return** : Rational = sum(scores) / size(scores);
The base calculation definition and usage areCalculationandcalculationsfrom theCalculationslibrary
model (see7.18).

**7.19Constraints
7.19.1Constraints Overview**
_Metamodel references:_

- _Textual notation,8.2.2.19_
- _Graphical notation,8.2.3.19_
- _Abstract syntax,8.3.19_
- _Semantics,8.4.15_
**Constraint Definition and Usage**
A _constraint definition_ is a kind of occurrence definition (see7.9) that defines a logical predicate. Similar to a
calculation definition (see7.18), a constraint definition may have parameters with direction **in**. A constraint always
has an implicit Boolean-value result parameter with direction **out**. A constraint usage is an occurrence usage that is
the usage of a constraint definition.
Also similarly to a calculation, a constraint definition or usage may have features that are calculation or action
usages that carry out steps in the computation of the result of the calculation. The constraint may also have other
features that are used to record intermediate results in the computation. The final result is specified as an expression

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 121**


written in terms of the input parameters of the calculation and any intermediate results. In addition, a constraint
definition is also a KerML predicate and a constraint usage is a KerML Boolean expression, which allows a
constraint definition or usage to also be invoked using the notation of a KerML invocation expression.
For a given set of input parameter values, a constraint usage is _satisfied_ if its expression evaluates totrueand is
_violated_ otherwise. The parameters of a constraint usage may be bound to specific features whose values can be
constrained by the constraint expression. For the constraint expression{x < y}, the constraint usage may bindxto
the diameter of a bolt and bind _y_ to the diameter of a hole that the bolt must fit into. This constraint can then be
evaluated to betrueorfalse. E.g., ifxis 3 andyis 5 , then the expressionx < yevaluates to true, and the
constraint is satisfied_._ In the general case, the expression used to define a constraint can be arbitrarily complicated,
as long as the overall expression returns a Boolean value.
A constraint usage that is a feature of another definition or usage may also directly reference features of its
containing context, in which case it may be used to effectively constrain the values of those features. In a context
with the featuresbolt diameterandhole diameter, a constraint usage may be defined directly without
parameters using the expression{'bolt diameter' < 'hole diameter'}.
**Asserted Constraints**
In general, a constraint may be satisfied sometimes and violated other times. However, an _assert constraint usage_
asserts that the result of a given constraint must be alwaystrueat all times. If, at some point in time, it can be
determined that an assert constraint usage evaluates to other than its asserted value, this would be a logical
inconsistency in the model. Constraints associated with the laws of physics, for example, should be asserted to be
true, because they cannot be violated in any valid model of the real world. However, a constraint can also be
asserted simply if its satisfaction is expected to be implied within a model. That way, if the constraint is violated,
this can be flagged by tooling as needing resolution.
An assert constraint usage can also be _negated,_ which means that the given constraint is asserted to befalserather
thantrue. A negated assert constraint usage can be used to assert that some condition must never happen if the
model is logically consistent.
**Table 18. Constraints – Representative Notation
Element Graphical Notation Textual Notation**

```
Constraint Definition
```
```
constraint def ConstraintDef1;
constraint def ConstraintDef1 {
}/* members */
```
```
Constraint
```
```
constraint : ConstraintDef1;constraint1
constraint : ConstraintDef1 {constraint1
}/* members */
```
**122 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Constraints
Compartment
```
```
{ constraint
constraint1 :ConstraintDef1
[1..*] ordered nonunique ;
/* ... */ assert constraint
constraint10; constraint
{boolean_expression1}}
```
```
Assert Constraints
Compartment
```
```
{ assert constraint
constraint1 :ConstraintDef1
[1..*] ordered nonunique;
assert /* ... */
constraint {boolean_expression1}
}
```
**7.19.2Constraint Definitions and Usages**
A constraint definition or usage can be declared as a kind of occurrence definition or usage (see7.9.2), using the
kind keyword **constraint**. A constraint usage must be defined by a single constraint definition or a KerML
predicate (see [KerML, 7.4.8]).
Constraint definitions and usages are not calculation definitions and usages, but, like calculation definitions and
usages, they are kinds of KerML functions and expressions (a predicate is a kind of function). As such, any directed
usages declared in the body of a calculation definition or usage are considered to be owned parameters of the
calculation. Furthermore, every constraint definition and usage has a result parameter, but, since this must have a
Boolean type, it is generally not necessary to redeclare it for a constraint definition or usage.
The body of a constraint definition or usage is also like the body of a calculation definition or usage (see7.18.2),
including the addition of the declaration of a result expression at the end, using the expression sublanguage from
[KerML, 7.4.9]. For a constraint definition or usage, the result expression must be Boolean valued.
**constraint defin** tank : FuelTank;IsFull {
tank.fuelLevel == tank.maxFuelLevel // Result expression

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 123**


} **part def** Vehicle {
**partconstraint** fuelTank : FuelTank;isFull : IsFull {
} **in** tank = fuelTank;
}
The base constraint definition and usage areConstraintandconstraintsfrom theConstraintsmodel library
(see7.19)

**7.19.3Assert Constraint Usages**
An assert constraint usage is declared like a regular constraint usage (see8.4.15.2), except using the kind keyword
**assert constraint** instead of just **constraint**. By default, an assert constraint usage asserts that it must
evaluate to true at all times. However, an assert constraint usage may be _negated_ by inserting the keyword **not**
between **assert** and **constraint** , in which case the assertion is that the assert constraint usage evaluates to _false_
at all times.
**partattribute** testObject {computedMass : MassValue;
**assert constraint** // Alternatively, the following is equivalent.{ computedMass >= 0[kg] }
} **assert not constraint** { computedMass < 0[kg] }
An assert constraint usage may also be declared using just the keyword **assert** instead of **assert constraint**.
In this case, the declaration does not include either a name or short name for the assert constraint usage. Instead, the
constraint to be asserted is identified by giving a qualified name or feature chain immediately after the **assert**
keyword, and it is then related to the assert constraint usage by a _reference subsetting relationship_ (see also8.4.5.3).
A negated assert constraint usage of this form can be constructed using **assertnot**.
**constraintattribute** negativeMass {mass : MassValue;
} mass < 0[kg]
**partattribute** testObject {computedMass : MassValue;
// The following is equivalent to// **assert not constraint references** negativeMass { ... }
**assert** :>> mass = computedMass; **not** negativeMass {
} }
**partattribute** alienObject {antiMass : MassValue;
// The following is equivalent to// **assert constraint references** negativeMass { ... }
**assert** :>> mass = computeMass;nonNegativeMass {
} }

**7.20Requirements**

**124 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**7.20.1Requirements Overview**
_Metamodel references:_

- _Textual notation,8.2.2.20_
- _Graphical notation,8.2.3.20_
- _Abstract syntax,8.3.20_
- _Semantics,8.4.16_
**Requirements**
A _requirement definition_ is a kind of constraint definition (see7.19) that specifiesstakeholder-imposed constraints
that a design solution must satisfy to be a valid solution. A requirement definition contains one or more features that
are constraint usages designated as the _required constraints._ These may be specified informally using text
statements (commonly known as "shall" statements) or more formally using constraint expressions. A requirement
definition may also optionally include _assumed constraints._ The required constraints of a requirement only apply if
all the assumed constraints are satisfied.
A _requirement usage_ is a kind of constraint usage (see7.19) that is a usage of a requirement definition in some
context. The context for multiple requirements can be provided by a package (see7.5), a part (see7.11) or another
requirement. A design solution must satisfy therequirementand all of its member requirements and constraints to be
a valid solution.
A requirement definition or usage may be decomposed into nested requirement usages, which may themselves be
further decomposed. Since a requirement usage is a kind of constraint usage, any nested composite requirement
usage is automatically considered to be a required constraint of the containing requirement definition or usage. A
requirement definition or usage may also reference another requirement usage as a required constraint. For the
overall requirement to then be satisfied, all such composite or referenced requirements must be satisfied.
Like any usage element, the features of a requirement usage can redefine the features of its requirement definition.
For example, a requirement definitionMaximumMassmay include the require constraint{massActual <=
massRequired}, written in terms of the attribute usagesmassActualandmassRequired. A requirement usage
maximumVehicleMassdefined byMaximumMasscould restrict the subject of the requirement to be aVehicle,
redefine themassActualattribute to be themassof the subjectVehicle, and redefine themassRequired
attribute and bind it to 2000 kilograms. In this way, the requirement definition serves as a requirement template that
can be reused and tailored to eachcontext of use.
**Subjects**
A requirement definition or usage always has a _subject,_ which is a distinguished parameter that identifies the entity
on which the requirement is being specified. A requirement usage can only be satisfied by an entity that conforms to
the definition of its subject. For example, if the subject of a requirement is defined to be aVehicle _,_ then a standard
vehicle model or sports vehicle model can satisfy the requirement, as long as these usages are defined byVehicle
or a specialization of it. The subject can also be restricted to be a certain kind of definition element, if it is desired to
constrain what kind of entity can satisfy the requirement. For example, the subject can be restricted to be an action,
if it is desired to constrain the requirement to be satisfied only by action usages.
Constraining the subject of a requirement definition or usage is also useful to allow features of the subject definition
to be used in formal expressions for the assumed and required constraints of the requirement. However, this may not
be necessary if the requirement is specified more informally, or in terms of parameters or other features to be bound
later. In this case, it is not necessary to explicitly specify the subject of a requirement, in which case it the subject is
implicitly assumed to be defined asAnything.
**Note.** Cases also have subjects (see7.21).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 125**


**Actors, Stakeholders and Concerns**
Actors and stakeholders are additional distinguished parameters that may be specified for a requirement definition or
usage. Actor and stakeholder parameters are part usages representing entities that play special roles relative to the
requirement definition or usage. A requirement may have multiple actors and stakeholders, some of which may have
the same definition, representing the same kind of entity playing different roles relative to the requirement.
An _actor parameter_ represents a role played by an entity external to the subject of the requirement but necessary for
the satisfaction of the requirement. For example, a requirement whose subject is aVehiclemay also specify an
actor that is theDrivingEnvironment. Features of this actor may be used in, for example, the assumed
constraints of the requirement, to constrain the environment in which the required constraints apply. The satisfaction
of the requirement by a specific subject entity is then relative to the specific environment entity filling the actor role.
**Note.** Actor parameters may also be specified for cases (see7.21) and, in particular, use cases (see7.24).
A _stakeholderparameter_ represents a role played by an entity (usually a person, organization or other group) having
concerns related to the containing requirement. Stakeholder concerns may also be explicitly modeled as special
kinds of requirements. A _concern definition_ is a kind of requirement definition that represents a stakeholder concern.
A _concern usage_ is a kind of requirement usage that is a usage of a concern definition. The stakeholder parameters
of a concern definition or usage then delineate the stakeholders that have a certain concern.
Rather than explicitly referencing specific stakeholders, a requirement definition or usage can be specified as
_framing_ the modeled concerns of relevant stakeholders. All the framed concerns of a requirement must then be
_addressed_ for the requirement to be satisfied.
**Note.** Stakeholder and concern modeling is frequently used in the context of view and viewpoint modeling (see
7.25). A viewpoint is a kind of requirement that frames certain stakeholder concerns to be addressed by one more
more views satisfying the viewpoint.
**Requirement Satisfaction**
Since a requirement is a kind of constraint, a requirementcan be evaluated to betrueorfalse. Arequirement is
_satisfied_ when it evaluates totrue.
A _satisfy requirement usage_ is a kind of assert constraint usage (see7.19) that asserts that a requirement is satisfied
when a given feature is bound to the subject parameter of the requirement. Other parameters or features of the
requirement may also be bound in the body of the satisfy requirement usage. For example, the
maximumVehicleMassrequirement above could be asserted to be satisfied by a specificvehicle c1usage,
which means that the required constraint{massActual <= massRequired}must be true whenmassActualis
bound to the mass ofvehicle c1_._
Similarly to an assert constraint usage, a satisfy requirement usage can also be _negated._ A negated satisfy
requirement usage asserts that some entity does _not_ satisfy the given requirement.

**126 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Table 19. Requirements – Representative Notation
Element Graphical Notation Textual Notation
```
```
Requirement
Definition
```
```
requirement def RequirementDef1 {<R1>
Subject1; subject s1 :
}
requirement def RequirementDef1 {
}/* members */
```
```
Requirement
```
```
requirement requirement1 :<r1>
RequirementDef1 { subjectredefines s1
} = mySubject;
requirement requirement1 :
RequirementDef1 { doc /* ... */
subject = mySubject; redefines s1
requireassume constraint1;require2;
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 127**


```
Element Graphical Notation Textual Notation
```
```
Requirements
Compartment
```
```
{ requirement
requirement1 :RequirementDef1
[1..*] ordered nonunique ;
/* ... */
}
```
```
Satisfy Requirements
Compartment
```
```
partsatisfy part1 {requirement11
bybind part1 {
'requirement11-1'.x1 =a;
'requirement11-2'.x2 = bind
b;}
}
```
```
Satisfy
```
```
requirement requirement1 :
Requirement1;
partsatisfy part1 : Part1 {requirement1;
}
```
**7.20.2Requirement Definition and Usage**
A requirement definition or usage is declared as a kind of constraint definition or usage (see7.19.2), using the kind
keyword **requirement**. A requirement usage must be defined by a single requirement definition.
The informal _text_ of a requirement is given by any documentation comments written in the body of a requirement
definition or usage. If a requirement definition or usage is declared with a short name (see7.2), then this is also
considered to be its _requirement ID._
Formally, a requirement is a kind of constraint. However, rather than specifying its constraint expression directly, a
requirement constraint is built from two sets of other constraints: the _assumed_ and _required_ constraints of the
requirement. The effective constraint for the requirement is them a logical implication: if all the assumption
constraints are true, all the required constraints must be true. Required and assumed constraints are declared as
composite constraint usages in the body of a requirement definition or usage, by prefixing a regular constraint usage
declaration (see7.19.2) with the keyword **assume** or **require**.

**128 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**requirement defdoc** <'1.1'> MaximumMass {
/** Assuming the required mass is greater than 0,
* the actual mass shall be less than or equal to* the required mass.
*/
**attributeattribute** massActual : MassValue;massRequired : MassValue;
**assumerequireconstraintconstraint** { massRequired > 0[kg] }{ massActual <= massRequired }
}
An assumed or required constraint may also be declared using just the keyword **assume** or **require** instead of
**assume constraint** or **require constraint**. In this case, the declaration does not include either a name or
short name for the constraint usage. Instead, the constraint to be assumed or required is identified by giving a
qualified name or feature chain immediately after the **assume** or **require** keyword, and it is then related to the
assumed or required constraint usage by a _reference subsetting relationship_ (see also8.4.5.3).
**constraintattribute** massIsPositive {mass : MassValue;
} mass > 0[kg];
**constraintattribute** massLimit {mass : MassValue;
**attribute** massActual <= massRequiredmassLimit : MassValue;
} **requirement def** <'1.1'> MaximumMass {
**attributeattribute** massActual : MassValue;massRequired : MassValue;
**assume** :>> mass = massRequired;massIsPositive {
} **require** massLimit {
:>> mass = massActual;:>> massLimit = massRequired;
} }
The _subject_ of a requirement definition or usage is modeled as its first parameter. Following the general rule for
parameters (see7.16.2), the subject parameter of a requirement definition or usage will redefine the subject
parameter of any requirement definitions or usages that it specializes. The base requirement definition in the
Requirementslibrary model specifies the most general possible subject, with the default namesubjand the most
general typeAnything, and this can then be further specialized in specific requirement definitions and usages. A
subject parameter is always an **in** parameter, so it is not necessary to declare it with an explicit direction. Instead,
the keyword **subject** is used to identify the declaration of a subject parameter, which must come before the
declaration of any other parameters in a requirement definition or usage.
**requirementdoc** <'v1.1'> vehicleMaximumMass : MaximumMass {
/* The total mass of a Vehicle shall be no greater than* its required mass.
*/
**subjectattribute** vehicle : Vehicle;:>> massActual = vehicle.totalMass;

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 129**


**attribute** // Required and assumed constraints are inherited.:>> massRequired = 2000[kg];
}
A requirement definition or usage may also have one or more _actor_ or _stakeholder_ parameters. Similarly to the
declaration of a subject parameter, these distinguished parameters are declared using the keywords **actor** and
**stakeholder** rather than explicitly declaring their direction. Actor and stakeholder parameters are part usages, so
they must be (explicitly or implicitly) defined by part definitions (see7.11.2).
**requirementsubjectdef** vehicle : Vehicle;BrakingRequirement {
**actorstakeholder** environment : 'Driving Environment';driver : Person;
**attributeattribute** speedLimit : SpeedValue;maxBrakingDistance : DistanceValue;
**assumedocconstraint** /* The environment conditions are poor. */{
} **assume constraint** {
} **doc** /* The driver is an occupant of the vehicle. */
**assume constraintdoc** /* The vehicle speed is less than the speed limit. */{
}
**require constraintdoc** /* The vehicle shall brake from its initial speed to zero{
* speed in a distance less than the maxBrakingDistance.*/
} }
A composite requirement usage nested in a requirement definition or usage is a _subrequirement_ of the containing
requirement definition or usage. Subrequirements are considered to automatically be required constraints of the
containing requirement definition or usage. This is useful for modeling groups of requirements that are intended to
be satisfied together on the same subject. To simplify doing this, if a subject parameter is not explicitly declared for
a subrequirement, it is assumed to have the same subject as its containing requirement definition or usage, with its
subject bound to that of the container.
**requirement defsubject** vehicle : Vehicle;VehicleRequirementsGroup {
// The subject of the following subrequirements// are implicitly bound to the subject "vehicle"
// of the containing requirement definition. **requirement** driving : DrivingRequirement;
**requirement** braking : BrakingRequirement;
// The subject of the following subrequirement// is declared explicitly.
**requirementsubject** engineRqts : EngineRequirementsGroup {engine = vehicle.engine;
} }

**130 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The base requirement definition and usage areRequirementCheckandrequirementChecksfrom the
Requirementsmodel library (see9.2.13).

**7.20.3Concern Definitions and Usages**
A concern definition or usage is declared as a requirement definition or usage (see7.20.2) using the kind keyword
**concern** instead of **requirement**. Otherwise, a concern definition or usage is specified exactly like a regular
requirement definition or usage. The intent, however, is that the concerns of one or more stakeholders can be
modeled as the required constraints of a concern definition or usage with appropriate stakeholder parameters.
**concern defsubject** BrakingConcern {vehicle : Vehicle;
**stakeholder** driver : Person;
**attribute** maxBrakingDistance : DistanceValue;
**assume constraintdoc** /* The driver is an occupant of the vehicle. */{
} **require constraint** {
**doc** /* The vehicle shall brake from its initial speed to zero* speed in a distance less than the maxBrakingDistance.
} */
}
One or more concerns can then be _framed_ in other requirement definitions and usages. A framed concern usage is a
subrequirement usage (see7.20.2) indicated by prefixing a concern usage declaration with the keyword **frame**. As
for an assumed or required constraint, the keyword **frame** can be used rather than **frame concern** to declare a
framed concern using reference subsetting. In any case, since the framed concern usage itself is a subrequirement, it
will automatically be considered a required constraint of its containing requirement definition or usage.
**requirementsubjectdef** vehicle : Vehicle;BrakingRequirement {
**actor** environment : 'Driving Environment';
**attributeattribute** speedLimit : SpeedValue;maxBrakingDistance : DistanceValue;
**assumedocconstraint** /* The environment conditions are poor. */{
}
**frame concern** // Subject is automatically bound to "vehicle".brakingConcern : BrakingConcern {
} :>> maxBrakingDistance = BrakingRequirement::maxBrakingDistance;
}
The base concern definition and usage areConcernCheckandconcernChecksfrom theRequirementsmodel
library (see9.2.13).

**7.20.4Satisfy Requirement Usages**
A satisfy requirement usage is declared as a requirement usage (see7.20.2), using the kind keyword **satisfy
requirement**. However, a satisfy requirement usage differs from a regular requirement usage in two ways:

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 131**


1. The subject parameter of a satisfy requirement usage must be bound to a _satisfying feature._
2. A satisfy requirement usage is a kind of assert constraint usage (see7.19.3).
Together, these mean that a satisfy requirement usage asserts that it is satisfied as a requirement (that is, it always
evaluates to true) when the role of its subject is bound to the satisfying feature. The satisfying feature for a satisfy
requirement usage can be specified in its declaration, immediately before its body, after keyword **by**.
**partsatisfy requirement** vehicle1 : Vehicle;braking : BrakingRequirement **by** vehicle1 {
:>> speedLimit = 100[km/h];:>> maxBrakingDistance = 10[m];
}
A satisfy requirement usage may also be declared using just the keyword **satisfy** instead of **satisfy
requirement**. In this case, the declaration does not include either a name or short name for the satisfy requirement
usage. Instead, the requirement to be satisfied is identified by giving a qualified name or feature chain immediately
after the **satisfy** keyword, and it is then related to the satisfy requirement usage by a _reference subsetting
relationship_ (see also8.4.5.3).
**satisfy** vehicleMaximumMass **by** vehicle1;
A satisfy requirement usage can be _negated_ by placing the keyword **not** before **satisfy**. A negated satisfy
requirement usage asserts that the modeled requirement is _not_ satisfied by the value of the given satisfying feature.
**partnot satisfy** vehicle2 : ExperimentalVehicle;vehicleMaximumMass **by** vehicle2;

A satisfy requirement usage can be declared without an explicit satisfying feature if it is nested in definition or
usage. In this case, the satisfying feature is considered to be given by the containing definition or usage (in the case
of a definition this is essentially theselffeature of the definition; see [KerML, 9.2.2]).
**partpart** vehicle3 : Vehicle {engine : Engine;
// ...
// "vehicle3" is implicitly the satisfying feature. **satisfy** rqts : VehicleRequirementsGroup;
}

**7.21Cases
7.21.1Cases Overview**
_Metamodel references:_

- _Textual notation,8.2.2.21_
- _Graphical notation,8.2.3.21_
- _Abstract syntax,8.3.21_
- _Semantics,_ 8.4.17
A _case definition_ is a kind of calculation definition (see7.18) that produces a result intended to achieve a specific
objective regarding a given subject. A _case usage_ is a kind of calculation usage that is a usage of a case definition. A
case is a general concept that may be used in its own right, but also provides the basis for more specific kinds of
cases, including analysis cases (see7.22), verification cases (see7.23), and use cases (see7.24).

**132 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The _subject_ of a case is modeled as a distinguished parameter, similarly to the subject of a requirement (see7.20).
The _objective_ of a case is modeled as a requirement usage to be satisfied by the performance of the case. Depending
on the kind of case, the subject of the objective may be the same as the subject of the case (such as for a verification
case or a use case) or it may be the result of the case (such as for an analysis case).
A case definition or usage may also have one or more _actor parameters_ that represent roles played by an entity
external to the subject of the case but necessary to the specification of the case. An actor parameter is a part usage
representing an entity that plays a designated actor role for the case. A case may have multiple actors representing
the same kind of entity playing different roles relative to the case.
**Note.** Actor parameters may also be specified for any kind of case, but they are used, in particular, in the
specification of use cases (see7.24). Requirements may also have actor parameters (see7.20).
The body of a case can be specified using subactions and subcalculations needed to achieve the case objective. This
generally includes some combination of collecting information about the subject, evaluating it, and then producing a
result.

**7.21.2Case Definitions and Usages**
A case definition or usage is declared as a kind of calculation definition or usage (see7.18.2), using the kind
keyword **case**. A case usage must be defined by a single case definition.
The _subject_ of a case definition or usage is modeled as its first parameter. Following the general rule for parameters
(see7.16.2), the subject parameter of a case definition or usage will redefine the subject parameter of any case
definitions or usages that it specializes. The base case definition in theCaseslibrary model specifies the most
general possible subject, with the default namesubjand the most general typeAnything, and this can then be
further specialized in specific case definitions and usages. A subject parameter is always an **in** parameter, so it is
not necessary to declare it with an explicit direction. Instead, the keyword **subject** is used to identify the
declaration of a subject parameter, which must come before the declaration of any other parameters in a case
definition or usage.
A case definition or usage may also have one or more _actor_ parameters. Similarly to the declaration of a subject
parameter, these distinguished parameters are declared using the keyword **actor** rather than explicitly declaring
their direction. Actor parameters are part usages, so they must be (explicitly or implicitly) defined by part definitions
(see7.11.2).
The _objective_ of a case definition or usage is declared as a requirement usage (see7.20.2), but using the keyword
**objective** instead of **requirement**. The subject of an objective requirement is bound by default to the result of
the case definition or usage, meaning that the objective of the case concerns its result. However, this can be
overridden in specific case definitions or usages (but see7.22.2and7.23.2on the required bindings for analysis
cases and verification cases).
**case defsubject** FaultRecovery {system : AutomationSystem;
**actorobjective** engineer : Person;{
**doc** /* The engineer determines the cause of the system
* fault and resolves it returning the system to* nominal operation.
} */
}
The base case definition and usage for areCaseandcasesfrom theCasesmodel library (see9.2.14).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 133**


**7.22Analysis Cases
7.22.1Analysis Cases Overview**
_Metamodel references:_

- _Textual notation,8.2.2.22_
- _Graphical notation,8.2.3.22_
- _Abstract syntax,8.3.22_
- _Semantics,8.4.18_
An _analysis case definition_ is a kind of case definition (see7.21) whose objective is to carry out an analysis on the
subject of the case. An _analysis case usage_ is a kind of case usage that is a usage of an analysis case definition.
The subject of an analysis case identifies what is being analyzed. The subject can often be kept quite general in an
analysis case definition and then made more specific in usages of that definition. Performing an analysis case returns
a result about the subject. For example, a fuel economy analysis of a vehicle subject returns the estimated fuel
economy of the vehicle, given a set of analysis inputs and assumed conditions. The analysis result can be evaluated
to determine whether it satisfies the analysis objective.
The performance of an analysis case can be specified in a number of different ways.
- The analysis case can include a set of _analysis actions_ , each of which can specify calculations that return
results. For example, the fuel economy analysis referred to above may require both a dynamics analysis
and a fuel consumption analysis. The dynamics analysisdetermines the vehicle trajectory and the required
engine power versus time. The fuel consumption analysis determines the fuel consumed to achieve the
required engine power. Both the dynamics analysis and the fuel consumption analysis may require
multiple calculations.
- An analysis can be specified in SysML and solved by external solvers. In this case, the analysis case
specifies the analysis to be performed, but does not define how the analysis is actually executed. For
example, the analysis case could specify that the analysis result is obtained by integrating a differential
equation, without detailing what integration algorithm is to be used to do this.
- An analysis case can also specify a set of simultaneous equations to be solved. This can be done defining
one or more constraint usages (see7.19) that logicallyandeach of the equations, and asserting that the
constraint must be true. A solver would be expected to solve the equations such that it returns values that
satisfy each equation.

**134 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Table 20. Analysis Cases - Representative Notation
Element Graphical Notation Textual Notation
```
```
Analysis Case
Definition
```
```
analysis def AnalysisDef1 {
Subject1; subject s1 :
objectivedoc /* '...' */;{
assumption1; assume
} }
analysis def AnalysisDef1 {
}/* members */
```
```
Analysis Case
```
```
analysis AnalysisDef1 {analysis1 :
subject = mySubject; redefines s1
objectivedoc /* '...' */{
assumption1; assume
} }
analysis AnalysisDef1 {analysis1 :
}/* members */
```
```
Analyses
Compartment
```
```
analysis AnalysisDef1 {analysis1 :
... analysis analysis4 :
} AnalysisDef4;
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 135**


**7.22.2Analysis Case Definitions and Usages**
An analysis case definition or usage is declared as a case definition or usage (see7.21.2), using the kind keyword
**analysis**. An analysis case usage must be defined by a single analysis case definition.
For an analysis case, the subject of the objective is always bound to the result of the analysis case definition or
usage. That is, the objective is always about the result that is produced by the analysis.
**analysissubjectdef** vehicle : Vehicle;FuelEconomyAnalysis {
**return** fuelEconomyResult : DistancePerVolumeValue;
**objectivedoc** fuelEconomyAnalysisObjective {
/** The objective of this analysis is to determine whether the
* subject vehicle can satisfy the fuel economy requirement.*/

} **requirement** : FuelEconomyRequirement;
} // ...
The base analysis case definition and usage areAnalysisCaseandanalysisCasesin theAnalsysisCases
model library (see9.2.15).

**7.22.3Trade-Off Analyses**
A _trade-off analysis_ is a special kind of analysis used to evaluate and compare alternatives. Such an analysis can be
modeled by a usage of theTradeStudyanalysis case definition from theTradeStudieslibrary model found in
the Analysis Domain Library (see9.4.5).
The subject of aTradeStudyanalysis case is the collection of alternatives to be analyzed. An _evaluation function_ is
then provided that is used to evaluate each alternative, in order to find the alternative that meets the objective of the
analysis case. CommonTradeStudyobjectives are to maximize or minimize the value of the objective function.
An example of a trade-off analysis is an analysis that evaluates and compares alternatives for a vehicle engine in
terms of various criteria, such as power, mass, efficiency and cost. The evaluation function establishes a relative
weighting of each criterion based on its importance to the stakeholder. The evaluation result is computed for each
alternative based on a weighted sum of the normalized value for each of the criteria. The evaluation results for each
alternative are then compared with each other, based on theTradeStudyobjective, to determine a preferred
solution.
**analysis** // The subject is bound to the two alternatives to be studied.engineTradeStudy : TradeStudy {
**subject** : Engine = (engine4cyl, engine6cyl);
// The objective is to find the alternative that has the// maximum value for the evaluationFunction.
**objective** : MaximizeObjective;
// For each one of the alternatives, the evaluationFunction// produces a numerical evaluation result.
**calcin** :>> evaluationFunction { **part** anEngine : Engine :>> alternative;

**136 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
calcin powerRollup: PowerRollup {engine = anEngine;
} return power;
calcin massRollup: MassRollup {engine = anEngine;
} return mass;
calcin efficiencyRollup: EfficiencyRollup {engine = anEngine;
} return efficiency;
calcin costRollup: CostRollup {engine = anEngine;
} return cost;
return power = powerRollup.power,:>> result : Real = EngineEvaluation(
mass = massRollup.mass,efficiency = efficiencyRollup.efficiency,
); cost = costRollup.cost
}
// The selected alternative will be the one that has the// maximum value for the evaluationFunction.
} returnpart :>> selectedAlternative : Engine;
```
**7.23Verification Cases
7.23.1Verification Cases Overview**
_Metamodel references:_

- _Textual notation,8.2.2.23_
- _Graphical notation,8.2.3.23_
- _Abstract syntax,8.3.23_
- _Semantics,8.3.23_
A _verification case definition_ is a kind of case definition (see7.21) whose result is a verdict on whether the subject
of the case satisfies certain requirements. A _verification case usage_ is a case usage that is a usage of a verification
case definition.
The subject of a verification case is an input parameter that identifies the system or other entity that is being
evaluated as to whether it satisfies certain requirements (often referred to as the "unit under test" or "unit under
verification"). The subject may be kept general in a verification case definition and then made more specific in
usages of that definition. The objective of a verification case is to verify that the verification subject satisfies one or
more specific requirements, which are specified as a special kind of required constraint in the objective. The result
of the validation case is a _verdict,_ which is one of the following:
- _Pass_ indicates that the subject has been determined to satisfy the requirements to be verified.
- _Fail_ indicates that the subject has been determined _not_ to satisfy the requirements to be verified.
- _Inconclusive_ indicates that a determination could not be made as to whether the subject satisfies the
requirements to be verified.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 137**


- _Error_ indicates that an error occurred during the performance of the verification.
A typical verification case includes a set of _verification actions_ that perform the following steps.
1. _Collect data_ about the subject as needed to support the verification objective, which is typically done
using _verification methods_ such as analysis, inspection, demonstration, and test.
2. _Analyze collecteddata._ For example, the data may include multiple measurements that span a range of
conditions for a particular individual, or measurements of different individuals. Thisanalysis step may
need to determine the probability distribution, mean, and standard deviation associated with the
measurements.
3. _Evaluate the results of the analysis_ based on the objective to produce a verdict.
Each of the verification actions in the verification case requires a set of resources to perform the actions. This may
include verification personnel, equipment, facilities, and other resources. These resources maybe represented in the
model as parts that perform actions, or more specifically, using actor parameters on the verification case.
**Table 21. Verification Cases – Representative Notation
Element Graphical Notation Textual Notation**

```
Verification Case
Definition
```
```
verification def VerificationDef1 {
Subject1; subject s1 :
objectivedoc /* '...' */{
requirement1; verify
} }
verification def VerificationDef1 {
}/* members */
```
**138 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Verification Case
```
```
verification verification1 :
VerificationDef1 { subjectredefines s1
= mySubject; objective {
docverify /* '...' */
requirement1;}
}
verification verification1 :
VerificationDef1 {/* members */
}
Verified
Requirements
Compartment
```
```
Verifications
Compartment
```
```
{ verification
verification1 :VerificationDef1
[1..*] ordered nonunique ;
/* ... */ perform verification
verification10; verification
verification11 { verification
'verification11.1'; verification
'verification11.2';}
}
```
```
Verification Methods
Compartment
```
```
metadata VerificationMethod {
analysis,kind = (inspection,
demonstration,test);}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 139**


```
Element Graphical Notation Textual Notation
```
```
Verifies
Compartment
```
```
objectiveverify {requirement1;
} verify requirement2;
```
```
Verify
```
```
requirement requirement1:
verification Requirement1;
verificationCase1 :VerificationCase1 {
objectiveverify {
requirement1;}
}
```
**7.23.2Verification Case Definitions and Usages**
A verification case definition or usage is declared as a case definition or usage (see7.21.2), using the kind keyword
**verification**. A verification case usage must be defined by a single verification case definition.
For a verification case, the subject of the objective is always bound to the subject of the verification case definition
or usage. That is, the objective is always about the verification of requirements relative to the subject of the case.
In addition to assumed and required constraint usages allowed in any requirement usage (see7.20.2), the objective
of a verification case may also have _requirementverification_ usages, which indicate the requirements to be verified
by the verification case. A requirement verification usage is a subrequirement of the objective that is indicated by
prefixing a requirement usage declaration with the keyword **verify**. As for an assumed or required constraint, the
keyword **verify** can be used rather than **verify requirement** to declare a verified requirement using reference
subsetting. In any case, since the requirement verification usage itself is a subrequirement, it is automatically
considered a required constraint of its containing objective. In addition, its subject is bound by default to the subject
of the objective, which is itself bound to the subject of the verification case.
The result of a verification case is averdictthat can have the valuespass,fail,inconclusive, orerror. In
simple cases, thePassIfcalculation definition from theVerificationCaseslibrary model (see9.2.16) can be
used to obtain a pass or fail verdict based on a Boolean value. In addition, theVerificationMethodmetadata
definition can be used to annotate a verification case with the method used to carry out the verification, one of
inspect,analyze,demo, ortest(see also7.26).
**verificationimport** VerificationCases::*; **def** VehicleMassTest {
**subjectobjective** testVehicle : Vehicle;vehicleMassVerificationObjective {
// The subject of the verify is automatically bound to "testVehicle". **verify** vehicleMassRequirement;
}
**metadata** kind = VerificationKind::test;VerificationMethod {

**140 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
}
actionin collectData {part testVehicle : Vehicle = VehicleMassTest::testVehicle;
} out massMeasured :> ISQ::mass;
actionin processData {massMeasured :> ISQ::mass = collectData.massMeasured;
} out massProcessed :> ISQ::mass;
actionin evaluateData {massProcessed :> ISQ::mass = processData.massProcessed;
out verdict : VerdictKind =// Check that "testVehicle" statisfies "vehicleMassRequirement"
// if its mass equals 'massProcessed'.PassIf(vehicleMassRequirement(
vehicle = testVehicle,massActual = massProcessed)
} );
} return verdict : VerdictKind = evaluateData.verdict;
```
**7.24Use Cases
7.24.1Use Cases Overview**
_Metamodel references:_

- _Textual notation,8.2.2.24_
- _Graphical notation,8.2.3.24_
- _Abstract syntax,8.3.24_
- _Semantics,8.4.20_
A _use case definition_ is a kind of case definition (see7.21) that specifies the required behavior of its subject relative
to one or more external actors. The objective of the use case is to provide an observable result of value to one or
more of its actors. A _use case usage_ is a case usage that is a usage of a use case.
A use case is typically specified as a sequence of interactions between the subject and the various actors, which are
all modeled as part usages. Each interaction can be modeled as a _message_ (see7.13) that delivers some payload or
signal from an actor to the system or vice versa. The sources and target ends of these messages can either be
modeled simply as abstract events within the lifetime of the subject and actor occurrences (see7.9), or more
concretely as actions performed to carry out the interaction (see7.16).
An _include use case usage_ is a use case usage that is also a kind of perform action usage (see7.16). A use case
definition or usage may contain an include use case usage to specify that the behavior of the containing use case
includes the behavior of the included use case. The subject of the included use case is the same as the subject of the
containing use case, so the subject parameter of the included use case must have a definition that is compatible with
the definition of the containing use case. Actor parameters of the included use case may be bound to corresponding
actor parameters of the containing use case as necessary (see also7.16on parameter binding and7.13on binding in
general).
As a behavior, a use case can be performed with specific values for its subject and actor parameters. If a given
subject also has a design model that decomposes its internal structure, then it should be possible to construct an
interaction of the internal parts of the subject, consistent with the design model, that can be shown to be a

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 141**


specialization of the behavior specified by the performance of the use case for that subject. This is known as a
_realization_ of the use case relative to the design model. A system is properly designed to provide the behavior
required by a set of use cases if there is a legal realization of each use case relative to the design of the system.
**Table 22. Use Cases – Representative Notation
Element Graphical Notation Textual Notation**

```
Use Case Definition
```
```
use case def UseCaseDef1 {
subjectobjective s1:Subject1;{
the objective doc /* This is
description. */ require
requirement1;}
}
use case def UseCaseDef1 {
}/* members */
```
```
Use Case
```
```
use case UseCaseDef1 {useCase1 :
= mySubject; subject redefines s1
objectivedoc /* '...' */{
requirement1; require
} }
use case UseCaseDef1 {useCase1 :
}/* members */
```
**142 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Include Use Case
Compartment
```
```
{ includeuse case
useCase1 :UseCase1 [1..*]
/* ... */ ordered nonunique ;
}
```
```
Includes
Compartment
```
```
Use Case Graphical
Compartment
```
```
use casesubject useCase1 {system =
system1; actor actor1 :
Actor1; actor actor2 :
Actor2; actor actor3 :
Actor3; include useCase2;
} include useCase3;
use caseusecase useCase2;useCase3;
```
**7.24.2Use Case Definitions and Usages**
A use case definition or usage is declared as a case definition or usage (see7.21.2), using the kind keyword **use
case**. A use case usage must be defined by a single use case definition.
A use case definition will typically have an explicit declaration of its subject and one or more external actors (see
see7.21.2on the declaration of subject and actor parameters in case definitions). The objective of the use case is for
the subject to provide some result of value to one or more of the actors. The subject and the actors interact in order
to achieve this objective, and the use case definition may specify this interaction as, for example, messages passing
between them (see7.13.6on message declarations).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 143**


**use case defsubject** vehicle : Vehicle;'Provide Transportation' {
**actoractor** driver : Person;passengers : Person[0..4];
**actor** environment : Environment;
**objectivedoc** {
/* Transport driver and passengers from starting location* to ending location.
} */
**message ofthen message** Enter **of** Enter **from** driver **from** passengers **to** vehicle; **to** vehicle;
**thenthenmessagemessageofof** DriveExit **fromfrom** passengersvehicle **toto** environment;vehicle;
} **thenmessageof** Exit **from** driver **to** vehicle;
The base use case definition and usage areUseCaseanduseCasesfrom theUseCaseslibrary model (see9.2.17)

**7.24.3Include Use Case Usages**
An _include_ use case usage is declared as a use case usage (see7.24.2) using the kind keyword **include use case**
instead of just **use case**. An include use case usage is a kind of perform action usage (see7.16.6) for which the
action usage is a use case usage, known as the _included use case._ As for a perform action usage, the included use
case is related to the include use usage by a _reference subsetting_ relationship, specified textually using the keyword
**references** or the symbol::>. Or, if the include use case usage has no such reference subsetting, then the
included use case is the include use case usage itself.
An include use case usage may also be declared using just the keyword **include** instead of **include use case**.
In this case, the declaration does not include either a name or short name. Instead, the included use case of the
include use case usage is identified by giving a qualified name or feature chain immediately after the **include**
keyword.
The subject of an included use case usage is bound by default to the subject of its containing use case definition or
usage. However, the actor parameters of the included use case usages should be explicitly bound to appropriate
actors of the containing use case, as necessary.
**use casefirst** 'provide transportation' : 'Provide Transportation' {start;
**then includeactor** :>> driver = 'provide transportation'::driver;'enter vehicle' {
} **actor** :>> passengers = 'provide transportation'::passengers;
**then includeactor** :>> driver = 'provide transportation'::driver;'drive vehicle' {
} **actor** :>> environment = 'provide transportation'::environment;
**then includeactor** :>> driver = 'provide transportation'::driver;'exit vehicle' {
**actor** :>> passengers = 'provide transportation'::passengers;

**144 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
}
} then done;
```
**7.25Views and Viewpoints
7.25.1Views and Viewpoints Overview**
_Metamodel references:_

- _Textual notation,_ 8.2.2.25
- _Graphical notation,_ 8.2.3.25
- _Abstract syntax,_ 8.3.25
- _Semantics,_ 8.4.21
A _viewpoint definition_ is a kind of requirement definition (see7.20) that frames the concerns of one or more
stakeholders regarding information about a modeled system or domain of interest. A _viewpoint usage_ is a
requirement usage that is a usage of a viewpoint definition. The subject of a viewpoint is a _view_ that is required to
address the stakeholder concerns.
A _view definition_ is a kind of part definition (see7.11) that specifies how to create a view artifact to satisfy one or
more viewpoints. A view artifact is a rendering of information that addresses some aspect ofa system or domain of
interest of concern to oneor more stakeholders. A view definition can include _view conditions_ to extract the relevant
model content, and a _rendering_ that specifies how the model content should be rendered in a view artifact. A view
condition is specified using metadata, in the same way as for a filter condition on a package (see7.5).
A view definition and its rendering can preserve a correspondence between elements of the model and of the
graphical and/or textual elements of the view artifact. The implementation of a rendering can follow this
correspondence to propagate changes to aview artifactback to the model from which the view artifact was extracted
and rendered.
A view usage is a kind of part usage (see7.11) that is a usage of a view definition. A view usage _exposes_ a portion
of a model, which is a kind of import (see7.5) without regard to visibility that provides the scope of application of
the view conditions. The view rendering can then be applied to those exposed elements that meet all the view
conditions to produce the view artifact. A view usage can add further view conditions to those inherited from its
view definition, and it can specify a view rendering if one is not provided by its definition.
View usages can be nested and ordered within a composite view to generate composite view artifacts.The view
usage also can contain further rendering specifications on the symbolic representation, style, and layout fora
particular view. For example, a complex view definition with deeply nested structures can be rendered as a
document, where each nested view usage corresponds to a section of a document, and the ordering represents the
order of the sections within the document. Within each section of the document, the nested view usagescan then
specify the information that is rendered as a combination of text, graphical, and tabular information.
A _rendering definition_ is a kind of part definition (see7.11) that specifies how a view artifact is to be rendered. A
_rendering usage_ is a kind of part usage that is a usage of a rendering definition. A rendering usage is used in a view
definition or usage to specify the view rendering.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 145**


```
Table 23. Views and Viewpoints – Representative Notation
Element Graphical Notation Textual Notation
```
```
View Definition
```
```
view defsatisfy ViewDef1 {viewpoint1;
/* ... */ filter
filterExpression1;/* ... */
} render rendering1;
view def /* members */ViewDef1 {
}
```
```
View
```
```
viewsatisfy view1 : ViewDef1 {viewpoint1;
exposefilter part1::**;@PartUsage;
} render asTable;
view /* members */view1 : ViewDef1 {
}
```
**146 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Viewpoint Definition
```
```
viewpoint def ViewPointDef1;
viewpoint def ViewPointDef1 {
}/* members */
```
```
Viewpoint
```
```
viewpoint ViewPointDef1;viewpoint1 :
viewpoint ViewPointDef1 {viewpoint1 :
}/* members */
```
```
Expose
```
```
partview part1 : Part1;view1 : View1 {
} expose part1;
```
```
Frame
```
```
concern Concern1;concern1 :
viewpoint Viewpoint1 {viewpoint1 :
} frame concern1;
```
```
Frames
Compartment
```
```
{ frame concern
concern1 : Concern1[1..*]
/* ... */ ordered nonunique ;
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 147**


**7.25.2View Definitions and Usages**
A view definition or usage is declared as a kind of part definition or usage (see7.11.2), using the kind keyword
**view**. A view usage must be defined by a single view.
A view definition includes _filter conditions_ on what kinds of elements can be included in a view and identifies a
_viewrendering_ that determines how the included elements are to be rendered. The filter conditions are specified in
the same way as for packages (see7.5.4), by using the keyword **filter** followed by a Boolean-valued, model-level
evaluable expression (see [KerML. 7.4.9]).
The view rendering is specified using the keyword **render** followed by a qualified name or feature chain
identifying a rendering usage (see7.25.4), which establishes a reference subsetting relationship between the view
rendering usage and the identified rendering usage. (Note that, in the textual notation, it is only possible to specify a
view rendering using reference subsetting.) TheViewsmodel in the Systems Model Library provides a limited
number of basic standard renderings (see9.2.18).
**view defimport** 'Part Structure View' {Views::*;
**filterrender** @SysML::PartUsage;asTreeDiagram;
}
A view usage inherits any filter conditions from its view definition and can declare addition conditions of its own. If
a view usage does not declare a view rendering, then this will be inherited from the view definition, if it has one. If a
view usage does declare a view rendering, then this will redefine the view rendering from its view definition (if
any). Note that this means that the view rendering for a view usage must be consistent with the rendering specified
in the view definition, though it can be more specialized.
In addition, a view usage can specify which elements are actually to be _exposed_ by the view. This is done using
expose relationships, which are a special kind of import relationships. Expose relationships are declared like import
relationships (see7.5.3), but using the keyword **expose** instead of **import**. A view artifact is generated from a view
usage by first importing the exposed elements based on the expose relationships of the view usage, filtering those
based on the filter conditions that are owned and inherited by the view usage, and then generating a rendered view
artifact using the view rendering specified for the view usage.
**view** // Recursive import is useful for exposing elements'vehicle parts view' : 'Part Structure View' {
// from hierarchical models. **expose** VehicleDesignModel::**;
// This is an additional filter condition. **filternot** @SysML::ConnectionUsage;
// This implicitly redefines the view rendering from// the view definition.
} **render** asMyTreeDiagram;
Since an expose relationship is a kind of import relationship, the filtered import notation can also be used with it (see
7.5.4). This provides an alternate way to filter the elements exposed by a view usage.
**view** // This applies the filter directly on the imported'vehicle parts view' : 'Part Structure View' {
// elements from the expose relationships. (The filter// conditions from the view definition also still apply.)

**148 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**expose** VehicleDesignModel::**[ **not** @SysML::ConnectionUsage];
} **render** asMyTreeDiagram;
The base view definition and usage areViewandviewsfrom theViewsmodel library (see9.2.18).

**7.25.3Viewpoint Definitions and Usages**
A viewpoint definition or usage is declared as a kind of requirement definition or usage (see7.20.2). A viewpoint
usage must be defined by a single viewpoint definition.
The subject of a viewpoint definition or usage must be a view. Otherwise, a viewpoint is specified with assumed and
required constraints, just like any requirement definition or usage. However, it is typical for a viewpoint definition to
be structured as framing a set of stakeholder concerns (see7.20.3) regarding information about a modeled system or
domain of interest. The viewpoint then models the requirement for view needed in order to address the framed
concerns.
**concernstakeholder** 'system breakdown' {se : 'Systems Engineer';
} **stakeholder** ivv : 'IV&V';
**concernstakeholder** 'modularity' {se : 'Systems Engineer';
}
**viewpointframedef** 'system breakdown';'System Structure Perspective' {
**frame** 'modularity';
**requiredoc constraint** {
/* A system structure view shall show the hierarchical* part decomposition of a system, starting with a
* specified root part.*/
} }
Since a viewpoint usage is a kind of requirement usage, a view usage can be declared to satisfy a viewpoint usage
using a satisfy requirement usage (see7.20.4). However, as a short cut, any composite viewpoint usage nested in a
view definition or usage is asserted to be satisfied by that view.
**view def** // This viewpoint is asserted to be satisfied by any'Part Structure View' {
// instance of the view definition. **viewpoint** vp : 'System Structure Perspective';

} //...
Alternatively, a satisfy requirement usage can be used explicitly between a viewpoint and a view. In particular, a
satisfy requirement usage for a viewpoint that is nested in a view definition or usage will, by default, have the
containing view as its satisfying feature (as described in general for nested satisfy requirement usages in7.20.4).
**viewpoint** 'System Structure Perspective' {'vehicle structure perspective' :

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 149**


```
} subject : Vehicle;
view // This asserts that the give viewpoint is satisfied by the'vehicle parts view' : 'Part Structure View' {
// 'vehicle parts view'. satisfy 'vehicle structure perspective';
```
} // ...
The base viewpoint definition and usage areViewpointandviewpointsfrom theViewslibrary model (see
9.2.18).

**7.25.4Rendering Definitions and Usages**
A rendering definition or usage is declared as a kind of part definition or usage (see7.11.2), using the kind keyword
**rendering**. A rendering usage must be defined by a single rendering definition.
While a rendering is intended to specify how a view is rendered as a view artifact, there are no specific constructs
provided in SysML for specifying that. A rendering definition or usage can be defined similarly to any other part
definition or usage, perhaps with nested subrenderings and references to related view usages. Nevetheless,
conforming tools can provide libraries of rendering usages that reflect the capabilities they provide for rendering
various kinds of views, which can then be identified in user models specifying those kinds of views. A small number
of basic standard rendering usages are provided in theViewslibrary model (see9.2.18).
The base rendering definition and usage areRenderingandrenderingsfrom theViewslibrary model (see
9.2.18).

**7.25.5Diagrams**
A _diagram_ is a view usage (see7.25.2) where the diagram name and type are the names of the view usage and view
definition, respectively. A _view artifact_ is an individual view usage where the model content is rendered in a
compartment of the view usage. A view about a particular element can expose the element and be rendered as a
compartment of the rendering of that element. For example, the attributes view of a part can be rendered in an
attributes compartment of the graphical symbol for the part (see, for example,Table 9in7.11.2). The rendered
information can be in textual or graphical form.
TheStandardViewDefinitionsmodel in the Systems Model Library (see9.2.19) provides a small set of
standard view definitions for typical kinds of diagrams. However, visualization of SysML models is not limited to
these standard views. User models of view definitions and usages can be used to provide a wide range of user-
defined visualizations.

**150 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Table 24. Diagrams – Representative Examples
Standard View Diagram
```
```
General View
```
```
Tree View
```
```
Nested View
```
```
Table View
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 151**


```
Standard View Diagram
```
```
Matrix View
```
```
Matrix View
```
**7.26Metadata
7.26.1Metadata Overview**
_Metamodel references:_

- _Textual notation,_ 8.2.2.26
- _Graphical notation,_ 8.2.3.26
- _Abstract syntax,_ 8.3.26
- _Semantics,_ 8.4.22
A _metadata usage_ is a kind of annotating element (see7.4) that allows for the definition of structured metadata with
modeler-specified attributes. This may be used, for example, to add tool-specific information to a model that can be
relevant to the function of various kinds of tooling that may use or process a model, or domain-specific information
relevant to a certain project or organization. A metadata usage is defined by a single _metadata definition_. If the
definition has no nested features itself, then the metadata usage simply acts as a user-defined syntactic tag on the
annotated element. If the definition does have features, then the metadata usage must provide value bindings for all
of them, specifying metadata for the annotated element.
**Table 25. Metadata – Representative Notation
Element Graphical Notation Textual Notation**

```
Metadata
```
```
metadata attribute1=value1;MetadataDef1 {
attribute2="value2";
attribute3="http://...."}
or
@MetadataDef1 {attribute1=value1;
attribute2="value2";
attribute3="http://...."}
```
**152 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Element Graphical Notation Textual Notation
```
```
Annotation-Metadata
```
```
analysis vehicleAnalysis :
metadata VehicleAnalysis;ToolMetadata
vehicleAnalysis { about
toolName="ToolX";
toolURL="http://.....";behaviorName=
"ComputeVehicleState";}
or
analysis vehicleAnalysis :
VehicleAnalysis { metadata
ToolMetadata {toolName="ToolX";
toolURL="http://.....";behaviorName=
"ComputeVehicleState";}
}
```
```
Metadata
Compartment
```
```
metadata attribute1=value1;MetadataDef1 {
attribute2="value2";attribute3=
} "http://.....";
```
**7.26.2Metadata Definitions and Usages**
A metadata definition is declared like an item definition (see7.10), but using the keyword **metadata def**.
**metadata def** SecurityRelated;
**metadata defattribute** ApprovalAnnotation {approved : Boolean;
} **attribute** approver : String;
A metadata usage is declared like an item usage (see7.10) using the keyword **metadata** (or the symbol@)followed
by the keyword **definedby** (or the symbol:) and the qualified name of exactly one metadata definition or KerML
Metaclass (see [KerML], 7.4.13). If there is no declared name or short name, then the keyword **definedby** (or the
symbol:) may also be omitted. In addition, one or more annotated elements can be identified for the metadata usage

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 153**


after the keyword **about** , indicating that the metadata usage has annotation relationships to each of the identified
elements (see also7.4on annotation relationships).
**metadataabout** securityDesignAnnotation : SecurityRelatedSecurityRequirements, SecurityDesign;

If the specified metadata definition (or KerML metaclass) has features, then a body must be given for the metadata
usage that declares reference usages (see7.6) that redefine each of the features of the definition and binds them to
the result of model-level evaluable expressions (see [KerML, 7.4.9]). These nested reference usages of a metadata
usage must always have the same names as the names of the features of its metadata definition, so the shorthand
prefix redefines notation (see7.6) is always used
**metadataref** :>> approved = true;ApprovalAnnotation **about** Design {
} **ref** :>> approver = "John Smith";
The keyword **ref** and/or **redefines** (or the equivalent symbol:>>) may be omitted in the declaration of a feature
of a metadata usage.
**metadata** approved = true;ApprovalAnnotation **about** Design {
} approver = "John Smith";
If the metadata usage is an owned member of a namespace (see7.5), then the explicit identification of annotated
elements can be omitted, in which case the annotated element shall be implicitly the containing namespace.
**part** // This metadata usage is implicitly about the part def Design. **def** Design {
@ApprovalAnnotation {approved = true;
} approver = "John Smith";
}
The base metadata definition and usage areMetadataItemandmetadataItemsfrom theMetadatalibrary (see
9.2.20). The base metadata definitionMetadataItemspecializes the KerML metaclassMetaobject, and it inherits
the featureannotatedElementfromMetaobject, which is typed by the reflected KerML metaclass
KerML::Element(see [KerML, 9.2.17]). When a metadata usage is declared, its inheritedannotatedElement
feature is implicitly bound to reflective instances representing its annotated elements.
**metadataabout** securityDesignAnnotation : SecurityRelatedSecurityRequirements, SecurityDesign {
// The feature "annotatedElement" is implicitly bound to the list// of SecurityRequirements **meta** KerML::Element and
} // SecurityDesign **meta** KerML::Element.
A metadata definition can restrict the kind of elements that it can be applied to by subsetting
Metaobject::annotatedElementand restricting its type. If a metadata usage then inherits one or more concrete
features that directly or indirectly subsetannotatedElement, any annotated element of the metadata usage must
conform to the type of at least one of these features. The restricted type should be one of the reflective metaclasses
from theKerML(see [KerML, 9.2.17]) orSysML(see9.2.21) abstract syntax models.

**154 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**metadata def** // A metadata usage of this definition may annotateCommandMetadata {
// an ActionDefinition or an ActionUsage.:> annotatedElement : SysML::ActionDefinition;
} :> annotatedElement : SysML::ActionUsage;
**action def** @CommandMetadata; // This is valid.Save **specializes** UserAction {
**redefine** @CommandMetadata; // This is valid. **action** doAction {
} }
**item** @CommandMetadata; // This is INVALID. **def** Options {
}
**7.26.3Semantic Metadata**
If the metadata definition of a metadata usage is a direct or indirect specialization of KerML metaclass
SemanticMetadatafrom the Metaobjects model in the Kernel Semantic Library (see [KerML, 9.2.16]), then the
annotated elements of the metadata usage must all be types (e.g., definitions or usages), and the inheritedfeature
SemanticMetadata::baseTypemust be bound to a value of typeKerML::Type(which is a generalization of
SysML::DefinitionandSysML::Usage). Each annotated element is then considered to implicitly specialize a
definition or usage determined from thebaseTypevalue as follows:

- If the annotated type is a definition and thebaseTypeis a definition (or KerML classifier), then the
    annotated definition implicitly subclassifies thebaseType.
- If the annotated type is a definition and thebaseTypeis a usage (or KerML feature), then the annotated
    definition implicitly subclassifies each definition (or type)of thebaseType.
- If the annotated type is a usage and thebaseTypeis a usage (or KerML feature), then the annotated usage
    implicitly subsets thebaseType.
- Otherwise no implicit specialization is added.
When evaluated in a model-level evaluable expression, the meta-cast operator **meta** (see [KerML, 7.4.9.2]) may be
used to cast a type element referenced as its first operand to the actual reflective metadata definition (or KerML
metaclass) value for the type, which may then be bound to thebaseTypefeature ofSemanticMetadata.
**action defaction** userActions : UserAction[*]UserAction; **nonunique** ;
**metadata def** // The meta-cast operation "userAction meta SysML::Usage" hasCommandMetadata :> SemanticMetadata {
// type Usage, which conforms to the type KermL::Type of baseType.// Since userActions is an ActionUsage, the expression evaluates
// at model level to a value of type SysML::ActionUsage.:>> baseType = userActions **meta** SysML::Usage;
}
// Save implicitly subclassifies UserAction// (which is the definition of userActions).
**action def** @CommandMetadata;Save {
}
// previousAction implicitly subsets userActions. **action** previousAction[1] {

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 155**


} @CommandMetadata;
**7.26.4User-Defined Keywords**
A _user-defined keyword_ is the (possibly qualified) name (or short name) of a metadata definition (or KerML
metaclass) preceded by the symbol#. Such a keyword can be used in package, dependency, definition and usage
declarations. The user-defined keyword is placed immediately before the language-defined (reserved) keyword for
the declaration and specifies a metadata annotation of the declared element. If the named metadata definition is a
kind ofSemanticMetadata, then the implicit specialization rules given in7.26.3for semantic metadata also apply.
**occurrence defoccurrence** situations : Situation[0..*]Situation; **nonunique** ;
// It is often convenient to use a lower-case initial name or// short name for semantic metadata intended to be used as a keyword.
**metadata def** :>> baseType = situations<situation> SituationMetadata :> SemanticMetadata { **meta** SysML::Usage;
}
// Failure is an OccurrenceDefinition that implicitly subclassifies Situation. **#situation occurrence def** Failure;
// batteryLow is an OccurrenceUsage that implicitly subsets situations. **#situation occurrence** batteryLow;

In addition, a user-defined keyword for semantic metadata may also be used to declare a definition or usage without
using any language-defined keyword.
// Failure is a definition that implicitly subclassifies Situation. **#situation def** Failure;
// batteryLow is a usage implicitly subsets situations. **#situation** batteryLow;

It is also possible to include more than one user defined-keyword in a declaration.
**#SecurityRelated #situation def** Vulnerability;

**156 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 8 Metamodel....................................................................................................................................................................................

**8.1Metamodel Overview**
The SysML metamodel extends the KerML metamodel asspecified in the KerML specification [KerML].

- The SysML concrete syntax includes a textual notation (see8.2.2), which is generally distinct from that of
    KerML, though consistent on common elements (such as packages and expressions), and a complete
    graphical notation (see8.2.3).
- The SysML abstract syntax (see8.3) imports the KerML abstract syntax, reusing some KerML
    metaclasses directly, and further specializing most other KerML metaclasses.
- The SysML semantics (see8.4) are defined by relating the SysML abstract syntax to the semantic models
    in the Systems Model Library (seeClause 9), which is based on the Kernel Model Library from KerML,
    and providing syntactic transformations from SysML models to syntactically equivalent KerML models
    (including elements that are otherwise implicit in the SysML abstract syntax).
Throughout this clause, the names of elements from the SysML (and KerML) abstract syntax models appear in a
"code" font. Further:
1. Names of metaclasses appear exactly as in the abstract syntax, including capitalization, except possibly
with added pluralization. When used as English common nouns, e.g., "aUsage", "multiple
Subsettings", they refer to instances of the metaclass. E.g., "Usagescan be nested in otherUsages"
refers to instances of the metaclassUsagethat reside in models. This can be modified with the term
"metaclass" as necessary to refer to the metaclass itself instead of its instances, e.g., "TheUsagemetaclass
is contained in theDefinitionAndUsagepackage."
2. Names of properties of metaclasses, when used as English common nouns, e.g., “anownedUsage”,
“multiplenestedActions”, refer to values of the properties. This can be modified using the term
"metaproperty" as necessary to refer to the metaproperty itself instead of its values, e.g., "The
ownedUsagemetaproperty is contained in theDefinitionAndUsagepackage."
Similar stylistic conventions apply to text about SysML (and KerML) models, except that an " _italic code_ " front
is used.
1. Convention 1 above applies to SysML Definitions (e.g., _Action_ ), using "definition" (or a more
specialized term) instead of "metaclass" (e.g., "the action definition _Action_ ").
2. Convention 2 above applies to SysMLUsages(e.g, _actions_ ), using "usage" (or a more specialized term)
instead of "metaproperty" (e.g., "the action usage _actions_ ").

**8.2Concrete Syntax
8.2.1Concrete Syntax Overview**
_Concrete syntax_ specifies the how the language appears to modelers. They construct and reviewmodels shown
according to the concrete syntax. The SysML concrete syntax includes both a textual notation, described in8.2.2,
and a graphical notation, described in8.2.3. Various views of a SysML model may be rendered entirely using the
textual notation, entirely using the graphical notation, or using a combination of the two.

**8.2.2Textual Notation
8.2.2.1Textual Notation Overview**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 157**


**8.2.2.1.1EBNF Conventions**
The _grammar_ definition for the SysML textual concrete syntax defines how lexical tokens for an input text are
grouped in order to construct an abstract syntax representation of a model (see8.3). The concrete syntax grammar
definition uses an Extended Backus Naur Form (EBNF) notation (seeTable 26) that includes further notations to
describe how the concrete syntax maps to the abstract syntax (seeTable 27).
Productions in the grammar formally result in the synthesis of classes in the abstract syntax and the population of
their properties (seeTable 28). Productions may also be parameterized, with the parameters typed by abstract syntax
classes. Information passed in parameters during parsing allows a production to update the properties of the
provided abstract syntax elements as a side-effect of the parsing it specifies. Some productions only update the
properties of parameters, without synthesizing any new abstract syntax element.
**Table 26. EBNF Notation Conventions
Lexical element** LEXICAL
**Terminal element** 'terminal'
**Non-terminal element** NonterminalElement
**Sequential elements** Element1 Element2
**Alternative elements** Element1 | Element2
**Optional elements (zero or one)** Element?
**Repeated elements (zero or more)** Element *
**Repeated elements (one or more)** Element +
**Grouping** ( Elements ... )
**Table 27. Abstract Syntax Synthesis Notation
Property assignment** p = Element

```
Assign the result of parsing the
concrete syntaxElementto abstract
syntax propertyp.
List property construction p += Element
```
```
Add the result of parsing the
concrete syntaxElementto the
abstract syntax list propertyp.
Boolean property assignment p ?= Element
```
```
If the concrete syntaxElementis
parsed, then set the abstract Boolean
propertypto true.
```
```
Non-parsing assignment { p = value }{ p += value }
```
```
Assign (or add) the givenvalueto
the abstract syntax propertyp,
without parsing any input.The
valuemay be a literal or a reference
to another abstract syntax property.
The symbol "this" refers to the
element being synthesized.
```
```
Name resolution [QualifiedName]
```
```
Parse aQualifiedName, then
resolve that name to an Element
reference for use as a value in an
assignment as above.
```
**158 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Table 28. Grammar Production Definitions
```
```
Production definition NonterminalElement :AbstractSyntaxElement = ...
```
```
Define a production for the
NonterminalElementthat
synthesizes the
AbstractSyntaxElement. If the
NonterminalElementhas the
same name as the
AbstractSyntaxElement, then ":
AbstractSyntaxElement" may
be omitted.
```
```
Parameterized production
definition
```
```
NonterminalElement (p :
Type) :
AbstractSyntaxElement = ...
```
```
Define a production for the
NonterminalElementthat
synthesizes the
AbstractSyntaxElement, with a
parameter namedp, whosetypeis
an abstract syntax class.
```
**8.2.2.1.2Lexical Structure**
The lexical structure of the SysML textual notation is identical to that of the KerML textual notation [KerML],
except for the following two points.

1. The reserved keywords of SysML are the following.
    **about abstract accept action actor after alias all allocate allocationanalysis and as assign assert assoc assume at attribute bind binding block**
    **by calc case comment concern connect connection constraint decide defdefault defined dependency derived do doc else end entry enum event exhibit**
    **exit expose filter first flow for fork frame from hastype if implies importin include individual inout interface istype item join language loop merge**
    **message metadata nonunique not objective occurrence of or ordered outpackage parallel part perform port private protected public readonly**
    **redefines ref references render rendering rep require requirement returnsatisfy send snapshot specializes stakeholder state subject subsets**
    **succession then timeslice to transition until use variant variationverification verify via view viewpoint when while xor**
2. The set of special lexical terminals matching either certain keywords or their symbolic equivalents are the
    following in SysML.
    DEFINED_BY = ':' | 'defined' 'by'SPECIALIZES = ':>' | 'specializes'
    SUBSETS = ':>' | 'subsets'REFERENCES = '::>' | 'references'
    REDEFINES = ':>>' | 'redefines'
**8.2.2.2Elements and Relationships Textual Notation**
Identification : Element =( '<' declaredShortName = NAME '>' )?
( declaredName = NAME )?

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 159**


RelationshipBody : Relationship =';' | '{' ( ownedRelationship += OwnedAnnotation )* '}'

**8.2.2.3Dependencies Textual Notation**
Dependency =( ownedRelationship += PrefixMetadataAnnotation )*
'dependency' DependencyDeclarationRelationshipBody

DependencyDeclaration =( Identification 'from' )?
client += [QualifiedName] ( ',' client += [QualifiedName] )* 'to'supplier += [QualifiedName] ( ',' supplier += [QualifiedName] )*

**8.2.2.4Annotations Textual Notation
8.2.2.4.1Annotations**
Annotation =annotatedElement = [QualifiedName]

OwnedAnnotation : Annotation =annotatingElement = AnnotatingElement
{ ownedRelatedElement += annotatingElement }
AnnotatingMember : OwningMembership =ownedRelatedElement += AnnotatingElement

AnnotatingElement =Comment
| Documentation| TextualRepresentation
| MetadataFeature
**8.2.2.4.2Comments and Documentation**
Comment ='comment' Identification
( 'about' annotation += Annotation{ ownedRelationship += annotation }
( ',' annotation += Annotation{ ownedRelationship += annotation } )*
)?body = REGULAR_COMMENT

Documentation ='doc' Identification
body = REGULAR_COMMENT
**8.2.2.4.3Textual Representation**
TextualRepresentation =( 'rep' Identification )?
'language' language = STRING_VALUE body = REGULAR_COMMENT
**8.2.2.5Namespaces and Packages Textual Notation**

**160 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.2.2.5.1Packages**
RootNamespace : Namespace =PackageBodyElement*

Package =( ownedRelationship += PrefixMetadataMember )*
PackageDeclaration PackageBody
LibraryPackage =( isStandard ?= 'standard' ) 'library'
( ownedRelationship += PrefixMetadataMember )*PackageDeclaration PackageBody

PackageDeclaration : Package ='package' Identification

PackageBody : Package =';' | '{' PackageBodyElement* '}'

PackageBodyElement : Package =ownedRelationship += PackageMember
| ownedRelationship += ElementFilterMember| ownedRelationship += AliasMember
| ownedRelationship += Import
MemberPrefix : Membership =( visibility = VisibilityIndicator )?

PackageMember : OwningMembershipMemberPrefix
( ownedRelatedElement += DefinitionElement| ownedRelatedElement = UsageElement )

ElementFilterMember : ElementFilterMembership =MemberPrefix
'filter' ownedRelatedElement += OwnedExpression ';'
AliasMember : Membership =MemberPrefix
'alias' ( '<' memberShortName = NAME '>' )?( memberName = NAME )?
RelationshipBody'for' memberElement = [QualifiedName]
Import =( visibility = VisibilityIndicator )?
'import' ( isImportAll ?= 'all' )?( ImportedNamespace
| ImportedFilterPackage )RelationshipBody

ImportedNamespace : Import =( importedNamespace = [QualifiedName] )?
( importedMemberName = NAME | '*' )( '::' isRecursive ?= '**' )?

ImportedFilterPackage : Import :importedNamspace = FilterPackage

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 161**


{ ownedRelatedElement += FilterPackage }
FilterPackage : Package =ownedRelationship += FilterPackageImport
( ownedRelationship += FilterPackageMember )+
FilterPackageImport : Import =ImportedNamespace

FilterPackageMember : ElementFilterMembership ='[' ownedRelatedElement += OwnedExpression ']'
{ visibility = 'private' }
VisibilityIndicator : VisibilityKind ='public' | 'private' | 'protected'

**8.2.2.5.2Package Elements**
AnnotatingElement =Comment
| PrefixComment| Documentation
| TextualRepresentation| MetadataUsage

DefinitionElement : Element =Package
| LibraryPackage| AnnotatingElement
| Dependency| AttributeDefinition
| EnumerationDefinition| OccurrenceDefinition
| IndividualDefinition| ItemDefinition
| PartDefinition| ConnectionDefinition
| FlowConnectionDefinition| InterfaceDefinition
| PortDefinition| ActionDefinition
| CalculationDefinition| StateDefinition
| ConstraintDefinition| RequirementDefinition
| ConcernDefinition| StakeholderDefinition
| CaseDefinition| AnalysisCaseDefinition
| VerificationCaseDefinition| UseCaseDefinition
| ViewDefinition| ViewpointDefinition
| RenderingDefinition| MetadataDefinition
| ExtendedDefinition
UsageElement : Usage =NonOccurrenceUsageElement
| OccurrenceUsageElement

**162 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.2.2.6Definition and Usage Textual Notation
8.2.2.6.1Definitions**
BasicDefinitionPrefix =isAbstract ?= 'abstract' | isVariation ?= 'variation'

DefinitionExtensionKeyword : Definition =ownedRelationship += PrefixMetadataMember

DefinitionPrefix : Definition =BasicDefinitionPrefix? DefinitionExtensionKeyword*

Definition =DefinitionDeclaration DefinitionBody

DefinitionDeclaration : DefinitionIdentification SubclassificationPart?

DefinitionBody : Type =';' | '{' DefinitionBodyItem* '}'

DefinitionBodyItem : Type =ownedRelationship += DefinitionMember
| ownedRelationship += VariantUsageMember| ownedRelationship += NonOccurrenceUsageMember
| ( ownedRelationship += SourceSuccessionMember )?ownedRelationship += OccurrenceUsageMember
| ownedRelationship += AliasMember| ownedRelationship += Import

DefinitionMember : OwningMembership =MemberPrefix
ownedRelatedElement += DefinitionElement
VariantUsageMember : VariantMembership =MemberPrefix 'variant'
ownedVariantUsage = VariantUsageElement
NonOccurrenceUsageMember : FeatureMembership =MemberPrefix
ownedRelatedElement += NonOccurrenceUsageElement
OccurrenceUsageMember : FeatureMembership =MemberPrefix
ownedRelatedElement += OccurrenceUsageElement
StructureUsageMember : FeatureMembership =MemberPrefix
ownedRelatedElement += StructureUsageElement
BehaviorUsageMember : FeatureMembership =MemberPrefix
ownedRelatedElement += BehaviorUsageElement
**8.2.2.6.2Usages**
FeatureDirection : FeatureDirectionKind ='in' | 'out' | 'inout'

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 163**


RefPrefix : Usage =( direction = FeatureDirection )?
( isAbstract ?= 'abstract' | isVariation ?= 'variation')?( isReadOnly ?= 'readonly' )?
( isDerived ?= 'derived' )?( isEnd ?= 'end' )?

BasicUsagePrefix : Usage =RefPrefix
( isReference ?= 'ref' )?
UsageExtensionKeyword : Usage =ownedRelationship += PrefixMetadataMember

UsagePrefix : Usage =BasicUsagePrefix UsageExtensionKeyword*

Usage =UsageDeclaration UsageCompletion

UsageDeclaration : Usage =Identification FeatureSpecializationPart?

UsageCompletion : Usage =ValuePart? UsageBody

UsageBody : Usage =DefinitionBody

ValuePart : Feature =ownedRelationship += FeatureValue

FeatureValue =( '='
| isInitial ?= ':='| isDefault ?= 'default' ( '=' | isInitial ?= ':=' )?
)ownedRelatedElement += OwnedExpression

**8.2.2.6.3Reference Usages**
DefaultReferenceUsage : ReferenceUsage =RefPrefix Usage

ReferenceUsage =RefPrefix 'ref' Usage

VariantReference : ReferenceUsage =ownedRelationship += OwnedReferenceSubsetting
FeatureSpecialization* UsageBody
**8.2.2.6.4Body Elements**
NonOccurrenceUsageElement : Usage =DefaultReferenceUsage
| ReferenceUsage| AttributeUsage
| EnumerationUsage| BindingConnectorAsUsage
| SuccessionAsUsage

**164 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


| ExtendedUsage
OccurrenceUsageElement : Usage =StructureUsageElement | BehaviorUsageElement

StructureUsageElement : Feature =OccurrenceUsage
| IndividualUsage| PortionUsage
| EventOccurrenceUsage| ItemUsage
| PartUsage| ViewUsage
| RenderingUsage| PortUsage
| ConnectionUsage| InterfaceUsage
| AllocationUsage| Message
| FlowConnectionUsage| SuccessionFlowConnectionUsage

BehaviorUsageElement : Usage =ActionUsage
| CalculationUsage| StateUsage
| ConstraintUsage| RequirementUsage
| ConcernUsage| CaseUsage
| AnalysisCaseUsage| VerificationCaseUsage
| UseCaseUsage| ViewpointUsage
| PerformActionUsage| ExhibitStateUsage
| IncludeUseCaseUsage| AssertConstraintUsage
| SatisfyRequirementUsage
VariantUsageElement : Usage =VariantReference
| ReferenceUsage| AttributeUsage
| BindingConnector| Succession
| OccurrenceUsage| IndividualUsage
| PortionUsage| EventOccurrenceUsage
| ItemUsage| PartUsage
| ViewUsage| RenderingUsage
| PortUsage| ConnectionUsage
| InterfaceUsage| AllocationUsage
| Message| FlowConnectionUsage

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 165**


```
| SuccessionFlowConnectionUsage| BehaviorUsageElement
```
**8.2.2.6.5Specialization**
SubclassificationPart : Classifier =SPECIALIZES ownedRelationship += OwnedSubclassification
( ',' ownedRelationship += OwnedSubclassification )*
OwnedSubclassification : Subclassification =superClassifier = [QualifiedName]

FeatureSpecializationPart : Feature =FeatureSpecialization+ MultiplicityPart? FeatureSpecialization*
| MultiplicityPart FeatureSpecialization*
FeatureSpecialization : Feature =Typings | Subsettings | References | Redefinitions

Typings : Feature =TypedBy ( ',' ownedRelationship += FeatureTyping )*

TypedBy : Feature =DEFINED_BY ownedRelationship += FeatureTyping

FeatureTyping =OwnedFeatureTyping | ConjugatePortTyping

OwnedFeatureTyping : FeatureTyping =type = [QualifiedName]
| type = OwnedFeatureChain{ ownedRelatedElement += type }

Subsettings : Feature =Subsets ( ',' ownedRelationship += OwnedSubsetting )*

Subsets : Feature =SUBSETS ownedRelationship += OwnedSubsetting

OwnedSubsetting : Subsetting =subsettedFeature = [QualifiedName]
| subsettedFeature = OwnedFeatureChain{ ownedRelatedElement += subsettedFeature }

References : Feature =REFERENCES ownedRelationship += OwnedReferenceSubsetting

OwnedReferenceSubsetting : ReferenceSubsetting =referencedFeature = [QualifiedName]
| referencedFeature = OwnedFeatureChain{ ownedRelatedElement += referenceFeature }

Redefinitions : Feature =Redefines ( ',' ownedRelationship += OwnedRedefinition )*

Redefines : Feature =REDEFINES ownedRelationship += OwnedRedefinition

OwnedRedefinition : Redefinition =redefinedFeature = [QualifiedName]

**166 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
| redefinedFeature = OwnedFeatureChain{ ownedRelatedElement += redefinedFeature }
```
OwnedFeatureChain : Feature =ownedRelationship += OwnedFeatureChaining
( '.' ownedRelationship += OwnedFeatureChaining )+
OwnedFeatureChaining : FeatureChaining =chainingFeature = [QualifiedName]

**8.2.2.6.6Multiplicity**
MultiplicityPart : Feature =ownedRelationship += OwnedMultiplicity
| ( ownedRelationship += OwnedMultiplicity )?( isOrdered ?= 'ordered' ( { isUnique = false } 'nonunique' )?
| { isUnique = false } 'nonunique' ( isOrdered ?= 'ordered' )? )
OwnedMultiplicity : OwningMembership =ownedRelatedElement += MultiplicityRange

MultiplicityRange ='[' ( ownedRelationship += MultiplicityExpressionMember '..' )?
ownedRelationship += MultiplicityExpressionMember ']'
MultiplicityExpressionMember : OwningMembership =ownedRelatedElement += ( LiteralExpression | FeatureReferenceExpression )

**8.2.2.7Attributes Textual Notation**
AttributeDefinition : AttributeDefinition =DefinitionPrefix 'attribute' 'def' Definition

AttributeUsage : AttributeUsage =UsagePrefix 'attribute' Usage

**8.2.2.8Enumerations Textual Notation**
EnumerationDefinition ='enum' 'def' DefinitionDeclaration EnumerationBody

EnumerationBody : EnumerationDefinition =';'
| '{' ( ownedRelationship += AnnotatingMember| ownedRelationship += EnumerationUsageMember )*
'}'
AnnotatingMember : OwningMembership =ownedMemberElement = AnnotatingElement

EnumerationUsageMember : VariantMembership =MemberPrefix ownedRelatedElement += EnumeratedValue

EnumeratedValue : EnumerationUsage ='enum'? Usage

EnumerationUsage : EnumerationUsage =UsagePrefix 'enum' Usage

**8.2.2.9Occurrences Textual Notation**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 167**


**8.2.2.9.1Occurrence Definitions**
OccurrenceDefinitionPrefix : OccurrenceDefinition =BasicDefinitionPrefix?
( isIndividual ?= 'individual' )?DefinitionExtensionKeyword*

OccurrenceDefinition =OccurrenceDefinitionPrefix 'occurrence' 'def' Definition

IndividualDefinition : OccurrenceDefinition =BasicDefinitionPrefix? isIndividual ?= 'individual'
DefinitionExtensionKeyword* 'def' Definition
**8.2.2.9.2Occurrence Usages**
OccurrenceUsagePrefix : OccurrenceUsage =BasicUsagePrefix
( isIndividual ?= 'individual' )?( portionKind = PortionKind )?
UsageExtensionKeyword*
OccurrenceUsage =OccurrenceUsagePrefix 'occurrence' Usage

IndividualUsage : OccurrenceUsage =BasicUsagePrefix isIndividual ?= 'individual'
UsageExtensionKeyword* Usage
PortionUsage : OccurrenceUsage =BasicUsagePrefix ( isIndividual ?= 'individual' )?
portionKind = PortionKindUsageExtensionKeyword* Usage

PortionKind ='snapshot' | 'timeslice'

EventOccurrenceUsage =OccurrenceUsagePrefix 'event'
( ownedRelationship += OwnedReferenceSubsettingFeatureSpecializationPart?
| 'occurrence' UsageDeclaration? )UsageCompletion

**8.2.2.9.3Occurrence Successions**
SourceSuccessionMember : FeatureMembership ='then' ownedRelatedElement + SourceSuccession

SourceSuccession : SuccessionAsUsage =ownedRelationship += SourceEndMember

SourceEndMember : EndFeatureMembership =ownedRelatedElement + SourceEnd

SourceEnd : Feature =( ownedRelationship += OwnedMultiplicity )?

**168 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.2.2.10Items Textual Notation**
ItemDefinition =OccurrenceDefinitionPrefix
'item' 'def' Definition
ItemUsage =OccurrenceUsagePrefix 'item' Usage

**8.2.2.11Parts Textual Notation**
PartDefinition =OccurrenceDefinitionPrefix 'part' 'def' Definition

PartUsage =OccurrenceUsagePrefix 'part' Usage

**8.2.2.12Ports Textual Notation**
PortDefinition =DefinitionPrefix 'port' 'def' Definition
ownedRelationship += ConjugatedPortDefinitionMember{ conjugatedPortDefinition.ownedPortConjugator.

_(See Note 1)_ originalPortDefinition = this }
ConjugatedPortDefinitionMember : OwningMembership =ownedRelatedElement += ConjugatedPortDefinition

ConjugatedPortDefinition =ownedRelationship += PortConjugation

PortConjugation ={}

PortUsage =OccurrenceUsagePrefix 'port' Usage

ConjugatedPortTyping : ConjugatedPortTyping ='~' originalPortDefinition = ~[QualifiedName]
_(See Note 2)_
**Notes**

1. Even though it is not explicitly represented in the text, aPortDefinitionis always parsed as containing
    a nestedConjugatedPortDefinitionwith aPortDefinitionRelationshippointing back to the
    containingPortDefinition. The abstract syntax forConjugatedPortDefinitionsets its
    effectiveNameto the name of itsoriginalPortDefinitionwith the symbol~prepended to it (see
    8.3.12.2). (See also8.4.8.1.)
2. The notation~[QualifiedName]indicates that aQualifiedNameshall be parsed from the input text,
    but that it shall be resolved as if it was the qualified name constructed as follows:
       ◦ Extract the last segment name of the givenQualifiedNameand prepend the symbol~to it.
       ◦ Append the name so constructed to the end of the entire originalQualifiedName.
    For example, if theConjugatedPortTypingis~A::B::C, then the givenQualifiedNameisA::B::C,
    and ~[QualifiedName] is resolved asA::B::C::'~C'. Alternatively, a conforming tool may first resolve
    the givenQualifiedNameas usual to aPortDefinitionand then use the
    conjugatedPortDefinitionof thisPortDefinitionas the resolution of~[QualifiedName].

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 169**


**8.2.2.13Connections Textual Notation
8.2.2.13.1Connection Definition and Usage**
ConnectionDefinition =OccurrenceDefinitionPrefix 'connection' 'def' Definition

ConnectionUsage =OccurrenceUsagePrefix
( 'connection' UsageDeclaration( 'connect' ConnectorPart )?
| 'connect' ConnectorPart )UsageBody

ConnectorPart : ConnectionUsage =BinaryConnectorPart | NaryConnectorPart

BinaryConnectorPart : ConnectionUsage =ownedRelationship += ConnectorEndMember 'to'
ownedRelationship += ConnectorEndMember
NaryConnectorPart : ConnectionUsage ='(' ownedRelationship += ConnectorEndMember ','
ownedRelationship += ConnectorEndMember( ',' ownedRelationship += ConnectorEndMember )* ')'

ConnectorEndMember : EndFeatureMembership :ownedRelatedElement += ConnectorEnd

ConnectorEnd : Feature =( declaredName = NAME REFERENCES )?
ownedRelationship += OwnedReferenceSubsetting( ownedRelationship += OwnedMultiplicity )?

**8.2.2.13.2Binding Connectors**
BindingConnectorAsUsage =UsagePrefix ( 'binding' UsageDeclaration )?
'bind' ownedRelationship += ConnectorEndMember'=' ownedRelationship += ConnectorEndMember
UsageBody
**8.2.2.13.3Successions**
SuccessionAsUsage =UsagePrefix ( 'succession' UsageDeclaration )?
'first' s.ownedRelationship += ConnectorEndMember'then' s.ownedRelationship += ConnectorEndMember
UsageBody
**8.2.2.13.4Messages and Flow Connections**
FlowConnectionDefinition :OccurrenceDefinitionPrefix 'flow' 'def' Definition

Message : FlowConnectionUsage =OccurrenceUsagePrefix 'message'
MessageDeclaration DefinitionBody{ isAbstract = true }

**170 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


MessageDeclaration : FlowConnectionUsage =UsageDeclaration ValuePart?
( 'of' ownedRelationship += ItemFeatureMember )?( 'from' ownedRelationship += MessageEventMember
)?'to' ownedRelationship += MessageEventMember
| ownedRelationship += MessageEventMember 'to'ownedRelationship += MessageEventMember

MessageEventMember : ParameterMembership =ownedRelatedElement += MessageEvent

MessageEnd : EventOccurrenceUsage =ownedRelationship += OwnedReferenceSubsetting

FlowConnectionUsage =OccurrenceUsagePrefix 'flow'
FlowConnectionDeclaration DefinitionBody
SuccessionFlowConnectionUsage =OccurrenceUsagePrefix 'succession' 'flow'
FlowConnectionDeclaration DefinitionBody
FlowConnectionDeclaration : FlowConnectionUsage =UsageDeclaration ValuePart?
( 'of' ownedRelationship += FlowPayloadFeatureMember )?( 'from' ownedRelationship += FlowEndMember
| ownedRelationship += FlowEndMember 'to''to' ownedRelationship += FlowEndMember )?
ownedRelationship += FlowEndMember
FlowPayloadFeatureMember : FeatureMembership =ownedRelatedElement += ItemFeature

FlowPayloadFeature : ItemFeature =PayloadFeature

PayloadFeature : Feature =Identification? PayloadFeatureSpecializationPart

| ownedRelationship += OwnedFeatureTypingValuePart?
| ownedRelationship += OwnedMultiplicity( ownedRelationship += OwnedMultiplicity )?
ownedRelationship += OwnedFeatureTyping
PayloadFeatureSpecializationPart : Feature =( -> FeatureSpecialization )+ MultiplicityPart?

| MultiplicityPart FeatureSpecialization+FeatureSpecialization*
FlowEndMember : EndFeatureMembership =ownedRelatedElement += ItemFlowEnd

FlowEnd : ItemFlowEnd =( ownedRelationship += FlowEndSubsetting )?
ownedRelationship += FlowFeatureMember
FlowEndSubsetting : ReferenceSubsetting =referencedFeature = [QualifiedName]
| referencedFeature = FeatureChainPrefix

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 171**


{ ownedRelatedElement += referencedFeature }
FeatureChainPrefix : Feature =( ownedRelationship += OwnedFeatureChaining '.' )+
ownedRelationship += OwnedFeatureChaining '.'
FlowFeatureMember : FeatureMembership =ownedRelatedElement += FlowFeature

FlowFeature : ReferenceUsage =ownedRelationship += FlowFeatureRedefinition

FlowFeatureRefefinition : Redefinition =redefinedFeature = [QualifiedName]

**8.2.2.14Interfaces Textual Notation
8.2.2.14.1Interface Definitions**
InterfaceDefinition =OccurrenceDefinitionPrefix 'interface' 'def'
DefinitionDeclaration InterfaceBody
InterfaceBody : Type =';' | '{' InterfaceBodyItem* '}'

InterfaceBodyItem : Type =ownedRelationship += DefinitionMember
| ownedRelationship += VariantUsageMember| ownedRelationship += InterfaceNonOccurrenceUsageMember
| ( ownedRelationship += SourceSuccessionMember )?ownedRelationship += InterfaceOccurrenceUsageMember
| ownedRelationship += AliasMember| ownedRelationship += Import

InterfaceNonOccurrenceMember : FeatureMembership =MemberPrefix ownedRelatedElement += InterfaceNonOccurrenceUsageElement

InterfaceNonOccurrenceUsageElement : Usage =ReferenceUsage
| AttributeUsage| EnumerationUsage
| BindingConnector| Succession

InterfaceOccurrenceUsageMember : FeatureMembership =MemberPrefix ownedRelatedElement += InterfaceOccurrenceUsageElement

InterfaceOccurrenceUsageElement : Feature =DefaultInterfaceEnd | StructureUsageElement | BehaviorUsageElement

DefaultInterfaceEnd : PortUsage =( direction = FeatureDirection )?
( isAbstract ?= 'abstract' | isVariation ?= 'variation')?isEnd ?= 'end' Usage

**8.2.2.14.2Interface Usages**
InterfaceUsage =OccurrenceUsagePrefix 'interface'

**172 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


InterfaceUsageDeclaration InterfaceBody
InterfaceUsageDeclaration : InterfaceUsage =UsageDeclaration ( 'connect' InterfacePart )?
| InterfacePart
InterfacePart : InterfaceUsage =BinaryInterfacePart | NaryInterfacePart

BinaryInterfacePart : InterfaceUsage =ownedRelationship += InterfaceEndMember 'to'
ownedRelationship += InterfaceEndMember
NaryInterfacePart : InterfaceUsage ='(' ownedRelationship += InterfaceEndMember ','
ownedRelationship += InterfaceEndMember( ',' ownedRelationship += InterfaceEndMember )* ')'

InterfaceEndMember : EndFeatureMembership =ownedRelatedElement += InterfaceEnd

InterfaceEnd : PortUsage :( declaredName = Name REFERENCES )?
ownedRelationship += OwnedReferenceSubsetting( ownedRelationship += OwnedMultiplicity )?

**8.2.2.15Allocations Textual Notation**
AllocationDefinition =OccurrenceDefinitionPrefix 'allocation' 'def' Definition

AllocationUsage =OccurrenceUsagePrefix
AllocationUsageDeclaration UsageBody
AllocationUsageDeclaration : AllocationUsage ='allocation' UsageDeclaration

| 'allocate' ConnectorPart( 'allocate' ConnectorPart )? )
**8.2.2.16Actions Textual Notation
8.2.2.16.1Action Definitions**
ActionDefinition =OccurrenceDefinitionPrefix 'action' 'def'
DefinitionDeclaration ActionBody
ActionBody : Type =';' | '{' ActionBodyItem* '}'

ActionBodyItem : Type =NonBehaviorBodyItem
| ownedRelationship += InitialNodeMember( ownedRelationship += ActionTargetSuccessionMember )*
| ( ownedRelationship += SourceSuccessionMember )?ownedRelationsuip += ActionBehaviorMember
| ownedRelationship += GuardedSuccessionMember( ownedRelationship += ActionTargetSuccessionMember )*

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 173**


NonBehaviorBodyItem =ownedRelationship += Import
| ownedRelationship += AliasMember| ownedRelationship += DefinitionMember
| ownedRelationship += VariantUsageMember| ownedRelationship += NonOccurrenceUsageMember
| ( ownedRelationship += SourceSuccessionMember )?ownedRelationship += StructureUsageMember

ActionBehaviorMember : FeatureMembership =BehaviorUsageMember | ActionNodeMember

InitialNodeMember : FeatureMembership =MemberPrefix 'first' memberFeature = [QualifiedName]
RelationshipBody
ActionNodeMember : FeatureMembership =MemberPrefix ownedRelatedElement += ActionNode

ActionTargetSuccessionMember : FeatureMembership =MemberPrefix ownedRelatedElement += ActionTargetSuccession

GuardedSuccessionMember : FeatureMembership =MemberPrefix ownedRelatedElement += GuardedSuccession

**8.2.2.16.2Action Usages**
ActionUsage =OccurrenceUsagePrefix 'action'
ActionUsageDeclaration ActionBody
ActionUsageDeclaration : ActionUsage =UsageDeclaration ValuePart?

PerformActionUsage =OccurrenceUsagePrefix 'perform'
PerformActionUsageDeclaration ActionBody
PerformActionUsageDeclaration : PerformActionUsage =( ownedRelationship += OwnedReferenceSubsetting

| 'action' UsageDeclaration )FeatureSpecializationPart?
ValuePart?
ActionNode : ActionUsage =ControlNode
| AssignmentNode| SendNode | AcceptNode
| IfNode | WhileLoopNode | ForLoopNode
ActionNodeUsageDeclaration : ActionUsage ='action' UsageDeclaration?

ActionNodePrefix : ActionUsage =OccurrenceUsagePrefix ActionNodeUsageDeclaration?

**8.2.2.16.3Control Nodes**
ControlNode =MergeNode | DecisionNode | JoinNode| ForkNode

**174 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ControlNodePrefix : OccurrenceUsage =RefPrefix
( isIndividual ?= 'individual )?( portionKind = PortionKind )?

MergeNode =ControlNodePrefix
isComposite ?= 'merge' UsageDeclarationActionNodeBody

DecisionNode =ControlNodePrefix
isComposite ?= 'decide' UsageDeclarationActionNodeBody

JoinNode =ControlNodePrefix
isComposite ?= 'join' UsageDeclarationActionNodeBody

ForkNode =ControlNodePrefix
isComposite ?= 'fork' UsageDeclarationActionNodeBody

ActionNodeBody : ControlNode =';' | '{' ( ownedRelationship += AnnotatingMember )* '}'

**8.2.2.16.4Send and Accept Action Usages**
AcceptNode : AcceptActionUsage =OccurrenceUsagePrefix
AcceptNodeDeclaration ActionBody
AcceptNodeDeclaration : AcceptActionUsage =ActionNodeUsageDeclaration?
'accept' AcceptParameterPart
AcceptParameterPart : AcceptActionUsage =ownedRelationship += PayloadParameterMember
( 'via' ownedRelationship += NodeParameterMember| ownedRelationship += EmptyParameterMember )

PayloadParameterMember : ParameterMembership =ownedRelatedElement += PayloadParameter

PayloadParameter : ReferenceUsage =PayloadFeature
| Identification PayloadFeatureSpecializationPart?TriggerValuePart

TriggerValuePart : Feature =ownedRelationship += TriggerFeatureValue

TriggerFeatureValue : FeatureValue =ownedRelatedElement += TriggerExpression

TriggerExpression : TriggerInvocationExpression =kind = ( 'at | 'after' )

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 175**


| kind = "when'ownedRelationship += OwnedExpressionMember
ownedRelationship += ChangeExpressionMember
ChangeExpressionMember : FeatureMembership =ownedRelatedElement += ChangeExpression

ChangeExpression : Expression =ownedRelationship += ChangeExpressionMember

ChangeResultExpressionMember : ResultExpressionMember =ownedRelatedElement += OwnedExpression

SendNode : SendActionUsage =OccurrenceUsagePrefix
SendNodeDeclaration ActionBody
SendNodeDeclaration : SendActionUsage =ActionNodeUsageDeclaration?
'send' ownedRelationship += NodeParameterMember( 'via' ownedRelationship += NodeParameterMember
| ownedRelationship += EmptyParameterMember )( 'to' ownedRelationship += NodeParameterMember
| ownedRelationship += EmptyParameterMember )
NodeParameterMember : ParameterMembership =ownedRelatedElement += NodeParameter

NodeParameter : ReferenceUsage =ownedRelationship += FeatureBinding

FeatureBinding : FeatureValue =ownedRelatedElement += OwnedExpression

EmptyParameterMember : ParameterMembership =ownedRelatedElement += EmptyUsage

EmptyUsage : ReferenceUsage ={}

**8.2.2.16.5Assignment Action Usages**
AssignmentNode : AssignmentActionUsage =OccurrenceUsagePrefix
AssignmentNodeDeclaration ActionBody
AssignmentNodeDeclaration: ActionUsage =( ActionNodeUsageDeclaration )? 'assign'
ownedRelationship += AssignmentTargetMemberownedRelationship += FeatureChainMember ':='
ownedRelationship += NodeParameterMember
AssignmentTargetMember : ParameterMembership =ownedRelatedElement += AssignmentTargetParameter

AssignmentTargetParameter : ReferenceUsage =( ownedRelationship += AssignmentTargetBinding '.' )?

AssignmentTargetBinding : FeatureValue =ownedRelatedElement += NonFeatureChainPrimaryExpression

**176 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


FeatureChainMember : Membership =memberElement = [QualifiedName]
| OwnedFeatureChainMember
OwnedFeatureChainMember : OwnedMembership =ownedRelatedElement += FeatureChain

**8.2.2.16.6Structured Control Action Usages**
IfNode : IfActionUsage =ActionNodePrefix
'if' ownedRelationship += ExpressionParameterMemberownedRelationship += ActionBodyParameterMember
( 'else' ownedRelationship +=( ActionBodyParameterMember | IfNodeParameterMember ) )?

ExpressionParameterMember : ParameterMembership =ownedRelatedElement += OwnedExpression

ActionBodyParameterMember : ParameterMembership =ownedRelatedElement += ActionBodyParameter

ActionBodyParameter : ActionUsage =( 'action' UsageDeclaration? )?
'{' ActionBodyItem* '}'
IfNodeParameterMember : ParameterMembership =ownedRelatedElement += IfNode

WhileLoopNode : WhileLoopActionUsage =ActionNodePrefix
( 'while' ownedRelationship += ExpressionParameterMember| 'loop' ownedRelationship += EmptyParameterMember
)ownedRelationship += ActionBodyParameterMember
( 'until' ownedRelationship += ExpressionParameterMember ';' )?
ForLoopNode : ForLoopActionUsage =ActionNodePrefix
'for' ownedRelationship += ForVariableDeclarationMember'in' ownedRelationship += NodeParameterMember
ownedRelationship += ActionBodyParameterMember
ForVariableDeclarationMember : FeatureMembership =ownedRelatedElement += UsageDeclaration

ForVariableDeclaration : ReferenceUsage =UsageDeclaration

**8.2.2.16.7Action Successions**
ActionTargetSuccession : Feature =( TargetSuccession | GuardedTargetSuccession | DefaultTargetSuccession )
UsageBody
TargetSuccession : SuccessionAsUsage =ownedRelationship += SourceEndMember
ownedRelationship += ConnectorEndMember

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 177**


GuardedTargetSuccession : TransitionUsage =ownedRelationship += GuardExpressionMember
'then' ownedRelationship += TransitionSuccessionMember
DefaultTargetSuccession : TransitionUsage ='else' ownedRelationship += TransitionSuccessionMember

GuardedSuccession : TransitionUsage =( 'succession' UsageDeclaration )?
'first' ownedRelationship += FeatureChainMemberownedRelationship += GuardExpressionMember
'then' ownedRelationship += TransitionSuccessionMemberUsageBody

**8.2.2.17States Textual Notation
8.2.2.17.1State Definitions**
StateDefinition =OccurrenceDefinitionPrefix 'state' 'def'
DefinitionDeclaration StateDefBody
StateDefBody : StateDefinition =';'
| ( isParallel ?= 'parallel' )?'{' StateBodyItem* '}'

StateBodyItem : Type =NonBehaviorBodyItem
| ( ownedRelationsup += SourceSuccessionMember )?ownedRelationship += BehaviorUsageMember
| ownedRelationship += TransitionUsageMember( ownedRelationship += TargetTransitionUsageMember )*
| ownedRelationship += EntryActionMember( ownedRelationship += EntryTransitionMember )*
| ownedRelationship += DoActionMember| ownedRelationship += ExitActionMember

EntryActionMember : StateSubactionMembership =MemberPrefix kind = 'entry'
ownedRelatedElement += StateActionUsage
DoActionMember : StateSubactionMembership =MemberPrefix kind = 'do'
ownedRelatedElement += StateActionUsage
ExitActionMember : StateSubactionMembership =MemberPrefix kind = 'exit'
ownedRelatedElement += StateActionUsage
EntryTransitionMember : FeatureMembership :MemberPrefix
( ownedRelatedElement += GuardedTargetSuccession| 'then' ownedRelatedElement += TargetSuccession
) ';'
StateActionUsage : ActionUsage =EmptyActionUsage ';'
| StatePerformActionUsage

**178 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


| StateAcceptActionUsage| StateSendActionUsage
| StateAssignmentActionUsage
EmptyActionUsage : ActionUsage ={}

StatePerformActionUsage : PerformActionUsage =PerformActionUsageDeclaration ActionBody

StateAcceptActionUsage : AcceptActionUsage =AcceptNodeDeclaration ActionBody

StateSendActionUsage : SendActionUsageSendNodeDeclaration ActionBody

StateAssignmentActionUsage : AssignmentActionUsage =AssignmentNodeDeclaration ActionBody

TransitionUsageMember : FeatureMembership =MemberPrefix ownedRelatedElement += TransitionUsage

TargetTransitionUsageMember : FeatureMembership =MemberPrefix ownedRelatedElement += TargetTransitionUsage

**8.2.2.17.2State Usages**
StateUsage =OccurrenceUsagePrefix 'state'
ActionUsageDeclaration StateUsageBody
StateUsageBody : StateUsage =';'
| ( isParallel ?= 'parallel' )?'{' StateBodyItem* '}'

ExhibitStateUsage =OccurrenceUsagePrefix 'exhibit'
( ownedRelationship += OwnedReferenceSubsettingFeatureSpecializationPart?
| 'state' UsageDeclaration )ValuePart? StateUsageBody

**8.2.2.17.3Transition Usages**
TransitionUsage ='transition' ( UsageDeclaration 'first' )?
ownedRelationship += FeatureChainMemberownedRelationship += EmptyParameterMember
( ownedRelationship += EmptyParameterMemberownedRelationship += TriggerActionMember )?
( ownedRelationship += GuardExpressionMember )?( ownedRelationship += EffectBehaviorMember )?
'then' ownedRelationship += TransitionSuccessionMemberActionBody

TargetTransitionUsage : TransitionUsage =ownedRelationship += EmptyParameterMember
( 'transition'( ownedRelationship += EmptyParameterMember

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 179**


```
( ownedRelationship += GuardExpressionMember )?ownedRelationship += TriggerActionMember )?
| ownedRelationship += EmptyParameterMember( ownedRelationship += EffectBehaviorMember )?
ownedRelationship += TriggerActionMember( ownedRelationship += GuardExpressionMember )?
| ownedRelationship += GuardExpressionMember( ownedRelationship += EffectBehaviorMember )?
)?( ownedRelationship += EffectBehaviorMember )?
'then' ownedRelationship += TransitionSuccessionMemberActionBody
```
TriggerActionMember : TransitionFeatureMembership ='accept' { kind = 'trigger' } ownedRelatedElement += TriggerAction

TriggerAction : AcceptActionUsage =AcceptParameterPart

GuardExpressionMember : TransitionFeatureMembership ='if' { kind = 'guard' } ownedRelatedElement += OwnedExpression

EffectBehaviorMember : TransitionFeatureMembership ='do' { kind = 'effect' } ownedRelatedElement += EffectBehaviorUsage

EffectBehaviorUsage : ActionUsage =EmptyActionUsage
| TransitionPerformActionUsage| TransitionAcceptActionUsage
| TransitionSendActionUsage| TransitionAssignmentActionUsage

TransitionPerformActionUsage : PerformActionUsage =PerformActionDeclaration ( '{' ActionBodyItem* '}' )?

TransitionAcceptActionUsage : AcceptActionUsage =AcceptNodeDeclaration ( '{' ActionBodyItem* '}' )?

TransitionSendActionUsage : SendActionUsage =SendNodeDeclaration ( '{' ActionBodyItem* '}' )?

TransitionAssignmentActionUsage : AssignmentActionUsage =AssignmentNodeDeclaration ( '{' ActionBodyItem* '}' )?

TransitionSuccessionMember : OwningMembership =ownedRelatedElement += TransitionSuccession

TransitionSuccession : Succession =ownedRelationship += EmptyEndMember
ownedRelationship += ConnectorEndMember
EmptyEndMember : EndFeatureMembership =ownedRelatedElement += EmptyFeature

EmptyFeature : Feature ={}

**8.2.2.18Calculations Textual Notation**

**180 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.2.2.18.1Calculation Definitions**
CalculationDefinition =OccurrenceDefinitionPrefix 'calc' 'def'
DefinitionDeclaration CalculationBody
CalculationBody : Type =';' | '{' CalculationBodyPart '}'

CalculationBodyPart : Type =CalculationBodyItem*
( ownedRelationship += ResultExpressionMember )?
CalculationBodyItem : Type =ActionBodyItem
| ownedRelationship += ReturnParameterMember
ReturnParameterMember : ReturnParameterMembership =MemberPrefix? 'return' ownedRelatedElement += UsageElement

ResultExpressionMember : ResultExpressionMembership =MemberPrefix? ownedRelatedElement += OwnedExpression

**8.2.2.18.2Calculation Usages**
CalculationUsage : CalculationUsage =OccurrenceUsagePrefix 'calc'
CalculationUsageDeclaration CalculationBody
CalculationUsageDeclaration : Step =UsageDeclaration ValuePart?

**8.2.2.19Constraints Textual Notation**
ConstraintDefinition =OccurrenceDefinitionPrefix 'constraint' 'def'
DefinitionDeclaration CalculationBody
ConstraintUsage =OccurrenceUsagePrefix 'constraint'
CalculationUsageDeclaration CalculationBody
AssertConstraintUsage =OccurrenceUsagePrefix 'assert' ( isNegated ?= 'not' )?
( ownedRelationship += OwnedReferenceSubsettingFeatureSpecializationPart?
| 'constraint' UsageDeclaration )CalculationBody

**8.2.2.20Requirements Textual Notation
8.2.2.20.1Requirement Definitions**
RequirementDefinition =OccurrenceDefinitionPrefix 'requirement' 'def'
DefinitionDeclaration RequirementBody?
RequirementBody : Type =';' | '{' RequirementBodyItem* '}'

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 181**


RequirementBodyItem : Type =DefinitionBodyItem
| ownedRelationship += SubjectMember| ownedRelationship += RequirementConstraintMember
| ownedRelationship += FramedConcernMember| ownedRelationship += RequirementVerificationMember
| ownedRelationship += ActorMember| ownedRelationship += StakeholderMember

SubjectMember : SubjectMembership =MemberPrefix ownedRelatedElement += SubjectUsage

SubjectUsage : ReferenceUsage ='subject' UsageExtensionKeyword* Usage

RequirementConstraintMember : RequirementConstraintMembership =MemberPrefix? RequirementKind
ownedRelatedElement += RequirementConstraintUsage
RequirementKind : RequirementConstraintMembership ='assume' { kind = 'assumption' }
| 'require' { kind = 'requirement' }
RequirementConstraintUsage : ConstraintUsage =ownedRelationship += OwnedReferenceSubsetting

```
| ( UsageExtensionKeyword* 'constraint'FeatureSpecializationPart? RequirementBody
| UsageExtensionKeyword+ )CalculationUsageDeclaration CalculationBody
```
FramedConcernMember : FramedConcernMembership =MemberPrefix? 'frame'
ownedRelatedElement += FramedConcernUsage
FramedConcernUsage : ConcernUsage =ownedRelationship += OwnedReferenceSubsetting

```
| ( UsageExtensionKeyword* 'concern'FeatureSpecializationPart? RequirementBody
| UsageExtensionKeyword+ )CalculationUsageDeclaration CalculationBody
```
ActorMember : ActorMembership =MemberPrefix ownedRelatedElement += ActorUsage

ActorUsage : PartUsage ='actor' UsageExtensionKeyword* Usage

StakeholderMember : StakeholderMembership =MemberPrefix ownedRelatedElement += StakeholderUsage

StakeholderUsage : PartUsage ='stakeholder' UsageExtensionKeyword* Usage

**8.2.2.20.2Requirement Usages**
RequirementUsage =OccurrenceUsagePrefix 'requirement'
CalculationUsageDeclaration RequirementBody
SatisfyRequirementUsage =

**182 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


OccurrenceUsagePrefix 'assert' ( isNegated ?= 'not' ) 'satisfy'( ownedRelationship += OwnedReferenceSubsetting
| 'requirement' UsageDeclaration )FeatureSpecializationPart?
ValuePart?( 'by' ownedRelationship += SatisfactionSubjectMember )?
RequirementBody
SatisfactionSubjectMember : SubjectMembership =ownedRelatedElement += SatisfactionParameter

SatisfactionParameter : ReferenceUsage =ownedRelationship += SatisfactionFeatureValue

SatisfactionFeatureValue : FeatureValue =ownedRelatedElement += SatisfactionReferenceExpression

SatisfactionReferenceExpression : FeatureReferenceExpression =ownedRelationship += FeatureChainMember

**8.2.2.20.3Concerns**
ConcernDefinition =OccurrenceDefinitionPrefix 'concern' 'def'
DefinitionDeclaration RequirementBody?
ConcernUsage =OccurrenceUsagePrefix 'concern'
CalculationUsageDeclaration RequirementBody
**8.2.2.21Cases Textual Notation**
CaseDefinition =OccurrenceDefinitionPrefix 'case' 'def'
DefinitionDeclaration CaseBody
CaseUsage =OccurrenceUsagePrefix 'case'
CalculationUsageDeclaration CaseBody
CaseBody : Type =';'
| '{' CaseBodyItem*( ownedRelationship += ResultExpressionMember )?
'}'
CaseBodyItem : Type =ActionBodyItem
| ownedRelationship += SubjectMember| ownedRelationship += ActorMember
| ownedRelationship += ObjectiveMember
ObjectiveMember : ObjectiveMembership =MemberPrefix 'objective'
ownedRelatedElement += ObjectiveRequirementUsage
ObjectiveRequirementUsage : RequirementUsage =UsageExtensionKeyword* CalculationUsageDeclaration
RequirementBody

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 183**


**8.2.2.22Analysis Cases Textual Notation**
AnalysisCaseDefinition =OccurrenceDefinitionPrefix 'analysis' 'def'
DefinitionDeclaration CaseBody
AnalysisCaseUsage =OccurrenceUsagePrefix 'analysis'
CalculationUsageDeclaration CaseBody
**8.2.2.23Verification Cases Textual Notation**
VerificationCaseDefinition =OccurrenceDefinitionPrefix 'verification' 'def'
DefinitionDeclaration CaseBody
VerificationCaseUsage =OccurrenceUsagePrefix 'verification'
CalculationUsageDeclaration CaseBody
RequirementVerificationMember : RequirementVerificationMembership =MemberPrefix 'verify' { kind = 'requirement' }
ownedRelatedElement += RequirementVerificationUsage
RequirementVerificationUsage : RequirementUsage =ownedRelationship += OwnedReferenceSubsetting

```
| ( UsageExtensionKeyword* 'requirement'FeatureSpecialization* RequirementBody
| UsageExtensionKeyword+ )CalculationUsageDeclaration RequirementBody
```
**8.2.2.24Use Cases Textual Notation**
UseCaseDefinition =OccurrenceDefinitionPrefix 'use' 'case' 'def'
DefinitionDeclaration CaseBody
UseCaseUsage =OccurrenceUsagePrefix 'use' 'case'
CalculationUsageDeclaration CaseBody
IncludeUseCaseUsage :OccurrenceUsagePrefix 'include'
( ownedRelationship += OwnedReferenceSubsettingFeatureSpecializationPart?
| 'use' 'case' UsageDeclaration )ValuePart?
CaseBody
**8.2.2.25Views and Viewpoints Textual Notation
8.2.2.25.1View Definitions**
ViewDefinition =OccurrenceDefinitionPrefix 'view' 'def'
DefinitionDeclaration ViewDefinitionBody
ViewDefinitionBody : ViewDefinition =';' | '{' ViewDefinitionBodyItem* '}'

**184 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ViewDefinitionBodyItem : ViewDefinition =DefinitionBodyItem
| ownedRelationship += ElementFilterMember| ownedRelationship += ViewRenderingMember

ViewRenderingMember : ViewRenderingMembership =MemberPrefix 'render'
ownedRelatedElement += ViewRenderingUsage
ViewRenderingUsage : RenderingUsage =ownedRelationship += OwnedReferenceSubsetting
FeatureSpecializationPart?UsageBody

**8.2.2.25.2View Usages**
ViewUsage =OccurrenceUsagePrefix 'view'
UsageDeclaration? ValuePart?ViewBody

ViewBody : ViewUsage =';' | '{' ViewBodyItem* '}'

ViewBodyItem : ViewUsage =DefinitionBodyItem
| ownedRelationship += ElementFilterMember| ownedRelationship += ViewRenderingMember
| ownedRelationship += Expose
Expose =( visibility = VisibilityIndicator )?
'expose' ( ImportedNamespace | ImportedFilterPackage ) ';'
**8.2.2.25.3Viewpoints**
ViewpointDefinition =OccurrenceDefinitionPrefix 'viewpoint' 'def'
DefinitionDeclaration RequirementBody
ViewpointUsage =OccurrenceUsagePrefix 'viewpoint'
CalculationUsageDeclaration RequirementBody
**8.2.2.25.4Renderings**
RenderingDefinition =OccurrenceDefinitionPrefix 'rendering' 'def'
Definition
RenderingUsage =OccurrenceUsagePrefix 'rendering'
Usage
**8.2.2.26Metadata Textual Notation**
MetadataDefinition =( isAbstract ?= 'abstract')? 'metadata' 'def'
Definition

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 185**


PrefixMetadataAnnotation : Annotation ='#' annotatingElement = PrefixMetadataUsage
{ ownedRelatedElement += annotatingElement }
PrefixMetadataMember : OwningMembership ='#' ownedRelatedEleemnt = PrefixMetadataUsage

PrefixMetadataUsage : MetadataUsage =ownedRelationship += OwnedFeatureTyping

MetadataUsage =( '@' | 'metadata' ) MetadataUsageDeclaration
( 'about' annotation += AnnotationownedRelationship += Annotation
( ',' annotation += Annotation{ ownedRelationship += Annotation } )*
)?MetadataBody

MetadataFeatureDeclaration : MetadataUsage =( Identification ( ':' | 'typed' 'by' ) )?
ownedRelationship += OwnedFeatureTyping
MetadataBody : Type =';' |
'{' ( ownedRelationship += DefinitionMember| ownedRelationship += MetadataBodyUsageMember
| ownedRelationship += AliasMember| ownedRelationship += Import
'}')*
MetadataBodyUsageMember : FeatureMembership =ownedMemberFeature = MetadataBodyUsage

MetadataBodyUsage : ReferenceUsage :'ref'? ( ':>>' | 'redefines' )? ownedRelationship += OwnedRedefinition
FeatureSpecializationPart? ValuePart?MetadataBody

ExtendedDefinition : Definition =BasicDefinitionPrefix? DefinitionExtensionKeyword+
'def' Definition
ExtendedUsage : Usage =BasicUsagePrefix UsageExtensionKeyword+
Usage
**8.2.3Graphical Notation
8.2.3.1Graphical Notation Overview**
The SysML graphical notation is expressed using a simplified form of the EBNF notation used to define the SysML
textual notation (see8.2.2.1.1). This graphical BNF has been extended to include productions with a mixture of
graphical and textual elements.Table 29summarizes the conventions used.
**Table 29. Graphical BNF Conventions
Non-terminal element** non-terminal-element

**186 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Non-terminal element production (complete) non-terminal-element = elements
Non-terminal element production (partial) non-terminal-element =| elements
Grouping ( elements )
Alternative elements elements | elements
Repeated elements (zero or more) element *
Repeated elements (one or more) element +
Optional elements (zero or one) element?
Elements 2-D layout of graphical and textual elements
Graphical element graphical shape or graphical line
Graphical shape 2-D shape with optional nested elements
Graphical line 1-D shape with optional nested elements
Graphical line that connects other elements &element graphical-line &element
Sequential text elements element1 element2
Terminal text element as literal string 'terminal'
Terminal text element as lexical symbol LEXICAL
Graphical Notation to Textual Notation mapping graphical production <=> textualproduction
```
These conventions make a distinction between a complete production, which must include all alternatives within the
production itself, and partial productions, which allow alternatives to be distributed across multiple productions
located anywhere within a specification. This distinction allows greater reuse of production symbols across sections
of a specification that build on partial productions given by earlier sections, while still making clear productions that
are already complete within a given section.
A graphical production contains a two-dimensional layout of graphical and textual elements including graphical
shapes and lines. Shapes may contain other elements nested within these shapes. Generally speaking, graphical
elements specify only containment and connectivity of graphical and textual elements out of which they are built.
Shapes within the graphical notation may generally be relocated anywhere within a given graphical layout. They
may also have any of their graphical elements stretched as necessary to hold their contents.
Lines that connect other graphical elements may be composed of one or more straight or curved line segments. Any
of these line segments may contain a semicircular jump symbol where the segment overlaps a line segment of
another connecting line.
A textual production contains only other textual productions. All production symbols within the graphical BNF
follow a convention of all-lowercase names with optional internal hyphens. Elements of the textual notationdefined
in subclause8.2.2of this specification may also be referenced by textual productions within the graphical BNF.
Theseimported textual notation elements can be distinguished from those of the graphical BNF by their use of one
or more uppercase letters within the name.
**8.2.3.2Elements and Relationships Graphical Notation**
element =dependencies-and-annotations-element
| general-element

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 187**


| element-inside-textual-compartment
compartment =| general-compartment
general-compartment =

general-view
general-view =(general-element)*
(dependencies-and-annotations-element)*(ellipsis-at-lower-left-corner)?

ellipsis-at-lower-left-corner = '...'
general-element =general-node
| general-relationship
element-inside-textual-compartment =

rel-name =Identification
| QualifiedName
**Note.** Anelement inside a textual compartment is selected by graying out a substring containing the element. The
grayed-out section must cover a single element within the textual syntax inside the compartment.
**8.2.3.3Dependencies Graphical Notation**
dependencies-and-annotations-element =| dependencies-element
dependencies-element =|binary-dependency
| n-ary-dependency
binary-dependency =

n-ary-dependency =&n-ary-association-dot (n-ary-dependency-client-or-supplier-link &element-node)+

n-ary-dependency-client-or-supplier-link =n-ary-dependency-client-link
| n-ary-dependency-supplier-link
n-ary-association-dot =

n-ary-dependency-client-link =

**188 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


n-ary-dependency-supplier-link =

**Note.** An n-ary dependency must have two or more client elements or two or more supplier elements.
**8.2.3.4Annotations Graphical Notation**
dependencies-and-annotations-element =|annotation-node
| annotation-link
annotation-node =comment-node
| documentation-node| textual-representation-node

text-block = (LINE_TEXT)*
comment-node =comment-without-keyword
| comment-with-keyword
comment-without-keyword =

comment-with-keyword =

documentation-node =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 189**


documentation-compartment =

```
Identificationtext-block
```
textual-representation-node =

language-string = 'language' '=' STRING_VALUE
annotation-link =

annotated-element =element
| element-inside-textual-compartment
**Note.** A comment node may be attached to zero, one, or more than one annotated elements. All other annotation
nodes must be attached to one and only one annotated element.
**8.2.3.5Namespaces and Packages Graphical Notation**
general-node =| namespace-node
namespace-node =| package-node
package-node =package-with-name-inside
| package-with-name-in-tab| imported-package-with-name-inside
| imported-package-with-name-in-tab
package-with-name-inside =

**190 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


package-with-name-in-tab =

imported-package-with-name-inside =

imported-package-with-name-in-tab =

package-compartment =general-compartment
| documentation-compartment| packages-compartment
| members-compartment| relationships-compartment

compartment =| package-compartment
packages-compartment =

packages-compartment-contents
packages-compartment-contents = text-block

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 191**


members-compartment =

members-compartment-contents
members-compartment-contents = text-block
relationships-compartment =

relationships-compartment-contents
relationships-compartment-contents = text-block
general-relationship =|import
| top-level-import| recursive-import
| owned-membership| unowned-membership

import =

top-level-import =

recursive-import =

owned-membership =

unowned-membership =

**8.2.3.6Definition and Usage Graphical Notation**
general-node =| type-node

**192 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


type-node =definition-node
| usage-node
namespace-node =| type-node
basic-name-prefix =('«variation»')?
('«variant»')?('«abstract»')?

definition-name-with-alias =Identification
( '«alias»' ( QualifiedName (',' QualifiedName)* ) )?
usage-name-with-alias =Identification (':' QualifiedName)?
( '«alias»' ( QualifiedName (',' QualifiedName)* ) )?
compartment-stack = (compartment)*
compartment =|| variants-compartment
| variant-elementusages-compartment
variants-compartment =

variants-compartment-contents
variants-compartment-contents = text-block
variant-elementusages-compartment =

variant-elementusages-compartment-contents
variant-elementusages-compartment-contents = text-block
general-relationship =|type-relationship

type-relationship =subclassification
| subsetting| definition
| redefinition| composite-feature-membership
| noncomposite-feature-membership
subclassification =

definition =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 193**


subsetting =

reference-subsetting =

redefinition =

composite-feature-membership =

noncomposite-feature-membership =

rd = (reference-diamond)?
reference-diamond =

```
|
```
el-prefix = '^' | '/'
**8.2.3.7Attributes Graphical Notation**
definition-node =| attribute-def
attribute-def =

**194 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


attribute-def-name-compartment =basic-name-prefix
'«attribute def»'definition-name-with-alias

usage-node =| attribute
attribute =

attribute-name-compartment =basic-name-prefix
'«attribute»'usage-name-with-alias

compartment =| attributes-compartment
attributes-compartment =

attributes-compartment-contents
attributes-compartment-contents = (attributes-compartment-element)* '...'?attributes-compartment-element =
el-prefix? UsagePrefix UsageDeclaration DefinitionBodyItem*

**8.2.3.8Enumerations Graphical Notation**
definition-node =| enumeration-def
enumeration-def =

enumeration-def-name-compartment =basic-name-prefix
'«enumeration def»'definition-name-with-alias

usage-node =| enumeration
enumeration =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 195**


enumeration-name-compartment =basic-name-prefix
'«enumeration»'usage-name-with-alias

compartment =| enums-compartment
enums-compartment =

enums-compartment-contents
enums-compartment_contents = (enums-compartment-element)* '...'?enums-compartment-element =
el-prefix? UsagePrefix Usage
**8.2.3.9Occurrences Graphical Notation**
definition-node =| occurrence-def
general-relationship =| portion-relationship
occurrence-name-prefix = basic-name-prefix («individual»)?
occurrence-def =

occurrence-def-name-compartment =occurrence-name-prefix
'«occurrence def»'definition-name-with-alias

usage-node =|occurrence
| timeslice-or-snapshot-node
occurrence =

**196 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


occurrence-name-compartment =occurrence-name-prefix
'«occurrence»'usage-name-with-alias

timeslice-or-snapshot-node =timeslice
| snapshot
timeslice =

timeslice-name-compartment'«timeslice»'
usage-name-with-alias
snapshot =

snapshots-name-compartment'«snapshot»'
usage-name-with-alias
portion-relationship =

compartment =|occurrences-compartment
| individuals-compartment| timeslices-compartment
| snapshots-compartment| sequence-compartment

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 197**


occurrences-compartment =

occurrences-compartment-contents
occurrences-compartment-contents = (occurrences-compartment-element)* '...'?occurrences-compartment-element =
el-prefix? OccurrenceUsagePrefix Usage DefinitionBodyItem*
individuals-compartment =

individuals-compartment-contents
individuals-compartment-contents = (individuals-compartment-element)* '...'?individuals-compartment-element =
el-prefix? OccurrenceUsagePrefix Usage DefinitionBodyItem*
timeslices-compartment =

timeslices-compartment-contents
timeslices-compartment-contents = (timeslices-compartment-element)* '...'?timeslices-compartment-element =
el-prefix? OccurrenceUsagePrefix Usage DefinitionBodyItem*
snapshots-compartment =

snapshots-compartment-contents
snapshots-compartment-contents = (snapshots-compartment-element)* '...'?snapshots-compartment-element =
el-prefix? OccurrenceUsagePrefix Usage DefinitionBodyItem*
sequence-compartment =

sequence-view
sequence-view = (sq-graphical-element)*
sq-graphical-element =sq-graphical-node
| sq-graphical-relationship| dependencies-and-annotations-element

sq-graphical-node = sq-head-node | sq-l-node
sq-head-node = sq-part | sq-port
sq-part =

**198 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


sq-port =

sq-port-label = Usage
sq-l-node =lifeline
| proxy| sq-ev-occurrence

lifeline =

proxy =

sq-proxy-label = Usage
sq-ev-occurrence =

sq-ev-occurrence-label = Usage

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 199**


sq-graphical-relationship = sq-message | sq-succession
sq-message =

sq-message-label = Usage
sq-succession =

**8.2.3.10Items Graphical Notation**
definition-node =| item-def
item-def =

item-def-name-compartment =occurrence-name-prefix
'«item def»'definition-name-with-alias

usage-node = | item
item =

item-name-compartment =connection-name-prefix
'«item»'usage-name-with-alias

compartment =| items-compartment
items-compartment =

```
items-compartment-contents
```
**200 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


items-compartment-contents = (items-compartment-element)* '...'items-compartment-element =
el-prefix? OccurrenceUsagePrefix Usage DefinitionBodyItem*
**8.2.3.11Parts Graphical Notation**
definition-node =| part-def
part-def =

part-def-name-compartment =occurrence-name-prefix
'«part def»'definition-name-with-alias

usage-node =| part
part =

part-name-compartment =occurrence-name-prefix
'«part»'usage-name-with-alias

compartment =|parts-compartment
| directed-features-compartment| interconnection-compartment

parts-compartment =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 201**


parts-compartment-contents
parts-compartment-contents = (parts-compartment-element)* '...'?parts-compartment-element =
el-prefix? OccurrenceUsagePrefix UsageDeclaration ValueOrFlowPart? DefinitionBodyItem*

directed-features-compartment =

directed-features-compartment-contents
directed-features-compartment-contents = (directed-features-compartment-element)* '...'?directed-features-compartment-element =
el-prefix FeatureDirection Definition-Body-Item*
interconnection-compartment =

```
interconnection-view
```
interconnection-view =|(interconnection-element)*
(dependencies-and-annotations-element)*(ellipsis-at-lower-left-corner)?

interconnection-element =part-def
| part
general-view =| interconnection-view
**8.2.3.12Ports Graphical Notation**
definition-node =| port-def
port-def =

port-def-name-compartment =occurrence-name-prefix
'«port def»'definition-name-with-alias

usage-node =| port-usage
port-usage =

**202 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


port-name-compartment =occurrence-name-prefix
'«port»'usage-name-with-alias

compartment =| ports-compartment
ports-compartment =

ports-compartment-contents
ports-compartment-contents = (ports-compartment-element)* '...'?ports-compartment-element =
el-prefix? OccurrenceUsagePrefix UsageDeclaration ValueOrFlowPart? DefinitionBodyItem*
interconnection-element =|port-def
| port
pdh =

```
|
```
```
|
```
pdv =

```
|
```
```
|
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 203**


port-l =

```
|
```
```
|proxy
```
port-r =

|

```
| proxy
```
port-t =

**204 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
|
```
```
| proxy
```
port-b =

```
|
```
```
| proxy
```
port-label = QualifiedName (':' QualifiedName)?

**Note.** The proxy option of aport production is valid only on a part usage contained within an interconnection view.
**8.2.3.13Connections Graphical Notation**
definition-node =| connection-def
connection-def =

connection-def-name-compartment =occurrence-name-prefix
'«connection def»'definition-name-with-alias

usage-node =| connection
connection =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 205**


connection-name-compartment =occurrence-name-prefix
'«connection»'usage-name-with-alias

compartment =| connections-compartment
connections-compartment =

connections-compartment-contents
connections-compartment-contents = (connections-compartment-element)* '...'?connections-compartment-element =
el-prefix? OccurrenceUsagePrefix UsageDeclaration ConnectorPart+ DefinitionBodyItem*
interconnection-element =|connection-def
| connection| connection-relationship
| attribute
connection-relationship =port-binding-connection
| constraint-binding-connection| flow-connection
| interface-connection| connection-definition-elaboration
| connection-usage-elaboration
port-binding-connection =

constraint-binding-connection =

flow-connection =

flow-node =flow-node-r
| flow-node-l
flow-node-r =

**206 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


flow-node-r =

interface-connection =

connection-definition-elaboration =

connection-usage-elaboration =

**8.2.3.14Interfaces Graphical Notation**
definition-node =| interface-def
interface-def =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 207**


interface-def-name-compartment =occurrence-name-prefix
'«interface def»'definition-name-with-alias

usage-node =| interface
interface =

interface-name-compartment =occurrence-name-prefix
'«interface»'usage-name-with-alias

compartment =|interfaces-compartment
| ends-compartment
interfaces-compartment =

interfaces-compartment-contents
interfaces-compartment-contents = (interfaces-compartment-element)* '...'?interfaces-compartment-element =
el-prefix? InterfaceUsageDeclaration InterfaceBodyDefinition*
ends-compartment =

ends-compartment-contents
ends-compartment-contents = (ends-compartment-element)* '...'?ends-compartment-element = QualifedName (':' QualifiedName)?

**8.2.3.15Allocations Graphical Notation**
definition-node =| allocation-def
allocation-def =

**208 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


allocation-def-name-compartment =occurrence-name-prefix
'«allocation def»'definition-name-with-alias

usage-node =| allocation
allocation =

allocation-name-compartment =occurrence-name-prefix
'«allocation»'usage-name-with-alias

compartment =| allocations-compartment
allocations-compartment =

allocations-compartment-contents
allocations-compartment-contents = (allocations-compartment-element)* '...'?
allocations-compartment-element =el-prefix? OccurrenceUsagePrefix AllocationUsageDeclaration UsageBody*

general-relationship =| allocate-relationship
allocate-relationship =

allocation-node =general-node
| element-in-textual-compartment

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 209**


**8.2.3.16Actions Graphical Notation**
definition-node =| action-def
action-def =

action-def-name-compartment =occurrence-name-prefix
'«action def»'definition-name-with-alias

usage-node =|action
| perform-action-usage
action =

action-name-compartment =occurrence-name-prefix
'«action»'usage-name-with-alias

perform-action-usage =

**210 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


perform-action-name-compartment ='«perform-action»'
action-name-compartment
compartment =|actions-compartment
| perform-actions-compartment| parameters-compartment
| action-flow-compartment
actions-compartment =

actions-compartment-contents
actions-compartment-contents = (actions-compartment-element)* '...'?actions-compartment-element =
el-prefix? OccurrenceUsagePrefix ActionUsageDeclaration ActionBodyItem*
perform-actions-compartment =

perform-actions-compartment-contents
perform-actions-compartment-contents = (perform-actions-compartment-element)* '...'?perform-actions-compartment-element =
el-prefix? PerformActionUsageDeclaration ActionBodyItem*
parameters-compartment =

parameters-compartment-contents
parameters-compartment-contents = (parameters-compartment-element)* '...'?parameters-compartment-element =
el-prefix? FeatureDirection UsageDeclaration ValueOrFlowPart? DefinitionBodyItem*
performed-by-compartment =

performed-by-compartment-contents
performed-by-compartment-contents = text-block
action-flow-compartment =

action-flow-view
action-flow-view =(dependencies-and-annotations-element)*
(action-flow-element)*(perform-action-swimlanes)?

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 211**


action-flow-element =|action-def
| action| action-flow-node
| action-flow-relationship
action-flow-node =start-node
| done-node| fork-node
| join-node| decision-node
| merge-node| send-action-node
| accept-action-node| loop-action-node
| assign-action-node
action-flow-relationship =flow-usage
| succession| action-binding-connection

param-l =

```
|
```
```
|proxy
```
param-r =

**212 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
|
```
```
|proxy
```
param-t =

```
|
```
```
|proxy
```
param-b =

```
|
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 213**


| proxy
param-label = QualifiedName (‘:’ QualifiedName)*
start-node =

done-node =

fork-node =

join-node =

decision-node =

merge-node =

send-action-node =

**214 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


send-action-name-compartment = ('«send»')? qualified-name (':' qualified-name)?( '«alias»' ( qualified-name (',' qualified-name)* ) )?

send-action-expression = NodeParameterMember 'to' NodeParameterMember
accept-action-node =

accept-action-name-compartment = ('«accept»')? qualified-name (':' qualified-name)?( '«alias»' ( qualified-name (',' qualified-name)* ) )?

accept-action-expression = AcceptParameterPart
loop-action-node =

loop-action-name-compartment = ('«loop»')? qualified-name (':' qualified-name)?( '«alias»' ( qualified-name (',' qualified-name)* ) )?

assign-action-node =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 215**


assign-action-name-compartment = ('«assign»')? qualified-name (':' qualified-name)?( '«alias»' ( qualified-name (',' qualified-name)* ) )?

perform-actions-swimlanes = (swimlane)*
swimlane =

succession =

guard-expression = ‘[‘ ExpressionParameterMember ActionBodyParameterMember ’]’

**216 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


action-binding-connector =

**Note.** All swimlanes are attached to each other on vertical edges and aligned along the top and bottom horizontal
edges.
**Note.** The proxy option of a parameter production is valid only on an action usage contained within an action flow
view.
**8.2.3.17States Graphical Notation**
definition-node =| action-def
state-def =

state-def-name-compartment =occurrence-name-prefix
'«state def»'('«parallel»')?
definition-name-with-alias
usage-node =|state
| exhibit-state-usage
state =

state-name-compartment =occurrence-name-prefix
'«state»'('«parallel»')?
definition-name-with-alias
exhibit-state-usage =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 217**


exhibit-state-name-compartment ='«exhibit-state»'
state-name-compartment
compartment =|states-compartment
| states-actions-compartment| exhibit-states-compartment
| successions-compartment| state-transition-compartment

states-compartment =

states-compartment-contents
states-compartment-contents = (states-compartment-element)* '...'?states-compartment-element = el-prefix? UsageDeclaration

state-actions-compartment =

state-actions-compartment-contents
state-actions-compartment-contents = (state-actions-compartment-element)* '...'?state-actions-compartment-element =
el-prefix? EntryActionMember | DoActionMember | ExitActionMember
exhibit-states-compartment =

exhibit-states-compartment-contents
exhibit-states-compartment-contents = exhibit-state-scompartment-element*exhibit-states-compartment-element-compartment = UsageDeclaration '...'?

succession-compartment =

succession-compartment-contents
succession-compartment-contents = text-block
state-transition-compartment =

**218 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


state-transition-view
state-transition-view =(state-transition-element)*
(dependencies-and-annotations-element)*
state-transition-element =state-def-node
| state-node| transition
| start-node| done-node
| fork-node| join-node
| decision-node| merge-node

transition =

transition-label = trigger-expression '/' ActionUsage
trigger-expression = AcceptParameterPart (guard-expression)?

**8.2.3.18Calculations Graphical Notation**
definition-node =| calc-def
calc-def =

calc-def-name-compartment =occurrence-name-prefix
'«calc def»'definition-name-with-alias

usage-node =| calc
calc =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 219**


calc-name-compartment =occurrence-name-prefix
'«calc def»'definition-name-with-alias

action-flow-element =|calc-def
| calc
compartment =|calcs-compartment
| result-compartment
calcs-compartment =

calcs-compartment-contents
calcs-compartment-contents = text-block
results-compartment =

result-compartment-contents
result-compartment-contents = text-block

**8.2.3.19Constraints Graphical Notation**
definition-node =| constraint-def
constraint-def =

**220 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


constraint-def-name-compartment =occurrence-name-prefix
'«constraint def»'definition-name-with-alias

usage-node =constraint
| assert-constraint-usage
constraint =

constraint-name-compartment =occurrence-name-prefix
'«constraint»'definition-name-with-alias

assert-constraint-usage =

assert-constraint-name-compartment ='«assert constraint»'
constraint-name-compartment

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 221**


compartment =|constraints-compartment
| assert-constraints-compartment
constraints-compartment =

constraints-compartment-contents
constraints-compartment-contents = (constraints-usage-compartment)* '...'?constraints-usage-compartment =
el-prefix? OccurrenceUsagePrefix CalculationUsageDeclaration CalculationBody*
assert-constraints-compartment =

assert-constraints-compartment-contents
assert-constraints-compartment-contents = (assert-constraints-compartment-element)* '...'?assert-constraints-compartment-element =
el-prefix? OccurrenceUsagePrefix ( 'not' )?( OwnedSubsetting FeatureSpecializationPart? | UsageDeclaration )
CalculationUsageParameterPart CalculationBody
interconnection-element =|constraint-def
| constraint

**8.2.3.20Requirements Graphical Notation**
definition-node =|requirement-def
| concern-def
requirement-def =

requirement-def-name-compartment =occurrence-name-prefix
'«requirement-def»'definition-name-with-alias

usage-node =requirement
| satisfy-requirement-usage

**222 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


| concern
requirement =

requirement-name-compartment =constraint-prefix
'«requirement»'definition-name-with-alias

satisfy-requirement-usage =

satisfy-requirement-name-compartment ='«satisfy requirement»'
requirement-name-compartment
concern-def =

concern-def-name-compartment =occurrence-name-prefix
'«concern-def»'definition-name-with-alias

concern =

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 223**


concern-name-compartment =occurrence-prefix
'«concern»'definition-name-with-alias

compartment =|constraints-compartment
| assert-constraints-compartment
compartment =|requirements-compartment
| require-constraints-compartment| assume-constraints-compartment
| satisfy-requirements-compartment| satisfies-compartment
| actors-compartment| subject-compartment
| stakeholders-compartment| frames-compartment

requirements-compartment =

requirements-compartment-contents
requirements-compartment-contents = (requirements-compartment-element)* '...'?requirements-compartment-element = OccurrenceUsagePrefix CalculationUsageDeclaration

require-constraints-compartment =

require-constraints-compartment-contents
require-constraints-compartment-contents = text-block
assume-constraints-compartment =

assume-constraints-compartment-contents
assume-constraints-compartment-contents = text-block
satisfy-requirements-compartment =

satisfy-requirements-compartment-contents
satisfy-requirements-compartment-contents = text-block

**224 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


satisfies-compartment =

satisfies-compartment-contents
satisfies-compartment-contents = (satisfies-compartment-element)* '...'?satisfies-compartment-element =
OccurrenceUsagePrefix ('not')?( OwnedSubsetting FeatureSpecializationPart? | UsageDeclaration )
( ValuePart | ActionParameterList ) ( 'by' SatisfactionSubjectMember )? RequirementBody
actors-compartment =

actors-compartment-contents
actors-compartment-contents = (actors-compartment-element)* '...'?actors-compartment-element = el-prefix? MemberPrefix Usage

subject-compartment =

subject-compartment-contents
subject-compartment-contents = (subject-compartment-element)* '...'?subject-compartment-element = el-prefix? MemberPrefix Usage

stakeholders-compartment =

stakeholders-compartment-contents
stakeholders-compartment-contents = (stakeholders-compartment-element)* '...'?stakeholders-compartment-element = el-prefix? MemberPrefix Usage

frames-compartment =

frames-compartment-contents
frames-compartment-contents = (frames-compartment-element)* '...'?frames-compartment-element = el-prefix* MemberPrefix? FramedConcernUsage

concerns-compartment =

concerns-compartment-contents
interconnection-element =|requirement-def
| requirement| concern-def
| concern

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 225**


| distinguished-parameter| distinguished-parameter-link
| concern-stakeholder-link
general-relationship =| frame-relationship
subject-actors-stakeholders-node =| requirement
distinguished-parameter =subject
| actor| stakeholder

subject =

actor =

```
|
```
stakeholder =

subject-name = QualifiedNameactor-name = QualifiedName
stakeholder-name = QualifiedName

**226 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


distinguished-parameter-link =

frame-relationship =

concern-stakeholder-link =

**8.2.3.21Cases Graphical Notation**
compartment =| objective-compartment
objective-compartment =

objective-compartment-contents
objective-compartment-contents = (objective-compartment-element)* '...'?objective-compartment-element =
comp-prefix? MemberPrefix CalculationUsageDeclaration RequirementBody
**8.2.3.22Analysis Cases Graphical Notation**
definition-node =| calc-def
analysis-def =

analysis-def-name-compartment =occurrence-name-prefix
'«analysis def»'definition-name-with-alias

usage-node =| analysis

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 227**


analysis =

analysis-name-compartment =occurrence-name-prefix
'«analysis»'definition-name-with-alias

compartment =| analyses-compartment
analyses-compartment =

analyses-compartment-contents
analyses-compartment-contents = analyses-compartment-element* '...'?analyses-compartment-element =
el-prefix? OccurrenceUsagePrefix CalculationUsageDeclaration CaseBody
action-flow-element =|analysis-def
| analysis
**8.2.3.23Verification Cases Graphical Notation**
definition-node =| verification-def
verification-def =

verification-def-name-compartment =occurrence-name-prefix
'«verification def»'

**228 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


definition-name-with-alias
usage-node =| verification
verification =

verification-name-compartment =occurrence-name-prefix
'«verification»'definition-name-with-alias

compartment =|verifications-compartment
| verifies-compartment| verification-methods-compartment

verifications-compartment =

verifications-compartment-contents
verifications-compartment-contents = (verifications-compartment-element)* '...'?verifications-compartment-element =
el-prefix? OccurrenceUsagePrefix CalculationUsageDeclaration CaseBody '...'
verifies-compartment =

verifies-compartment-contents
verifies-compartment-contents = (verifies-compartment-element)* '...'?verifies-compartment-element = el-prefix? MemberPrefix RequirementVerificationUsage '...'

verification-methods-compartment =

verification-methods-compartment-contents
verification-methods-compartment-contents = (verification-methods-compartment-element)* '...'?verification-methods-compartment-element = MetadataBody

action-flow-element =|verification-def

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 229**


| verification
general-relationship =| verify-relationship
verify-relationship =

**8.2.3.24Use Cases Graphical Notation**
definition-node =| use-case-def
use-case-def =

use-case-def-name-compartment =occurrence-name-prefix
'«use case def»'definition-name-with-alias

usage-node =|use-case
| include-use-case-usage
use-case =

use-case-name-compartment =occurrence-name-prefix
'«use case»'definition-name-with-alias

include-use-case-usage =

**230 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


include-use-case-name-compartment ='«include use case»'
requirement-name-compartment
compartment =|use-cases-compartment
| include-actions-compartment| includes-compartment

use-cases-compartment =

use-cases-compartment-contents
use-cases-compartment-contents = text-block
include-use-cases-compartment =

include-use-cases-compartment-contents
include-use-cases-compartment-contents = (include-use-cases-compartment-element* '...'?include-use-cases-compartment-element =
el-prefix? OccurrenceUsagePrefix( OwnedSubsetting FeatureSpecializationPart? | UsageDeclaration )
( ValuePart | ActionUsageParameterList )? CaseBody
includes-compartment =

includes-compartment-contents
includes-compartment-contents = (includes-compartment-element)* '...'?includes-compartment-element =
el-prefix? OccurrenceUsagePrefix( OwnedSubsetting FeatureSpecializationPart? | UsageDeclaration )

action-flow-element =|use-case-def
| use-case
general-relationship =| include-use-case-relationship

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 231**


include-use-case-relationship =

...
**8.2.3.25Views and Viewpoints Graphical Notation**
definition-node =|viewpoint-def
| view-def
viewpoint-def =

viewpoint-def-name-compartment =occurrence-name-prefix
'«viewpoint def»'definition-name-with-alias

view-def =

view-def-name-compartment =occurrence-name-prefix
'«view def»'definition-name-with-alias

usage-node =viewpoint
| view| view-frame

viewpoint =

viewpoint-name-compartment =constraint-prefix
'«viewpoint»'

**232 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


definition-name-with-alias
view =

view-name-compartment =occurrence-name-prefix
'«view»'definition-name-with-alias

compartment =|| views-compartment
| viewpoints-compartment| exposes-compartment
| filters-compartment| rendering-compartment

views-compartment =

views-compartment-contents
views-compartment-contents = (views-compartment-element)* '...'views-compartment-element =
el-prefix? OccurrenceUsagePrefix UsageDeclaration? ValueOrFlowPart? ViewBody
viewpoints-compartment =

viewpoints-compartment-contents
viewpoints-compartment-contents = (viewpoints-compartment-element)* '...'?viewpoints-compartment-element =
el-prefix? OccurrenceUsagePrefix CalculationUsageDeclaration RequirementBody
exposes-compartment =

exposes-compartment-contents
exposes-compartment-contents = text-block
filters-compartment =

filters-compartment-contents
filters-compartment-contents = (filters-compartment-element)* '...'?filters-compartment-element = el-prefix? MemberPrefix OwnedExpression

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 233**


rendering-compartment =

rendering-compartment-contents
rendering-compartment-contents = text-block
interconnection-element =|viewpoint-def
| viewpoint| view-def
| view
view-frame =

view-frame-name-compartment = '«view»' QualifiedName (':' QualifiedName)?
general-relationship =| expose-relationship
expose-relationship =

**Note.** A model library in Section 9.2.18 definesstandard graphical view definitions for SysML. These may be
supplemented by further, customized View Definitions specific to amodel.
**8.2.3.26Metadata Graphical Notation**
annotation-node =| metadata-feature-annotation-node
metadata-feature-annotation-node =

**234 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


metadata-feature-decl = Identifiermetadata-feature-name-value-list =

metadata-feature-name = Identifier( metadata-feature-name '=' expression-text )*
expression-text = text-block

**8.3Abstract Syntax
8.3.1Abstract Syntax Overview**
The _abstract syntax_ is the common underlying syntactic representation for SysML models. The SysML textual or
graphical notations (see8.2) provide for concrete presentation of models in the abstract syntax presentation. This
concrete syntax notation may also be parsed to create or update the abstract syntax representation of models. The
semantics for SysML models are then formally defined on the abstract syntax representation (see8.4).
The SysML abstract syntax is specified as a MOF model [MOF] that is an extension of the KerML abstract syntax
model [KerML]. Each of the subsequent abstract subclauses describes one package in the abstract syntax model,
including one ore more overview diagrams and descriptions of each of the elements in the package. In the diagrams,
metaclasses and relationships from the KerML abstract syntax are shown in gray. See [KerML] for the description
of these elements.
The MOF-compliant class model for the abstract syntax defines the basic structural representation for any SysML
model. In addition to this basic structure, the abstract syntax also includes _constraints_ defined on various
metaclasses. A conformant tool shall be able to accept any KerML model that conforms to the structural abstract
syntax class model, and it may then additionally report on and/or enforce the constraints on a model so represented
(as further described below).
The SysML abstract syntax model follows the conventions from [KerML, 8.3.1] on three kinds of constraints:

1. _Derivation constraints._ These constraints specify how the values of the derived properties of a metaclass
    are computed from the values of other properties in the abstract syntax model. A tool conformant to the
    SysML abstract syntax shall always enforce derivation constraints. However, the computed values of
    derived properties may depend on whether implied relationships are included in the model or not (see
    below). A derivation constraint has a name starting with the wordderive, followed by the name of the
    metaclass it constrains, followed by the name of the derived property it is for. The OCL specification of
    such a constraint always has the form of an equality, with the derived property on the left-hand side and
    the derivation expression on the right-hand side. For example, the derivation constraint for the derived
    propertyUsage::isReferenceis calledderiveUsageIsReferenceand has the OCL specification
    isReference = not isComposite.
    **Note.** Derivation constraints are _not_ included for derived properties in the following cases:
       ◦ The derived property subsets a property with multiplicity upper bound 1. In this case, if the
          derived property has a value, it must be the same as that of the subsetted property.
       ◦ The derived property redefines another derived property. In this case, the derivation of the
          redefined property also applies to the redefining property, though the redefining property will
          generally place additional constraints on type and/or multiplicity.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 235**


2. _Semantic constraints._ These constraints specify relationships that are semantically required in a SysML
    model (see8.4.1), particularly relationships with elements in the Kernel Semantic Library (see [KerML,
    9.2]) and Systems Model Library (see9.2). These constraints may be violated by a model as entered by a
    user or as interchanged. In this case, a tool may satisfy the constraints by introducing _impliedrelationships_
    into the model, it may simply report their violation, or it may ignore the violations. Semantic constraints
    have names that start with the wordcheck, followed by the name of the constrained metaclass, followed
    by a descriptive word or phrase. For example,checkPartDefinitionSpecialization.
3. _Validation constraints._ These constraints specify additional syntactic conditions that must be satisfied in
    order to give a model a proper semantic interpretation. They are written presuming that all semantic
    constraints are satisfied. A _valid_ model is a model that satisfies all validation constraints. A tool
    conformant to the SysML abstract syntax should report violations of validation constraints. A tool
    conformant to the SysML semantics is only required to operate on valid models. Validation constraints
    have names that start with the wordvalidate, followed by the name of the metaclass, followed by a
    descriptive word or phrase. For example,validateUsageOwningType.

**8.3.2Elements and Relationships Abstract Syntax**
This is a Kernel abstract syntax model. For Elements and Relationships Abstract Syntax class descriptions, see
[KerML, 8.3.2.1].

```
+libraryNamespace() : Namespace [0..1]{redefines libraryNamespace}
```
```
+isImplied : Boolean = false
```
```
Relationship
```
```
+libraryNamespace() : Namespace [0..1]+effectiveName() : String [0..1]
```
```
+effectiveShortName() : String [0..1]+escapedName() : String [0..1]
```
```
+/isLibraryElement : Boolean+isImpliedIncluded : Boolean = false
```
```
+/qualifiedName : String [0..1]+/name : String [0..1]
```
```
+/shortName : String [0..1]+declaredName : String [0..1]
```
```
+declaredShortName : String [0..1]+aliasIds : String [0..*]{ordered}
```
```
+elementId : String{id}
```
```
Element
```
```
{subsets relationship}
```
```
+targetRelationship
0..*
```
```
{subsets relatedElement, ordered}
```
```
+target
0..*
```
```
{subsets relationship}
```
```
+owningRelationship
0..1
```
```
{subsets relatedElement, ordered}
```
```
+ownedRelatedElement
0..*
```
```
{subsets relationship}
```
```
+sourceRelationship
0..*
```
```
{subsets relatedElement, ordered}
```
```
+source
0..*
```
```
{subsets relationship, ordered}
```
```
+ownedRelationship
0..*
```
```
{subsets relatedElement}
```
```
+owningRelatedElement
0..1
```
```
{union, nonunique}
```
```
+/relationship
0..*
```
```
{ordered, nonunique}
```
```
+/relatedElement
0..*
```
```
+/ownedElement{ordered}0..* +/owner0..1
```
**Figure 2. Elements**
It is a general design principle of the KerML abstract syntax that non-RelationshipElementsare related only by
reified instances ofRelationships. All other meta-associations betweenElementsare derived from these reified
Relationships. For example, theowningRelatedElement/ownedRelationshipmeta-association between an

**236 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Elementand aRelationshipis fundamental to establishing the structure of a model. However, the
owner/ownedElementmeta-association between twoElementsis derived, based on theRelationshipstructure
between them.

**8.3.3Dependencies Abstract Syntax**
This is a Kernel abstract syntax model. For Dependencies Abstract Syntax class descriptions, see [KerML, 8.3.2.2].

```
Element
```
```
Relationship
```
```
Dependency
{subsets sourceRelationship}
```
```
+clientDependency
0..*
```
```
{redefines source, ordered}
```
```
+client
1..*
```
```
{subsets targetRelationship}
```
```
+supplierDependency
0..*
```
```
{redefines target, ordered}
```
```
+supplier
1..*
```
**Figure 3. Dependencies
8.3.4Annotations Abstract Syntax**
This is a Kernel abstract syntax model. For Annotations Abstract Syntax class descriptions, see [KerML, 8.3.2.3].

```
+body : String [1]+language : String [1]
```
```
TextualRepresentation
```
```
AnnotatingElement
```
```
Element
```
```
+body : String [1]+locale : String [0..1]
```
```
Comment
```
```
Documentation
```
```
Relationship
```
```
Annotation
```
```
{subsets owner, redefines annotatedElement}
1 +/representedElement
```
```
{subsets annotatingElement, subsets ownedElement, ordered}
0..*+/textualRepresentation
```
```
{subsets annotatingElement, subsets ownedElement, ordered}
```
```
+/documentation0..*
```
```
{subsets owner, redefines annotatedElement}
```
```
+/documentedElement 1
```
```
{subsets annotatedElement, subsets owningRelatedElement}
0..1+/owningAnnotatedElement
{subsets annotation, subsets ownedRelationship,
{subsets targetRelationship, ordered} +annotation0..*0..* ordered}+/ownedAnnotation
```
```
+annotatedElement
{redefines target}^1
```
```
{subsets sourceRelationship, ordered}
```
```
+annotatingElement +annotation0..*
{redefines source}^1
```
```
+/annotatedElement
{ordered}1..*
```
```
+/annotatingElement
{ordered}0..*
```
**Figure 4. Annotation**
ThetextualAnnotationsof anElementare itsannotatingElementsthat areTextualRepresentations.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 237**


**8.3.5Namespaces and Packages Abstract Syntax**
This is a Kernel abstract syntax model. For Namespaces Abstract Syntax class descriptions, see [KerML, 8.3.2.4].
For Packages Abstract Syntax class descriptions, see [KerML, 8.3.4.13].

```
+unqualifiedNameOf( qualifiedName : String ) : String+qualificationOf( qualifiedName : String ) : String [0..1]
```
```
+resolveVisible( name : String ) : Membership [0..1]+resolveLocal( name : String ) : Membership [0..1]
```
```
+resolveGlobal( qualifiedName : String ) : Membership [0..1]+resolve( qualifiedName : String ) : Membership [0..1]
```
```
+importedMemberships( excluded : Namespace [0..*] ) : Membership [0..*]+visibleMemberships( excluded : Namespace [0..*], isRecursive : Boolean, includeAll : Boolean ) : Membership [0..*]
```
```
+visibilityOf( mem : Membership ) : VisibilityKind+namesOf( element : Element ) : String [0..*]
```
```
Namespace
```
```
+/ownedMemberName : String [0..1]{redefines memberName}+/ownedMemberShortName : String [0..1]{redefines memberShortName}
```
```
+/ownedMemberElementId : String{redefines memberElementId}
```
```
OwningMembership
```
```
+visibility : VisibilityKind = public+memberName : String [0..1]
```
```
+memberShortName : String [0..1]+/memberElementId : String
+isDistinguishableFrom( other : Membership ) : Boolean
```
```
Membership
```
```
Element
```
```
publicprotected
```
```
private
```
```
VisibilityKind «enumeration»
```
```
Relationship
```
```
{subsets membership, subsets owningRelationship}
```
```
+/owningMembership
0..1
```
```
{subsets ownedRelatedElement, redefines memberElement}
```
```
+/ownedMemberElement
1
```
```
{subsets targetRelationship}
```
```
+membership
0..*
```
```
+memberElement
{redefines target}^1
```
```
{subsets membershipNamespace}+/importingNamespace 0..*
```
```
{subsets membership, ordered}
+/importedMembership 0..*
```
```
{subsets membershipNamespace, subsets owningRelatedElement,
redefines source}
```
```
+/membershipOwningNamespace 1
```
```
{subsets membership, subsets ownedRelationship, subsets
sourceRelationship, ordered}+/ownedMembership 0..*
```
```
+/membershipNamespace{union}1..*
```
```
{union, ordered}+/membership0..*
```
```
{subsets namespace}+/owningNamespace 0..1
```
```
{subsets member, ordered}+/ownedMember0..*
0..*+/namespace
```
```
0..*{ordered}+/member
```
**Figure 5. Namespaces**

**238 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
+importedMemberships( excluded : Namespace [0..*] ) : Membership [0..*]{redefines importedMemberships} MembershipImport +importedMemberships( excluded : Namespace [0..*] ) : Membership [0..*]{redefines importedMemberships} NamespaceImport
```
```
+importedMemberships( excluded : Namespace [0..*] ) : Membership [0..*] +isImportAll : Boolean = false
```
```
+isRecursive : Boolean = false+visibility : VisibilityKind = public Import Namespace
```
```
Relationship
```
```
Membership
```
```
Element {subsets ownedRelationship, subsets sourceRelationship, {subsets owningRelatedElement, redefines source}+/importOwningNamespace 1
ordered}
```
```
+/importedElement 1 +/membershipImport0..* +/ownedImport0..*
```
+memberElement (^1) {redefines target}
{subsets targetRelationship}
+membership0..*
{subsets targetRelationship}
0..*+import
1 +importedNamespace{redefines target}
+importedMembership{redefines target} 1
+import{redefines targetRelationship}0..*
**Figure 6. Imports**
+includeAsMember( element : Element ) : Boolean+importedMemberships( excluded : Namespace [0..*] ) : Membership [0..*]{redefines importedMemberships}
**Package**
+libraryNamespace() : Namespace [0..1]{redefines libraryNamespace}
+isStandard : Boolean = false **LibraryPackage
ElementFilterMembership
Namespace OwningMembership
Expression**
+/conditionedPackage{subsets owningNamespace}0..1
{subsets ownedMember, ordered}
+/filterCondition0..*
+/condition{redefines ownedMemberElement} 1
+/owningFilter{subsets owningMembership}0..1
**Figure 7. Packages
8.3.6Definition and Usage Abstract Syntax
OMG Systems Modeling Language (SysML) v2.0, Beta 1 239**


**8.3.6.1Overview**

```
+isVariation : Boolean Definition
+namingFeature() : Feature [0..1]{redefines namingFeature}+isVariation : Boolean
```
```
+/isReference : Boolean Usage
```
```
+namingFeature() : Feature [0..1]{redefines namingFeature}+/isReference : Boolean = true{redefines isReference}
```
```
ReferenceUsage
```
```
Classifier Feature
```
```
+/referenceOwningDefinition{subsets owningDefinition}0..1
```
```
{subsets ownedUsage, ordered}
```
```
+/ownedReference0..*
```
```
{subsets typedFeature}
```
```
+/definedUsage0..*
```
```
{redefines type, ordered}
```
```
+/definition0..*
```
```
{subsets ownedFeature, subsets usage, ordered}
```
```
+/ownedUsage0..*
{subsets featuringDefinition, subsets owningType}
```
```
+/owningDefinition
0..1
```
```
{subsets directedFeature, subsets usage, ordered}
```
```
+/directedUsage0..*
{subsets featuringDefinition, subsets typeWithDirectedFeature}
0..*+/definitionWithDirectedUsage
```
```
{subsets feature, ordered}
```
```
+/usage0..*
{subsets typeWithFeature}
```
```
+/featuringDefinition0..* {subsets typeWithFeature}
0..*/featuringUsage
```
```
{subsets feature, ordered}
```
```
+/usage0..*
```
```
{subsets directedFeature, subsets usage, ordered}
```
```
+/directedUsage0..*
```
```
/usageWithDirectedUsage
{subsets featuringUsage, subsets
typeWithDirectedFeature}
```
```
0..*
```
```
{subsets ownedFeature, subsets usage, ordered}
```
```
+/nestedUsage0..*
```
```
{subsets owningType}
```
```
+/owningUsage0..1
```
```
+/referenceOwningUsage{subsets owningUsage}0..1
{subsets nestedUsage, ordered}
+/nestedReference0..*
```
**Figure 8. Definition and Usage**

```
VariantMembership
```
```
OwningMembership Definition
```
```
Usage
{subsets ownedMembership}
0..*+/variantMembership
{subsets membershipOwningNamespace}
```
```
+/owningVariationUsage
0..1
```
```
{redefines ownedMemberElement}
```
```
+/ownedVariantUsage
{subsets owningMembership}+/owningVariantMembership0..1^1
```
```
{subsets membershipOwningNamespace}
```
```
+/owningVariationDefinition
0..1
```
```
0..* {subsets ownedMembership}+/variantMembership
```
```
{subsets owningNamespace}
```
```
+/owningVariationUsage
0..1
```
```
{subsets ownedMember}
```
```
+/variant
0..*
```
```
+/owningVariationDefinition
{subsets owningNamespace}0..1
```
```
+/variant{subsets ownedMember}0..*
```
**Figure 9. Variant Membership
8.3.6.2Definition
Description**
ADefinitionis aClassifierofUsages. The actual kinds ofDefinitionthat may appear in a model are
given by the subclasses ofDefinition(possibly as extended with user-defined _SemanticMetadata_ ).

**240 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Normally, aDefinitionhas owned Usages that modelfeaturesof the thing being defined. ADefinitionmay
also have otherDefinitionsnested in it, but this has no semantic significance, other than the nested scoping
resulting from theDefinitionbeing considered as aNamespacefor any nestedDefinitions.
However, if aDefinitionhasisVariation=true, then it represents a _variation point_ Definition. In this
case, all of itsmembersmust bevariantUsages, related to theDefinitionbyVariantMembership
Relationships. Rather than beingfeaturesof theDefinition,variantUsagesmodel different concrete
alternatives that can be chosen to fill in for an abstractUsageof the variation pointDefinition.
**General Classes**
Classifier
**Attributes**
/directedUsage : Usage [0..*] {subsets usage, directedFeature, ordered}
Theusagesof thisDefinitionthat aredirectedFeatures.
isVariation : Boolean
Whether thisDefinitionis for a variation point or not. If true, then all themembershipsof theDefinition
must beVariantMemberships.
/ownedAction : ActionUsage [0..*] {subsets ownedOccurrence, ordered}
TheActionUsagesthat areownedUsagesof thisDefinition.
/ownedAllocation : AllocationUsage [0..*] {subsets ownedConnection, ordered}
TheAllocationUsagesthat areownedUsagesof thisDefinition.
/ownedAnalysisCase : AnalysisCaseUsage [0..*] {subsets ownedCase, ordered}
TheAnalysisCaseUsagesthat areownedUsagesof thisDefinition.
/ownedAttribute : AttributeUsage [0..*] {subsets ownedUsage, ordered}
TheAttributeUsagesthat areownedUsagesof thisDefinition.
/ownedCalculation : CalculationUsage [0..*] {subsets ownedAction, ordered}
TheCalculationUsagesthat areownedUsagesof thisDefinition.
/ownedCase : CaseUsage [0..*] {subsets ownedCalculation, ordered}
The code>CaseUsages that areownedUsagesof thisDefinition.
/ownedConcern : ConcernUsage [0..*] {subsets ownedRequirement}
TheConcernUsagesthat areownedUsagesof thisDefinition.
/ownedConnection : ConnectorAsUsage [0..*] {subsets ownedPart, ordered}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 241**


TheConnectorAsUsagesthat areownedUsagesof thisDefinition. Note that this list includes
BindingConnectorAsUsagesandSuccessionAsUsages, even though these areConnectorAsUsagesbut not
ConnectionUsages.
/ownedConstraint : ConstraintUsage [0..*] {subsets ownedOccurrence, ordered}
TheConstraintUsagesthat areownedUsagesof thisDefinition.
/ownedEnumeration : EnumerationUsage [0..*] {subsets ownedAttribute, ordered}
TheEnumerationUsagesthat areownedUsagesof thisDefinition.
/ownedFlow : FlowConnectionUsage [0..*] {subsets ownedConnection}
TheFlowConnectionUsagesthat areownedUsagesof thisDefinition.
/ownedInterface : InterfaceUsage [0..*] {subsets ownedConnection, ordered}
TheInterfaceUsagesthat areownedUsagesof thisDefinition.
/ownedItem : ItemUsage [0..*] {subsets ownedOccurrence, ordered}
TheItemUsagesthat areownedUsagesof thisDefinition.
/ownedMetadata : MetadataUsage [0..*] {subsets ownedItem, ordered}
TheMetadataUsagesthat areownedUsagesof thisDefinition.
/ownedOccurrence : OccurrenceUsage [0..*] {subsets ownedUsage, ordered}
TheOccurrenceUsagesthat areownedUsagesof thisDefinition.
/ownedPart : PartUsage [0..*] {subsets ownedItem, ordered}
ThePartUsagesthat areownedUsagesof thisDefinition.
/ownedPort : PortUsage [0..*] {subsets ownedUsage, ordered}
ThePortUsagesthat areownedUsagesof thisDefinition.
/ownedReference : ReferenceUsage [0..*] {subsets ownedUsage, ordered}
TheReferenceUsagesthat areownedUsagesof thisDefinition.
/ownedRendering : RenderingUsage [0..*] {subsets ownedPart, ordered}
TheRenderingUsagesthat areownedUsagesof thisDefinition.
/ownedRequirement : RequirementUsage [0..*] {subsets ownedConstraint, ordered}
TheRequirementUsagesthat areownedUsagesof thisDefinition.
/ownedState : StateUsage [0..*] {subsets ownedAction, ordered}
TheStateUsagesthat areownedUsagesof thisDefinition.

**242 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


/ownedTransition : TransitionUsage [0..*] {subsets ownedUsage}
TheTransitionUsagesthat areownedUsagesof thisDefinition.
/ownedUsage : Usage [0..*] {subsets ownedFeature, usage, ordered}
TheUsagesthat areownedFeaturesof thisDefinition.
/ownedUseCase : UseCaseUsage [0..*] {subsets ownedCase, ordered}
TheUseCaseUsagesthat areownedUsagesof thisDefinition.
/ownedVerificationCase : VerificationCaseUsage [0..*] {subsets ownedCase, ordered}
TheVerificationCaseUsagesthat areownedUsagesof thisDefinition.
/ownedView : ViewUsage [0..*] {subsets ownedPart, ordered}
TheViewUsagesthat areownedUsagesof thisDefinition.
/ownedViewpoint : ViewpointUsage [0..*] {subsets ownedRequirement, ordered}
TheViewpointUsagesthat areownedUsagesof thisDefinition.
/usage : Usage [0..*] {subsets feature, ordered}
TheUsagesthat arefeaturesof thisDefinition(not necessarily owned).
/variant : Usage [0..*] {subsets ownedMember}
TheUsageswhich represent the variants of thisDefinitionas a variation pointDefinition, ifisVariation=
true. IfisVariation = false, the there must be novariants.
/variantMembership : VariantMembership [0..*] {subsets ownedMembership}
TheownedMembershipsof thisDefinitionthat areVariantMemberships. IfisVariation= true, then this
must be allownedMembershipsof theDefinition. IfisVariation= false, thenvariantMembershipmust be
empty.
**Operations**
None.
**Constraints**
deriveDefinitionDirectedUsage
ThedirectedUsagesof aDefinitionare all itsdirectedFeaturesthat areUsages.
directedUsage = directedFeature->selectByKind(Usage)
deriveDefinitionOwnedAction
TheownedActionsof aDefinitionare all itsownedUsagesthat areActionUsages.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 243**


ownedAction = ownedUsage->selectByKind(ActionUsage)
deriveDefinitionOwnedAllocation
TheownedAllocationsof aDefinitionare all itsownedUsagesthat areAllocationUsages.
ownedAllocation = ownedUsage->selectByKind(AllocationUsage)
deriveDefinitionOwnedAnalysisCase
TheownedAnalysisCasesof aDefinitionare all itsownedUsagesthat areAnalysisCaseUsages.
ownedAnalysisCase = ownedUsage->selectByKind(AnalysisCaseUsage)
deriveDefinitionOwnedAttribute
TheownedAttributesof aDefinitionare all itsownedUsagesthat areAttributeUsages.
ownedAttribute = ownedUsage->selectByKind(AttributeUsage)
deriveDefinitionOwnedCalculation
TheownedCalculationsof aDefinitionare all itsownedUsagesthat areCalculationUsages.
ownedCalculation = ownedUsage->selectByKind(CalculationUsage)
deriveDefinitionOwnedCase
TheownedCasesof aDefinitionare all itsownedUsagesthat areCaseUsages.
ownedCase = ownedUsage->selectByKind(CaseUsage)
deriveDefinitionOwnedConcern
TheownedConcernsof aDefinitionare all itsownedUsagesthat areConcernUsages.
ownedConcern = ownedUsage->selectByKind(ConcernUsage)
deriveDefinitionOwnedConnection
TheownedConnectionsof aDefinitionare all itsownedUsagesthat areConnectorAsUsages.
ownedConnection = ownedUsage->selectByKind(ConnectorAsUsage)
deriveDefinitionOwnedConstraint
TheownedConstraintsof aDefinitionare all itsownedUsagesthat areConstraintUsages.
ownedConstraint = ownedUsage->selectByKind(ConstraintUsage)
deriveDefinitionOwnedEnumeration
TheownedEnumerationsof aDefinitionare all itsownedUsagesthat areEnumerationUsages.
ownedEnumeration = ownedUsage->selectByKind(EnumerationUsage)

**244 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


deriveDefinitionOwnedFlow
TheownedFlowsof aDefinitionare all itsownedUsagesthat areFlowConnectionUsages.
ownedFlow = ownedUsage->selectByKind(FlowUsage)
deriveDefinitionOwnedInterface
TheownedInterfacesof aDefinitionare all itsownedUsagesthat areInterfaceUsages.
ownedInterface = ownedUsage->selectByKind(ReferenceUsage)
deriveDefinitionOwnedItem
TheownedItemsof aDefinitionare all itsownedUsagesthat areItemUsages.
ownedItem = ownedUsage->selectByKind(ItemUsage)
deriveDefinitionOwnedMetadata
TheownedMetadataof aDefinitionare all itsownedUsagesthat areMetadataUsages.
ownedMetadata = ownedUsage->selectByKind(MetadataUsage)
deriveDefinitionOwnedOccurrence
TheownedOccurrencesof aDefinitionare all itsownedUsagesthat areOccurrenceUsages.
ownedOccurrence = ownedUsage->selectByKind(OccurrenceUsage)
deriveDefinitionOwnedPart
TheownedPartsof aDefinitionare all itsownedUsagesthat arePartUsages.
ownedPart = ownedUsage->selectByKind(PartUsage)
deriveDefinitionOwnedPort
TheownedPortsof aDefinitionare all itsownedUsagesthat arePortUsages.
ownedPort = ownedUsage->selectByKind(PortUsage)
deriveDefinitionOwnedReference
TheownedReferencesof aDefinitionare all itsownedUsagesthat areReferenceUsages.
ownedReference = ownedUsage->selectByKind(ReferenceUsage)
deriveDefinitionOwnedRendering
TheownedRenderingsof aDefinitionare all itsownedUsagesthat areRenderingUsages.
ownedRendering = ownedUsage->selectByKind(RenderingUsage)
deriveDefinitionOwnedRequirement

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 245**


TheownedRequirementsof aDefinitionare all itsownedUsagesthat areRequirementUsages.
ownedRequirement = ownedUsage->selectByKind(RequirementUsage)
deriveDefinitionOwnedState
TheownedStatesof aDefinitionare all itsownedUsagesthat areStateUsages.
ownedState = ownedUsage->selectByKind(StateUsage)
deriveDefinitionOwnedTransition
TheownedTransitionsof aDefinitionare all itsownedUsagesthat areTransitionUsages.
ownedTransition = ownedUsage->selectByKind(TransitionUsage)
deriveDefinitionOwnedUsage
TheownedUsagesof aDefinitionare all itsownedFeaturesthat areUsages.
ownedUsage = ownedFeature->selectByKind(Usage)
deriveDefinitionOwnedUseCase
TheownedUseCasesof aDefinitionare all itsownedUsagesthat areUseCaseUsages.
ownedUseCase = ownedUsage->selectByKind(UseCaseUsage)
deriveDefinitionOwnedVerificationCase
TheownedValidationCasesof aDefinitionare all itsownedUsagesthat areValidationCaseUsages.
ownedVerificationCase = ownedUsage->selectByKind(VerificationCaseUsage)
deriveDefinitionOwnedView
TheownedViewsof aDefinitionare all itsownedUsagesthat areViewUsages.
ownedView = ownedUsage->selectByKind(ViewUsage)
deriveDefinitionOwnedViewpoint
TheownedViewpointsof aDefinitionare all itsownedUsagesthat areViewpointUsages.
ownedViewpoint = ownedUsage->selectByKind(ViewpointUsage)
deriveDefinitionUsage
Theusagesof aDefinitionare all itsfeaturesthat areUsages.
usage = feature->selectByKind(Usage)
deriveDefinitionVariant
Thevariantsof aDefinitionare theownedVariantUsagesof itsvariantMemberships.

**246 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


variant = variantMembership.ownedVariantUsage
deriveDefinitionVariantMembership
ThevariantMembershipsof aDefinitionare thoseownedMembershipsthat areVariantMemberships.
variantMembership = ownedMembership->selectByKind(VariantMembership)
validateDefinitionNonVariationMembership
ADefinitionthat is not a variation must not have anyvariantMemberships.
not isVariation implies variantMembership->isEmpty()
validateDefinitionVariationMembership
If aDefinitionis a variation, then all itsownedMembershipsmust beVariantMemberships.
isVariation implies variantMembership = ownedMembership
validateDefinitionVariationSpecialization
A variationDefinitionmay not specialize any other variationDefinition.
isVariation impliesnot ownedSpecialization.specific->exists(isVariation)

**8.3.6.3ReferenceUsage
Description**
AReferenceUsageis aUsagethat specifies a non-compositional (isComposite = false) reference to
something. Thedefinitionof aReferenceUsagecan be any kind ofClassifier, with the default being the
top-levelClassifier _Base::Anything_ from the Kernel Semantic Library. This allows the specification of a
generic reference without distinguishing if the thing referenced is an attribute value, item, action, etc.
**General Classes**
Usage
**Attributes**
/isReference : Boolean {redefines isReference}
Alwaystruefor aReferenceUsage.
**Operations**
namingFeature() : Feature [0..1]
If thisReferenceUsageis the _payload_ parameterof aTransitionUsage, then its namingFeatureis the
payloadParameterof thetriggerActionof thatTransitionUsage(if any).
**body** : if owningType <> null and owningType.oclIsKindOf(TransitionUsage) andowningType.oclAsType(TransitionUsage).inputParameter(2) = self then
owningType.oclAsType(TransitionUsage).triggerPayloadParameter()

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 247**


else self.oclAsType(Usage).namingFeature()endif

**Constraints**
validateReferenceUsageIsReference
AReferenceUsageis always referential.
isReference
**8.3.6.4Usage
Description**
AUsageis a usage of aDefinition. AUsagemay only be anownedFeatureof aDefinitionor another
Usage.
AUsagemay havenestedUsagesthat modelfeaturesthat apply in the context of theowningUsage. AUsage
may also haveDefinitionsnested in it, but this has no semantic significance, other than the nested scoping
resulting from theUsagebeing considered as aNamespacefor any nestedDefinitions.
However, if aUsagehasisVariation = true, then it represents a _variation point_ Usage. In this case, all of its
membersmust bevariantUsages, related to theUsagebyVariantMembershipRelationships. Rather than
beingfeaturesof theUsage,variantUsagesmodel different concrete alternatives that can be chosen to fill in
for the variation pointUsage.
**General Classes**
Feature
**Attributes**
/definition : Classifier [0..*] {redefines type, ordered}
TheClassifiersthat are the types of thisUsage. Nominally, these areDefinitions, but other kinds of Kernel
Classifiersare also allowed, to permit use ofClassifiersfrom the Kernel Model Libraries.
/directedUsage : Usage [0..*] {subsets usage, directedFeature, ordered}
Theusagesof thisUsagethat aredirectedFeatures.
/isReference : Boolean
Whether thisUsageis a referentialUsage, that is, it hasisComposite = false.
isVariation : Boolean
Whether thisUsageis for a variation point or not. If true, then all themembershipsof theUsagemust be
VariantMemberships.
/nestedAction : ActionUsage [0..*] {subsets nestedOccurrence, ordered}
TheActionUsagesthat arenestedUsagesof thisUsage.

**248 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


/nestedAllocation : AllocationUsage [0..*] {subsets nestedConnection, ordered}
TheAllocationUsagesthat arenestedUsagesof thisUsage.
/nestedAnalysisCase : AnalysisCaseUsage [0..*] {subsets nestedCase, ordered}
TheAnalysisCaseUsagesthat arenestedUsagesof thisUsage.
/nestedAttribute : AttributeUsage [0..*] {subsets nestedUsage, ordered}
The code>AttributeUsages that arenestedUsagesof thisUsage.
/nestedCalculation : CalculationUsage [0..*] {subsets nestedAction, ordered}
TheCalculationUsagethat arenestedUsagesof thisUsage.
/nestedCase : CaseUsage [0..*] {subsets nestedCalculation, ordered}
TheCaseUsagesthat arenestedUsagesof thisUsage.
/nestedConcern : ConcernUsage [0..*] {subsets nestedRequirement}
TheConcernUsagesthat arenestedUsagesof thisUsage.
/nestedConnection : ConnectorAsUsage [0..*] {subsets nestedPart, ordered}
TheConnectorAsUsagesthat arenestedUsagesof thisUsage. Note that this list includes
BindingConnectorAsUsagesandSuccessionAsUsages, even though these areConnectorAsUsagesbut not
ConnectionUsages.
/nestedConstraint : ConstraintUsage [0..*] {subsets nestedOccurrence, ordered}
TheConstraintUsagesthat arenestedUsagesof thisUsage.
/nestedEnumeration : EnumerationUsage [0..*] {subsets nestedAttribute, ordered}
The code>EnumerationUsages that arenestedUsagesof thisUsage.
/nestedFlow : FlowConnectionUsage [0..*] {subsets nestedConnection}
The code>FlowConnectionUsages that arenestedUsagesof thisUsage.
/nestedInterface : InterfaceUsage [0..*] {subsets nestedConnection, ordered}
TheInterfaceUsagesthat arenestedUsagesof thisUsage.
/nestedItem : ItemUsage [0..*] {subsets nestedOccurrence, ordered}
TheItemUsagesthat arenestedUsagesof thisUsage.
/nestedMetadata : MetadataUsage [0..*] {subsets nestedItem, ordered}
TheMetadataUsagesthat arenestedUsagesof this of thisUsage.
/nestedOccurrence : OccurrenceUsage [0..*] {subsets nestedUsage, ordered}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 249**


TheOccurrenceUsagesthat arenestedUsagesof thisUsage.
/nestedPart : PartUsage [0..*] {subsets nestedItem, ordered}
ThePartUsagesthat arenestedUsagesof thisUsage.
/nestedPort : PortUsage [0..*] {subsets nestedUsage, ordered}
ThePortUsagesthat arenestedUsagesof thisUsage.
/nestedReference : ReferenceUsage [0..*] {subsets nestedUsage, ordered}
TheReferenceUsagesthat arenestedUsagesof thisUsage.
/nestedRendering : RenderingUsage [0..*] {subsets nestedPart, ordered}
TheRenderingUsagesthat arenestedUsagesof thisUsage.
/nestedRequirement : RequirementUsage [0..*] {subsets nestedConstraint, ordered}
TheRequirementUsagesthat arenestedUsagesof thisUsage.
/nestedState : StateUsage [0..*] {subsets nestedAction, ordered}
TheStateUsagesthat arenestedUsagesof thisUsage.
/nestedTransition : TransitionUsage [0..*] {subsets nestedUsage}
TheTransitionUsagesthat arenestedUsagesof thisUsage.
/nestedUsage : Usage [0..*] {subsets ownedFeature, usage, ordered}
TheUsagesthat areownedFeaturesof thisUsage.
/nestedUseCase : UseCaseUsage [0..*] {subsets nestedCase, ordered}
TheUseCaseUsagesthat arenestedUsagesof thisUsage.
/nestedVerificationCase : VerificationCaseUsage [0..*] {subsets nestedCase, ordered}
TheVerificationCaseUsagesthat arenestedUsagesof thisUsage.
/nestedView : ViewUsage [0..*] {subsets nestedPart, ordered}
TheViewUsagesthat arenestedUsagesof thisUsage.
/nestedViewpoint : ViewpointUsage [0..*] {subsets nestedRequirement, ordered}
TheViewpointUsagesthat arenestedUsagesof thisUsage.
/owningDefinition : Definition [0..1] {subsets owningType, featuringDefinition}
TheDefinitionthat owns thisUsage(if any).
/owningUsage : Usage [0..1] {subsets owningType}

**250 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


TheUsagein which thisUsageis nested (if any).
/usage : Usage [0..*] {subsets feature, ordered}
TheUsagesthat arefeaturesof thisUsage(not necessarily owned).
/variant : Usage [0..*] {subsets ownedMember}
TheUsageswhich represent the variants of thisUsageas a variation pointUsage, ifisVariation = true. If
isVariation = false, then there must be novariants.
/variantMembership : VariantMembership [0..*] {subsets ownedMembership}
TheownedMembershipsof thisUsagethat areVariantMemberships. IfisVariation = true, then this must
be allmembershipsof theUsage. IfisVariation = false, thenvariantMembershipmust be empty.
**Operations**
namingFeature() : Feature [0..1]
If thisUsageis a variant, then its namingFeatureis thereferencedFeatureof its
ownedReferenceSubsetting.
**body** : if not owningMembership.oclIsKindOf(VariantMembership) thenself.oclAsType(Feature).namingFeature()
else if ownedReferenceSubsetting = null then nullelse ownedReferenceSubsetting.referencedFeature
endif endif
**Constraints**
checkUsageVariationDefinitionSpecialization
If aUsagehas anowningVariationDefinition, then it must directly or indirectly specialize thatDefinition.
owningVariationDefinition <> null impliesspecializes(owningVariationDefinition)

checkUsageVariationUsageSpecialization
If aUsagehas anowningVariationUsage, then it must directly or indirectly specialize thatUsage.
owningVariationUsage <> null impliesspecializes(owningVariationUsage)

deriveUsageDirectedUsage
ThedirectedUsagesof aUsageare all itsdirectedFeaturesthat areUsages.
directedUsage = directedFeature->selectByKind(Usage)
deriveUsageIsReference
AUsageis referential if it is not composite.
isReference = not isComposite

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 251**


deriveUsageNestedAction
TheownedActionsof aUsageare all itsownedUsagesthat areActionUsages.
nestedAction = nestedUsage->selectByKind(ActionUsage)
deriveUsageNestedAllocation
TheownedAllocationsof aUsageare all itsownedUsagesthat areAllocationUsages.
nestedAllocation = nestedUsage->selectByKind(AllocationUsage)
deriveUsageNestedAnalysisCase
TheownedAnalysisCasesof aUsageare all itsownedUsagesthat areAnalysisCaseUsages.
nestedAnalysisCase = nestedUsage->selectByKind(AnalysisCaseUsage)
deriveUsageNestedAttribute
TheownedAttributesof aUsageare all itsownedUsagesthat areAttributeUsages.
nestedAttribute = nestedUsage->selectByKind(AttributeUsage)
deriveUsageNestedCalculation
TheownedCalculationsof aUsageare all itsownedUsagesthat areCalculationUsages.
nestedCalculation = nestedUsage->selectByKind(CalculationUsage)
deriveUsageNestedCase
TheownedCasesof aUsageare all itsownedUsagesthat areCaseUsages.
nestedCase = nestedUsage->selectByKind(CaseUsage)
deriveUsageNestedConcern
TheownedConcernsof aUsageare all itsownedUsagesthat areConcernUsages.
nestedConcern = nestedUsage->selectByKind(ConcernUsage)
deriveUsageNestedConnection
TheownedConnectionsof aUsageare all itsownedUsagesthat areConnectorAsUsages.
nestedConnection = nestedUsage->selectByKind(ConnectorAsUsage)
deriveUsageNestedConstraint
TheownedConstraintsof aUsageare all itsownedUsagesthat areConstraintUsages.
nestedConstraint = nestedUsage->selectByKind(ConstraintUsage)
deriveUsageNestedEnumeration

**252 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


TheownedEnumerationsof aUsageare all itsownedUsagesthat areEnumerationUsages.
ownedNested = nestedUsage->selectByKind(EnumerationUsage)
deriveUsageNestedFlow
TheownedFlowsof aUsageare all itsownedUsagesthat areFlowConnectionUsages.
nestedFlow = nestedUsage->selectByKind(FlowUsage)
deriveUsageNestedInterface
TheownedInterfacesof aUsageare all itsownedUsagesthat areInterfaceUsages.
nestedInterface = nestedUsage->selectByKind(ReferenceUsage)
deriveUsageNestedItem
TheownedItemsof aUsageare all itsownedUsagesthat areItemUsages.
nestedItem = nestedUsage->selectByKind(ItemUsage)
deriveUsageNestedMetadata
TheownedMetadataof aUsageare all itsownedUsagesthat areMetadataUsages.
nestedMetadata = nestedUsage->selectByKind(MetadataUsage)
deriveUsageNestedOccurrence
TheownedOccurrencesof aUsageare all itsownedUsagesthat areOccurrenceUsages.
nestedOccurrence = nestedUsage->selectByKind(OccurrenceUsage)
deriveUsageNestedPart
TheownedPartsof aUsageare all itsownedUsagesthat arePartUsages.
nestedPart = nestedUsage->selectByKind(PartUsage)
deriveUsageNestedPort
TheownedPortsof aUsageare all itsownedUsagesthat arePortUsages.
nestedPort = nestedUsage->selectByKind(PortUsage)
deriveUsageNestedReference
TheownedReferencesof aUsageare all itsownedUsagesthat areReferenceUsages.
nestedReference = nestedUsage->selectByKind(ReferenceUsage)
deriveUsageNestedRendering
TheownedRenderingsof aUsageare all itsownedUsagesthat areRenderingUsages.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 253**


nestedRendering = nestedUsage->selectByKind(RenderingUsage)
deriveUsageNestedRequirement
TheownedRequirementsof aUsageare all itsownedUsagesthat areRequirementUsages.
nestedRequirement = nestedUsage->selectByKind(RequirementUsage)
deriveUsageNestedState
TheownedStatesof aUsageare all itsownedUsagesthat areStateUsages.
nestedState = nestedUsage->selectByKind(StateUsage)
deriveUsageNestedTransition
TheownedTransitionsof aUsageare all itsownedUsagesthat areTransitionUsages.
nestedTransition = nestedUsage->selectByKind(TransitionUsage)
deriveUsageNestedUsage
TheownedUsagesof aUsageare all itsownedFeaturesthat areUsages.
nestedUsage = ownedFeature->selectByKind(Usage)
deriveUsageNestedUseCase
TheownedUseCasesof aUsageare all itsownedUsagesthat areUseCaseUsages.
nestedUseCase = nestedUsage->selectByKind(UseCaseUsage)
deriveUsageNestedVerificationCase
TheownedValidationCasesof aUsageare all itsownedUsagesthat areValidationCaseUsages.
nestedVerificationCase = nestedUsage->selectByKind(VerificationCaseUsage)
deriveUsageNestedView
TheownedViewsof aUsageare all itsownedUsagesthat areViewUsages.
nestedView = nestedUsage->selectByKind(ViewUsage)
deriveUsageNestedViewpoint
TheownedViewpointsof aUsageare all itsownedUsagesthat areViewpointUsages.
nestedViewpoint = nestedUsage->selectByKind(ViewpointUsage)
deriveUsageUsage
Theusagesof aUsageare all itsfeaturesthat areUsages.
usage = feature->selectByKind(Usage)

**254 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


deriveUsageVariant
Thevariantsof aUsageare theownedVariantUsagesof itsvariantMemberships.
variant = variantMembership.ownedVariantUsage
deriveUsageVariantMembership
ThevariantMembershipsof aUsageare thoseownedMembershipsthat areVariantMemberships.
variantMembership = ownedMembership->selectByKind(VariantMembership)
validateUsageNonVariationMembership
AUsagethat is not a variation must not have anyvariantMemberships.
not isVariation implies variantMembership->isEmpty()
validateUsageOwningType
If aUsagehas anowningType, it must be aDefinitionorUsage.
owningType <> null implies(owningType.oclIsKindOf(Definition) or
ownigType.oclIsKindOf(Usage))
validateUsageVariationMembership
If aUsageis a variation, then all itsownedMembershipsmust beVariantMemberships.
isVariation implies variantMembership = ownedMembership
validateUsageVariationSpecialization
A variationUsagemay not specialize any variationDefinitionorUsage.
isVariation impliesnot ownedSpecialization.specific->exists(isVariation)

**8.3.6.5VariantMembership
Description**
AVariantMembershipis aMembershipbetween a variation pointDefinitionorUsageand aUsagethat
represents a variant in the context of that variation. ThemembershipOwningNamespacefor the
VariantMembershipmust be either a Definition or aUsagewithisVariation = true.
**General Classes**
OwningMembership
**Attributes**
/ownedVariantUsage : Usage {redefines ownedMemberElement}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 255**


TheUsagethat represents a variant in the context of theowningVariationDefinitionor
owningVariationUsage.
**Operations**
None.
**Constraints**
validateVariantMembershipOwningNamespace
ThemembershipOwningNamespaceof aVariantMembershipmust be a variation-pointDefinitionorUsage.
membershipOwningNamespace.oclIsKindOf(Definition) andmembershipOwningNamespace.oclAsType(Definition).isVariation or
membershipOwningNamespace.oclIsKindOf(Usage) andmembershipOwningNamespace.oclAsType(Usage).isVariation

**8.3.7Attributes Abstract Syntax
8.3.7.1Overview**

```
+/isReference : Boolean = true{redefines isReference}
```
```
AttributeUsage
```
```
Usage
```
```
AttributeDefinition
```
```
Definition
```
```
DataType
{redefines definition, ordered}
```
```
+/attributeDefinition
0..*
```
```
{subsets definedUsage}
```
```
+/definedAttribute0..*
```
```
+/attributeOwningDefinition
{subsets owningDefinition}
```
```
0..1
```
```
{subsets ownedUsage, ordered}
```
```
+/ownedAttribute
0..*
```
```
+/attributeOwningUsage
{subsets owningUsage}
```
```
0..1
{subsets nestedUsage, ordered}
+/nestedAttribute0..*
```
**Figure 10. Attribute Definition and Usage
8.3.7.2AttributeUsage
Description**
AnAttributeUsageis aUsagewhose type is a DataType. Nominally, if the type is an
AttributeDefinition, anAttributeUsageis a usage of aAttributeDefinitionto
represent the value of some system quality or characteristic. However, other kinds of
kernel DataTypesare also allowed, to permit use ofDataTypesfrom the Kernel Model
Libraries. An AttributeUsageitself as well as all its nestedfeaturesmust be
referential (non-composite).
AnAttributeUsagemust specialize, directly or indirectly, the baseFeature
_Base::dataValues from the Kernel Semantic Library._

**256 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Classes**
Usage
**Attributes**
/attributeDefinition : DataType [0..*] {redefines definition, ordered}
TheDataTypesthat are the types of thisAttributeUsage. Nominally, these areAttributeDefinitions, but
other kinds of kernelDataTypesare also allowed, to permit use ofDataTypes,/code> from the Kernel
Model Libraries.
/isReference : Boolean {redefines isReference}
Always true for anAttributeUsage.
**Operations**
None.
**Constraints**
checkAttributeUsageSpecialization
AnAttributeUsagemust directly or indirectly specialize _Base::dataValues_ from the Kernel Semantic
Library.
specializesFromLibrary("Base::dataValues")
validateAttributeUsageFeatures
Allfeaturesof anAttributeUsagemust be non-composite.
feature->forAll(not isComposite)
validateAttributeUsageIsReference
AnAttributeUsageis always referential.
isReference
**8.3.7.3AttributeDefinition
Description**
AnAttributeDefinitionis aDefinitionand aDataTypeof information about a quality or characteristic of a
system or part of a system that has no independent identity other than its value. Allfeaturesof an
AttributeDefinitionmust be referential (non-composite).
As aDataType, anAttributeDefinitionmust specialize, directly or indirectly, the baseDataType
_Base::DataValue_ from the Kernel Semantic Library.
**General Types**
Definition

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 257**


DataType
**Features**
None.
**Constraints**
validateAttributeDefinitionFeatures
Allfeaturesof anAttributeDefinitionmust be non-composite.
feature->forAll(not isComposite)

**8.3.8Enumerations Abstract Syntax
8.3.8.1Overview**

```
+isVariation : Boolean = true{redefines isVariation} EnumerationDefinition EnumerationUsage
```
```
AttributeDefinition
```
```
Definition Usage
```
```
AttributeUsage
```
```
+/enumerationOwningDefinition
{subsets attributeOwningDefinition}0..1
```
```
{subsets ownedAttribute, ordered}
```
```
+/ownedEnumeration0..*
```
```
{subsets owningVariationDefinition}
```
```
+/owningEnumerationDefinition0..1
{redefines variant, ordered}
```
```
+/enumeratedValue0..*
```
```
{redefines attributeDefinition}
```
```
+/enumerationDefinition 1
{subsets definedAttribute}
```
```
+/definedEnumeration0..*
```
```
{subsets nestedAttribute, ordered}
0..*+/nestedEnumeration
```
```
+/enumerationOwningUsage
{subsets attributeOwningUsage}0..1
```
**Figure 11. Enumeration Definition and Usage
8.3.8.2EnumerationDefinition
Description**
AnEnumerationDefinitionis anAttributeDefinitionall of whose instances are given by an explicit list of
enumeratedValues. This is realized by requiring that theEnumerationDefinitionhaveisVariation =
true, with theenumeratedValuesbeing itsvariants.
**General Classes**
AttributeDefinition
**Attributes**
/enumeratedValue : EnumerationUsage [0..*] {redefines variant, ordered}

**258 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


EnumerationUsagesof thisEnumerationDefinitionthat have distinct, fixed values. EachenumeratedValue
specifies one of the allowed instances of theEnumerationDefinition.
isVariation : Boolean {redefines isVariation}
An EnumerationDefinition is considered semantically to be a variation whose allowed variants are its
enumerationValues.
**Operations**
None.
**Constraints**
validateEnumerationDefinitionIsVariation
AnEnumerationDefinitionmust be a variation.
isVariation
**8.3.8.3EnumerationUsage
Description**
AnEnumerationUsageis anAttributeUsagewhoseattributeDefinitionis an
EnumerationDefinition.
**General Classes**
AttributeUsage
**Attributes**
/enumerationDefinition : EnumerationDefinition {redefines attributeDefinition}
The single EnumerationDefinition that is the type of this EnumerationUsage.
**Operations**
None.
**Constraints**
None.

**8.3.9Occurrences Abstract Syntax**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 259**


**8.3.9.1Overview**

```
+effectiveName() : String [0..1]{redefines effectiveName}
```
```
+isSufficient : Boolean = true{redefines isSufficient} LifeClass
```
```
+portionKind : PortionKind [0..1]+isIndividual : Boolean = false
```
```
OccurrenceUsage
```
```
Usage
```
```
+isIndividual : Boolean = false OccurrenceDefinition
```
```
snapshottimeslice
```
```
«enumeration» PortionKind
```
```
Definition
```
```
Class
```
```
+/occurrenceOwningDefinition
{subsets owningDefinition}0..1
```
```
{subsets ownedUsage, ordered}
```
```
+/ownedOccurrence0..*
```
```
{subsets definedUsage}
```
```
+/occurrenceDefinition +/definedOccurrence0..*
{redefines definition, ordered}0..*
```
```
{subsets occurrenceDefinition}
0..1+/individualDefinition +/individualUsage0..*
```
```
{subsets ownedMember}
```
```
+/lifeClass0..1
```
```
{subsets owningNamespace}
```
```
+/individualDefinition0..1
```
```
{subsets nestedUsage, ordered}+/nestedOccurrence0..*
```
```
+/occurrenceOwningUsage{subsets owningUsage}0..1
```
**Figure 12. Occurrence Definition and Usage**

```
+/isReference : Boolean = true{redefines isReference}
```
```
EventOccurrenceUsage
```
```
+/eventOccurrence 1 OccurrenceUsage
```
```
+/referencingOccurrence
0..*
```
**Figure 13. Event Occurrences
8.3.9.2EventOccurrenceUsage
Description**
AnEventOccurrenceUsageis anOccurrenceUsagethat represents anotherOccurrenceUsageoccurring
as a _suboccurrence of the containing occurrence of theEventOccurrenceUsage. Unless it
is the EventOccurrenceUsageitself, the referencedOccurrenceUsage is related to the
EventOccurrenceUsageby aReferenceSubsettingRelationship.
If thethen it also subsets theEventOccurrenceUsagetimeEnclosedOccurrencesis owned by anOccurrenceDefinitionproperty of theorClassOccurrenceUsageOccurrence ,from
the Kernel Semantic Library model Occurrences._
**General Classes**
OccurrenceUsage
**Attributes**
/eventOccurrence : OccurrenceUsage

**260 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


TheOccurrenceUsagereferenced as an event by thisEventOccurrenceUsage. It is thereferenceFeatureof
theownedReferenceSubsettingfor theEventOccurrenceUsage, if there is one, and, otherwise, the
EventOccurrenceUsageitself.
/isReference : Boolean {redefines isReference}
Always true for anEventOccurrenceUsage.
**Operations**
None.
**Constraints**
checkEventOccurrenceUsageSpecialization
If anEventOccurrenceUsagehas anowningTypethat is anOccurrenceDefinitionorOccurrenceUsage,
then it must directly or indirectly specialize theFeature
_Occurrences::Occurrence::timeEnclosedOccurrences_.
owningType <> null and(owningType.oclIsKindOf(OccurrenceDefinition) or
owningType.oclIsKindOf(OccurrenceUsage)) impliesspecializesFromLibrary("Occurrences::Occurrence::timeEnclosedOccurrences")

deriveEventOccurrenceUsageEventOccurrence
If anEventOccurrenceUsagehas noownedReferenceSubsetting, then itseventOccurrenceis the
EventOccurrenceUsageitself. Otherwise, theeventOccurrenceis thereferencedFeatureof the
ownedReferenceSubsetting(which must be anOccurrenceUsage).
eventOccurrence =if ownedReferenceSubsetting = null then self
else if ownedReferenceSubsetting.referencedFeature.oclIsKindOf(OccurrenceUsage) thenownedReferenceSubsetting.referencedFeature.oclAsType(OccurrenceUsage)
else nullendif endif

validateEventOccurrenceUsageIsReference
AnEventOccurrenceUsagemust be referential.
isReference
validateEventOccurrenceUsageReference
If anEventOccurrenceUsagehas anownedReferenceSubsetting, then itsreferencedFeaturemust be an
OccurrenceUsage.
ownedReferenceSubsetting <> null impliesownedReferenceSubsetting.referencedFeature.oclIsKindOf(OccurrenceUsage)

**8.3.9.3LifeClass
Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 261**


ALifeClass is aClassthat specializes both theClass _Occurrences::Life_ from the Kernel Semantic Library
and a singleOccurrenceDefinition, and has a multiplicity of 0..1. This constrains the
OccurrenceDefinitionbeing specialized to have at most one instance that is a completeLife.
**General Classes**
Class
**Attributes**
isSufficient : Boolean {redefines isSufficient}
Always true for aLifeClass.
**Operations**
effectiveName() : String [0..1]
The name of aLifeClassis _Life._
**body** : "Life"
**Constraints**
checkLifeClassLifeSpecialization
ALifeClassmust specialize theClass _Occurrences::Life_ from the Kernel Semantic Model Library.
specializesFromLibrary("Occurrences::Life")
checkLifeClassMultiplicitySpecialization
Themultiplicityof aLifeClassis _zeroOrOne_.
multiplicity <> null andmultiplicity.specializesFromLibrary("Base::zeroOrOne")

checkLifeClassOccurrenceSpecialization
ALifeClassmust specialize itsindividualDefinition.
specializes(individualDefinition)
validateLifeClassIsSufficient
ALifeClassalways hasisSufficient = true.
isSufficient
**8.3.9.4OccurrenceDefinition
Description**
AnOccurrenceDefinitionis aDefinitionof aClassof individuals that have an independent life over time
and potentially an extent over space. This includes both structural things and behaviors that act on such structures.

**262 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


IfisIndividualis true, then theOccurrenceDefinitionis constrained to represent an individual thing. The
instances of such anOccurrenceDefinitioninclude all spatial and temporal portions of the individual being
represented, but only one of these can be the completeLifeof the individual. All other instances must be portions
of the "maximal portion" that is singleLifeinstance, capturing the conception that all of the instances represent one
individual with a single "identity".
AnOccurrenceDefinitionmust specialize, directly or indirectly, the baseClass _Occurrence_ from the Kernel
Semantic Library.
**General Classes**
Class
Definition
**Attributes**
isIndividual : Boolean
Whether this OccurrenceDefinition is constrained to represent single individual.
/lifeClass : LifeClass [0..1] {subsets ownedMember}
IfisIndividualis true, aLifeClassthat specializes thisOccurrenceDefinition, restricting it to represent an
individual.
**Operations**
None.
**Constraints**
deriveOccurrenceDefinitionLifeClass
ThelifeClassof anOccurrenceDefinitionis its singleownedMemberthat is aLifeClass(if any).
lifeClass =let lifeClasses: OrderedSet(LifeClass) =

```
if lifeClasses->isEmpty() then nullownedMember->selectByKind(LifeClass) in
else lifeClasses->first()endif
```
validateOccurrenceDefinitionLifeClass
If anOccurrenceDefinition hasisIndividual = true, then it has exactly oneownedMember
that is aLifeClass. Otherwise it has none.
let n : Integer = ownedMember->selectByKind(LifeClass) inif isIndividual then n = 1 else n = 0 endif

**8.3.9.5OccurrenceUsage
Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 263**


AnOccurrenceUsageis aUsagewhosetypesare allClasses. Nominally, if atypeis an
OccurrenceDefinition, anOccurrenceUsageis aUsageof thatOccurrenceDefinitionwithin a system.
However, other types of KernelClassesare also allowed, to permit use ofClassesfrom the Kernel Model
Libraries.
**General Classes**
Usage
**Attributes**
/individualDefinition : OccurrenceDefinition [0..1] {subsets occurrenceDefinition}
The at most oneoccurrenceDefinitionthat hasisIndividual = true.
isIndividual : Boolean
Whether thisOccurrenceUsagerepresents the usage of the specific individual (or portion of it) represented by its
individualDefinition.
/occurrenceDefinition : Class [0..*] {redefines definition, ordered}
TheClassesthat are the types of thisOccurrenceUsage. Nominally, these areOccurrenceDefinitions, but
other kinds of kernelClassesare also allowed, to permit use ofClassesfrom the Kernel Model Libraries.
portionKind : PortionKind [0..1]
The kind of (temporal) portion of the life of theoccurrenceDefinitionrepresented by thisOccurrenceUsage,
if it is so restricted.
**Operations**
None.
**Constraints**
checkOccurrenceUsageSpecialization
AnOccurrenceUsagemust directly or indirectly specialize _Occurrences::occurrences_ from the Kernel
Semantic Library.
specializesFromLibrary("Occurrences::occurrences")
checkOccurrenceUsageSuboccurrenceSpecialization
A compositeOccurrenceUsage, whose ownedTypeis aClass, anotherOccurrenceUsage, or any
kind ofFeaturetyped by a Class, must directly or indirectly specialize
_Occurrences::Occurrence::suboccurrences_.
isComposite andowningType <> null and
(owningType.oclIsKindOf(Class) orowningType.oclIsKindOf(OccurrenceUsage) or
owningType.oclIsKindOf(Feature) andowningType.oclAsType(Feature).type->

**264 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


specializesFromLibrary("Occurrences::Occurrence::suboccurrences")exists(oclIsKind(Class))) implies
checkOccurrenceUsageTypeFeaturing
If theportionKindof anOccurrenceUsageis not empty, then, for eachoccurrenceDefinitionof the
OccurrenceUsage, there must be afeaturingTypeof theOccurrenceUsagewhich either is the
occurrenceDefinitionor directly or indirectly specializes it.
portionKind <> null impliesoccurrenceDefinition->forAll(occ |
featuringType->exists(specializes(occ)))
deriveOccurrenceUsageIndividualDefinition
TheindividualDefinitionof anOccurrenceUsageis theoccurrenceDefinitionthat is an
OccurrenceDefinitionwithisIndividual = true, if any.
individualDefinition =let individualDefinitions : OrderedSet(OccurrenceDefinition) =
occurrenceDefinition->selectByKind(OccurrenceDefinition)->
if individualDefinitions->isEmpty() then nullselect(isIndividual) in
else individualDefinitions->first() endif
validateOccurrenceUsageIndividualDefinition
AnOccurrenceUsagemust have at most oneoccurrenceDefinitionwithisIndividual = true.
occurrenceDefinition->select(isIndividual).size() <= 1
validateOccurrenceUsageIndividualUsage
If anOccurrenceUsagehasisIndividual = true, then it must have anindividualDefinition.
isIndividual implies individualDefinition <> null
**8.3.9.6PortionKind
Description**
PortionKindis an enumeration of the specific kinds of _Occurrence_ portions that can be represented by an
OccurrenceUsage.
**General Classes**
None.
**Literal Values**
snapshot
A snapshot of anOccurrence(a time slice with zero duration).
timeslice

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 265**


A time slice of anOccurrence(a portion over time).

**8.3.10Items Abstract Syntax
8.3.10.1Overview**

```
OccurrenceDefinition OccurrenceUsage
```
```
Structure
```
```
ItemDefinition ItemUsage
```
```
Definition Usage
```
```
+/definedItem{subsets definedOccurrence}0..*
```
```
{subsets occurrenceDefinition, ordered}
```
```
+/itemDefinition
0..*
```
```
{subsets occurrenceOwningDefinition}
```
```
+/itemOwningDefinition
0..1
```
```
{subsets ownedOccurrence, ordered}
```
```
+/ownedItem
0..*
```
```
{subsets occurrenceOwningUsage}
```
```
+/itemOwningUsage
0..1
```
```
{subsets nestedOccurrence, ordered}
```
```
+/nestedItem
0..*
```
**Figure 14. Item Definition and Usage
8.3.10.2ItemDefinition
Description**
AnItemDefinitionis anOccurrenceDefinitionof theStructureof things that may themselves be systems
or parts of systems, but may also be things that are acted on by a system or parts of a system, but which do not
necessarily perform actions themselves. This includes items that can be exchanged between parts of a system, such
as water or electrical signals.
**General Classes**
OccurrenceDefinition
Structure
**Attributes**
None.
**Operations**
None.
**Constraints**
checkItemDefinitionSpecialization
AnItemDefinitionmust directly or indirectly specialize the Systems Library ModelItemDefinition
_Items::Item._

**266 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


specializesFromLibrary("Items::Item")
**8.3.10.3ItemUsage
Description**
AnItemUsageis aItemUsagewhosedefinitionis aStructure. Nominally, if thedefinitionis an
ItemDefinition, anItemUsageis aItemUsageof thatItemDefinitionwithin a system. However, other
kinds of KernelStructuresare also allowed, to permit use ofStructuresfrom the Kernel Model Libraries.
**General Classes**
OccurrenceUsage
**Attributes**
/itemDefinition : Structure [0..*] {subsets occurrenceDefinition, ordered}
The Structures that are thedefinitionsof this ItemUsage. Nominally, these are ItemDefinitions, but other kinds
of Kernel Structures are also allowed, to permit use of Structures from the Kernel Library.
**Operations**
None.
**Constraints**
checkItemUsageSpecialization
AnItemUsagemust directly or indirectly specialize the Systems Model LibraryItemUsage _items_.
specializesFromLibrary("Items::items")
checkItemUsageSubitemSpecialization
isComposite and owningType <> null and(owningType.oclIsKindOf(ItemDefinition) or
owningType.oclIsKindOf(ItemUsage)) impliesspecializesFromLibrary("Items::Item::subitem")

deriveItemUsageItemDefinition
TheitemDefinitionsof anItemUsageare thoseoccurrenceDefinitionsthat areItemDefinitions.
itemDefinition = occurrenceDefinition->selectByKind(ItemDefinition)
**8.3.11Parts Abstract Syntax**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 267**


**8.3.11.1Overview**

```
OccurrenceDefinition OccurrenceUsage
```
```
PartUsage
```
```
Definition
```
```
PartDefinition
```
```
ItemUsage
```
```
Usage
```
```
ItemDefinition
```
```
{subsets itemOwningDefinition}
```
```
+/partOwningDefinition
0..1
```
```
{subsets ownedItem, ordered}
```
```
+/ownedPart
0..*
```
```
{subsets itemDefinition, ordered}
```
```
+/partDefinition
0..* {subsets definedItem}
```
```
+/definedPart
0..* {subsets nestedItem, ordered}
```
```
+/nestedPart
0..*
```
```
{subsets itemOwningUsage}
```
```
+/partOwningUsage
0..1
```
**Figure 15. Part Definition and Usage
8.3.11.2PartDefinition
Description**
APartDefinitionis anItemDefinitionof aClassof systems or parts of systems. Note that all parts may be
considered items for certain purposes, but not all items are parts that can perform actions within a system.
**General Classes**
ItemDefinition
**Attributes**
None.
**Operations**
None.
**Constraints**
checkPartDefinitionSpecialization
APartDefinitionmust directly or indirectly specialize the basePartDefinition _Parts::Part_ from the
Systems Model Library.
specializesFromLibrary("Parts::Part")
**8.3.11.3PartUsage
Description**

**268 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


APartUsageis a usage of aPartDefinitionto represent a system or a part of a system. At least one of the
itemDefinitionsof thePartUsagemust be aPartDefinition.
APartUsagemust subset, directly or indirectly, the basePartUsage _parts_ from the Systems Model Library.
**General Classes**
ItemUsage
**Attributes**
/partDefinition : PartDefinition [0..*] {subsets itemDefinition, ordered}
TheitemDefinitionsof this PartUsage that are PartDefinitions.
**Operations**
None.
**Constraints**
checkPartUsageActorSpecialization
If aPartUsageis owned via anActorMembership, then it must directly or indirectly specialize either
_Requirements::RequirementCheck::actors_ (if itsowningTypeis aRequirementDefinitionor
RequirementUsageor _Cases::Case::actors_ (otherwise).
owningFeatureMembership <> null andowningFeatureMembership.oclIsKindOf(ActorMembership) implies
if owningType.oclIsKindOf(RequirementDefinition) orowningType.oclIsKindOf(RequirementUsage)
then specializesFromLibrary('Requirements::RequirementCheck::actors')else specializesFromLibrary('Cases::Case::actors')

checkPartUsageSpecialization
APartUsagemust directly or indirectly specialize thePartUsage _Parts::parts_ from the Systems Model
Library.
specializesFromLibrary("Parts::parts")
checkPartUsageStakeholderSpecialization
If aPartUsageis owned via aStakeholderMembership, then it must directly or indirectly specialize either
_Requirements::RequirementCheck::stakeholders_.
owningFeatureMembership <> null andowningFeatureMembership.oclIsKindOf(StakeholderMembership) implies
specializesFromLibrary('Requirements::RequirementCheck::stakeholders')
checkPartUsageSubpartSpecialization
A compositePartUsagewhoseowningTypeis aItemDefinitionorItemUsagemust directly or indirectly
specialize thePartUsage _Items::Item::subparts_ from the Systems Model Library.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 269**


isComposite and owningType <> null and(owningType.oclIsKindOf(ItemDefinition) or
owningType.oclIsKindOf(ItemUsage)) impliesspecializesFromLibrary("Items::Item::subparts")

derivePartUsagePartDefinition
ThepartDefinitionsof anPartUsageare thoseitemDefinitionsthat arePartDefinitions.
itemDefinition->selectByKind(PartDefinition)
validatePartUsagePartDefinition
At least one of theitemDefinitionsof aPartUsagemust be aPartDefinition.
partDefinition->notEmpty()
**8.3.12Ports Abstract Syntax
8.3.12.1Overview**

```
OccurrenceDefinition OccurrenceUsage
```
```
PortDefinition PortUsage
```
```
Structure
```
```
Definition Usage
{subsets owningDefinition}
```
```
+/portOwningDefinition
0..1
```
```
{subsets ownedUsage, ordered}
```
```
+/ownedPort
0..*
```
```
{redefines occurrenceDefinition, ordered}
```
```
+/portDefinition
0..* {subsets definedOccurrence}
```
```
+/definedPort
0..*
```
```
{redefines owningUsage}
```
```
+/portOwningUsage
0..1
```
```
{subsets nestedUsage, ordered}
```
```
+/nestedPort
0..*
```
**Figure 16. Port Definition and Usage**

**270 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
+effectiveName() : String [0..1]{redefines effectiveName} ConjugatedPortDefinition
```
```
PortDefinition
```
```
ConjugatedPortTyping PortConjugation
```
```
FeatureTyping Conjugation
```
```
{subsets conjugation}+portConjugation0..1
```
```
+originalPortDefinition{redefines originalType}
1
```
```
0..* {subsets targetRelationship}+/conjugatedPortTyping
```
```
+/portDefinition 1
```
(^1) {redefines owningNamespace}+/originalPortDefinition
0..1 +/conjugatedPortDefinition{subsets ownedMember} {redefines ownedConjugator}
+/ownedPortConjugator 1
+/conjugatedPortDefinition
{redefines owningType}^1
+typingByConjugatedPort{subsets typingByType}0..*
+conjugatedPortDefinition
{redefines type}^1
**Figure 17. Port Conjugation
8.3.12.2ConjugatedPortDefinition
Description**
AConjugatedPortDefinitionis aPortDefinitionthat is aPortDefinitionof its original
PortDefinition. That is, aConjugatedPortDefinitioninherits all thefeaturesof the original
PortDefinition, but inputflowsof the originalPortDefinitionbecome outputs on the
ConjugatedPortDefinitionand outputflowsof the originalPortDefinitionbecome inputs on the
ConjugatedPortDefinition. EveryPortDefinition(that is not itself aConjugatedPortDefinition) has
exactly one correspondingConjugatedPortDefinition, whose effective name is the name of the
originalPortDefinition, with the character~prepended.
**General Classes**
PortDefinition
**Attributes**
/originalPortDefinition : PortDefinition {redefines owningNamespace}
The originalPortDefinitionfor thisConjugatedPortDefinition, which is theowningNamespaceof the
ConjugatedPortDefinition.
/ownedPortConjugator : PortConjugation {redefines ownedConjugator}
ThePortConjugationthat is theownedConjugatorof thisConjugatedPortDefinition, linking it to its
originalPortDefinition.
**Operations**
effectiveName() : String [0..1]
If thenameof theoriginalPortDefinitionis non-empty, then return that with the character~prepended.
**body** if originalName = null then null: let originalName : String = originalPortDefinition.name in
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 271**


else '~' + originalNameendif

**Constraints**
validateConjugatedPortDefinitionConjugatedPortDefinitionIsEmpty
AConjugatedPortDefinitionmust not itself have aconjugatedPortDefinition.
conjugatedPortDefinition = null
validateConjugatedPortDefinitionOriginalPortDefinition
TheoriginalPortDefinitionof theownedPortConjugatorof aConjugatedPortDefinitionmust be the
originalPortDefinitionof theConjugatedPortDefinition.
ownedPortConjugator.originalPortDefinition = originalPortDefinition
**8.3.12.3ConjugatedPortTyping
Description**
AConjugatedPortTypingis aFeatureTypingwhosetypeis aConjugatedPortDefinition. (This
relationship is intended to be an abstract-syntax marker for a special surface notation for conjugated typing of ports.)
**General Classes**
FeatureTyping
**Attributes**
conjugatedPortDefinition : ConjugatedPortDefinition {redefines type}
Thetypeof thisConjugatedPortTypingconsidered as aFeatureTyping, which must be a
ConjugatedPortDefinition.
/portDefinition : PortDefinition
TheoriginalPortDefinitionof theconjugatedPortDefinitionof thisConjugatedPortTyping.
**Operations**
None.
**Constraints**
deriveConjugatedPortTypingPortDefinition
TheportDefinitionof aConjugatedPortTypingis theoriginalPortDefinitionof the
conjugatedPortDefinitionof theConjugatedPortTyping.
portDefinition = conjugatedPortDefinition.originalPortDefinition
**8.3.12.4PortConjugation
Description**

**272 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


APortConjugationis aConjugationRelationshipbetween aPortDefinitionand its corresponding
ConjugatedPortDefinition. As a result of thisRelationship, theConjugatedPortDefinitioninherits all
thefeaturesof the originalPortDefinition, but inputflowsof the originalPortDefinitionbecome
outputs on theConjugatedPortDefinitionand outputflowsof the originalPortDefinitionbecome inputs
on theConjugatedPortDefinition.
**General Classes**
Conjugation
**Attributes**
/conjugatedPortDefinition : ConjugatedPortDefinition {redefines owningType}
TheConjugatedPortDefinitionthat is conjugate to theoriginalPortDefinition.
originalPortDefinition : PortDefinition {redefines originalType}
ThePortDefinitionbeing conjugated.
**Operations**
None.
**Constraints**
None.
**8.3.12.5PortDefinition
Description**
APortDefinitiondefines a point at which external entities can connect to and interact with a system or part of a
system. AnyownedUsagesof aPortDefinition, other thanPortUsages, must not be composite.
**General Classes**
OccurrenceDefinition
Structure
**Attributes**
/conjugatedPortDefinition : ConjugatedPortDefinition [0..1] {subsets ownedMember}
Thethat is conjugate to thisPortDefinition.
**Operations**
None.
**Constraints**
checkPortDefinitionSpecialization

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 273**


APortDefinitionmust directly or indirectly specialize thePortDefinition _Ports::Port_ from the Systems
Model Library.
specializeFromLibrary('Ports::Port')
derivePortDefinitionConjugatedPortDefinition
TheconjugatedPortDefinitionof aPortDefinitionis theownedMemberthat is a
ConjugatedPortDefinition.
conjugatedPortDefinition =let conjugatedPortDefinitions : OrderedSet(ConjugatedPortDefinition) =

if conjugatedPortDefinitions->isEmpty() then nullownedMember->selectByKind(ConjugatedPortDefinition) in
else conjugatedPortDefinitions->first()endif

validatePortDefinitionConjugatedPortDefinition
Unless it is aConjugatedPortDefinition, aPortDefinitionmust have exactly oneownedMemberthat is a
ConjugatedPortDefinition.
not oclIsKindOf(ConjugatedPortDefinition) impliesownedMember->
selectByKind(ConjugatedPortDefinition)->size() = 1

validatePortDefinitionOwnedUsagesNotComposite
TheownedUsagesof aPortDefinitionthat are notPortUsagesmust not be composite.
ownedUsage->reject(oclIsKindOf(PortUsage))->
forAll(not isComposite)
**8.3.12.6PortUsage
Description**
APortUsageis a usage of aPortDefinition. APortUsageitself as well as all its
nestedUsagesmust be referential (non-composite).
**General Classes**
OccurrenceUsage
**Attributes**
/portDefinition : PortDefinition [0..*] {redefines occurrenceDefinition, ordered}
TheoccurrenceDefinitionsof thisPortUsage, which must all bePortDefinitions.
**Operations**
None.

**274 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
checkPortUsageSpecialization
APortUsagemust directly or indirectly specialize thePortUsage _Ports::ports_ from the Systems Model
Library.
specializesFromLibrary('Ports::ports')
checkPortUsageSubportSpecialization
A compositePortUsagewith anowningTypethat is aPortDefinitionorPortUsagemust directly or
indirectly specialize thePortUsage _Ports::Port::subports_ from the Systems Model Library.
isComposite and owningType <> null and(owningType.oclIsKindOf(PortDefinition) or
owningType.oclIsKindOf(PortUsage)) impliesspecializesFromLibrary('Ports::Port::subports')

validatePortUsageIsReference
Unless aPortUsagehas anowningTypethat is aPortDefinitionor aPortUsage, it must be referential (non-
composite).
owningType = null ornot owningType.oclIsKindOf(PortDefinition) and
not owningType.oclIsKindOf(PortUsage) impliesisReference

validatePortUsageNestedUsagesNotComposite
ThenestedUsagesof aPortUsagethat are not themselvesPortUsagesmust not be composite.
nestedUsage->reject(oclIsKindOf(PortUsage))->
forAll(not isComposite)
**8.3.13Connections Abstract Syntax**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 275**


**8.3.13.1Overview**

```
BindingConnectorAsUsage
```
```
BindingConnector
```
```
SuccessionAsUsage
```
```
Usage
```
```
ConnectorAsUsage
```
```
Succession
```
```
Connector
```
**Figure 18. Connectors as Usages**

```
OccurrenceDefinition
```
```
Definition
```
```
ItemDefinition
PartDefinition
```
```
ConnectionDefinition
```
```
ConnectorAsUsage
```
```
OccurrenceUsage
```
```
AssociationStructure
```
```
Usage
```
```
ItemUsage
PartUsage
```
```
ConnectionUsage
```
```
+/connectionOwningDefinition
{subsets partOwningDefinition}0..1
```
```
{subsets ownedPart, ordered}
```
```
+/ownedConnection0..*
```
```
{subsets partOwningUsage}
0..1+/connectionOwningUsage
```
```
{subsets nestedPart, ordered}
0..*+/nestedConnection
```
```
{subsets typedConnector, ordered}
```
```
+/definedConnection0..*
```
```
{subsets itemDefinition, redefines association,
ordered}
```
```
+/connectionDefinition0..*
```
```
{redefines associationWithEnd}
```
```
+/connectionDefinitionWithEnd
0..*
```
```
{redefines associationEnd, ordered}
```
```
+/connectionEnd0..*
```
**Figure 19. Connection Definition and Usage**

**276 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
SuccessionFlowConnectionUsage
```
```
FlowConnectionDefinition FlowConnectionUsage
```
```
ConnectionDefinition
```
```
OccurrenceDefinition
ItemDefinition
```
```
SuccessionItemFlow
```
```
ConnectionUsage
```
```
Usage
OccurrenceUsage
```
```
ActionDefinition ActionUsage
```
```
PartDefinition
```
```
Interaction
```
```
PartUsage
```
```
ItemUsage
```
```
ItemFlow
```
```
Definition
```
```
{redefines definedConnection}
```
```
+/definedFlowConnection0..*
{redefines actionDefinition, redefines connectionDefinition,
redefines interaction, ordered}
```
```
0..*+/flowConnectionDefinition
```
```
{subsets ownedConnection}
```
```
+/ownedFlow0..*
```
```
{subsets connectionOwningDefinition}
0..1+/flowOwningDefinition
```
```
{subsets nestedConnection}
```
```
+/nestedFlow0..*
```
```
{subsets connectionOwningUsage}
0..1+/flowOwningUsage
```
**Figure 20. Flow Connections
8.3.13.2BindingConnectorAsUsage
Description**
ABindingConnectorAsUsageis both aBindingConnectorand aConnectorAsUsage.
**General Classes**
BindingConnector
ConnectorAsUsage
**Attributes**
None.
**Operations**
None.
**Constraints**
None.
**8.3.13.3ConnectionDefinition
Description**
AConnectionDefinitionis aPartDefinitionthat is also anAssociationStructure. The endFeatures
of aConnectionDefinitionmust beUsages.
**General Classes**
PartDefinition

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 277**


AssociationStructure
**Attributes**
/connectionEnd : Usage [0..*] {redefines associationEnd, ordered}
TheUsagesthat define the things related by theConnectionDefinition.
**Operations**
None.
**Constraints**
checkConnectionDefinitionBinarySpecialization
A binaryConnectionDefinitionmust directly or indirectly specialize theConnectionDefinition
_Connections::BinaryConnection_ from the Systems Model Library.
ownedEndFeature->size() = 2 impliesspecializesFromLibrary("Connections::BinaryConnections")

checkConnectionDefinitionSpecializations
AConnectionDefinitionmust directly or indirectly specialize theConnectionDefinition
_Connections::Connection_ from the Systems Model Library.
specializesFromLibrary("Connections::Connection")
**8.3.13.4ConnectionUsage
Description**
AConnectionUsageis aConnectorAsUsagethat is also aPartUsage. Nominally, if its type is a
ConnectionDefinition, then aConnectionUsageis a Usage of thatConnectionDefinition, representing a
connection between parts of a system. However, other kinds of kernelAssociationStructuresare also allowed,
to permit use ofAssociationStructuresfrom the Kernel Model Libraries.
**General Classes**
ConnectorAsUsage
PartUsage
**Attributes**
/connectionDefinition : AssociationStructure [0..*] {subsets itemDefinition, redefines association, ordered}
TheAssociationStructuresthat are the types of thisConnectionUsage. Nominally, these are , but other
kinds of KernelAssociationStructuresare also allowed, to permit use ofAssociationStructuresfrom the
Kernel Model Libraries
**Operations**
None.

**278 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
checkConnectionUsageBinarySpecialization
A binaryConnectionUsagemust directly or indirectly specialize theConnectionUsage
_Connections::binaryConnections_ from the Systems Model Library.
ownedEndFeature->size() = 2 impliesspecializesFromLibrary("Connections::binaryConnections")

checkConnectionUsageSpecialization
AConnectionUsagemust directly or indirectly specialize theConnectionUsage
_Connections::connections_ from the Systems Model Library.
specializesFromLibrary("Connections::connections")
**8.3.13.5ConnectorAsUsage
Description**
AConnectorAsUsageis both aConnectorand aUsage.ConnectorAsUsagecannot itself be instantiated in a
SysML model, but it is the base class for the concrete classesBindingConnectorAsUsage,SuccessionAsUsage
andConnectionUsage.
**General Classes**
Usage
Connector
**Attributes**
None.
**Operations**
None.
**Constraints**
None.
**8.3.13.6FlowConnectionDefinition
Description**
AFlowConnectionDefinitionis aConnectionDefinitionandActionDefinitionthat is also an
Interactionrepresenting flows betweenUsages.
**General Classes**
ActionDefinition
ConnectionDefinition
Interaction

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 279**


**Attributes**
None.
**Operations**
None.
**Constraints**
checkFlowConnectionDefinitionSpecialization
AFlowConnectionDefinitionmust directly or indirectly specialize the baseFlowConnectionDefinition
_MessageConnectionDefinition_ from the Systems Model Library.
specializesFromLibrary("Connections::MessageConnection")
**8.3.13.7FlowConnectionUsage
Description**
AFlowConnectionUsageis aConnectionUsagethat is also anItemFlow.
**General Classes**
ConnectionUsage
ItemFlow
ActionUsage
**Attributes**
/flowConnectionDefinition : Interaction [0..*] {redefines actionDefinition, connectionDefinition, interaction,
ordered}
TheInteractionsthat are thetypesof thisFlowConnectionUsage. Nominally, these are
FlowConnectionDefinitions, but other kinds of KernelInteractionsare also allowed, to permit use of
Interactions from the Kernel Model Libraries.
**Operations**
None.
**Constraints**
checkFlowConnectionUsageSpecialization
If aFlowConnectionUsagehas noitemFlowEnds, then it must directly or indirectly specialize the base
FlowConnectionUsage _Connections::messageConnectionsfrom the Systems Library model. Otherwise, it
must directly or indirectly spcialize theFlowConnectionUsageConnections::flowConnections._
if itemFlowEnds->isEmpty() thenspecializesFromLibrary("Connections::messageConnections")
elsespecializesFromLibrary("Connections::flowConnections"
endif

**280 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.3.13.8SuccessionAsUsage
Description**
ASuccessionAsUsageis both aConnectorAsUsageand aSuccession.
**General Classes**
Succession
ConnectorAsUsage
**Attributes**
None.
**Operations**
None.
**Constraints**
None.
**8.3.13.9SuccessionFlowConnectionUsage
Description**
ASuccessionFlowConnectionUsageis aFlowConnectionUsagethat is also aSuccessionItemFlow.
**General Classes**
SuccessionItemFlow
FlowConnectionUsage
**Attributes**
None.
**Operations**
None.
**Constraints**
checkSuccessionFlowConnectionUsageSpecialization
ASuccessionFlowConnectionUsagemust directly or indirectly specialize the baseFlowConnectionUsage
_Connections::successionFlowConnectionsfrom the Systems Library model._
specializesFromLibrary("Connections::successionFlowConnections")
**8.3.14Interfaces Abstract Syntax**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 281**


**8.3.14.1Overview**

```
InterfaceUsage
```
```
Usage
```
```
OccurrenceDefinition
```
```
Definition
```
```
ItemDefinition
```
```
PartDefinition
```
```
InterfaceDefinition
```
```
ConnectionDefinition
```
```
OccurrenceUsage
```
```
PartUsage
```
```
ItemUsage
```
```
ConnectionUsage
```
```
PortUsage
{redefines connectionEnd, ordered}
```
```
+/interfaceEnd
{subsets connectionDefinitionWithEnd} 0..*
```
```
+/interfaceDefinitionWithEnd
0..*
```
```
{redefines connectionDefinition}
```
```
+/interfaceDefinition
0..* {subsets definedConnection}
```
```
+/definedInterface
0..*
```
```
{subsets ownedConnection, ordered}
```
```
+/ownedInterface
0..*
```
```
{subsets connectionOwningDefinition}
```
```
+/interfaceOwningDefinition
0..1
```
```
{subsets nestedConnection, ordered}
+/nestedInterface0..*
```
```
{subsets connectionOwningUsage}+/interfaceOwningUsage0..1
```
**Figure 21. Interface Definition and Usage
8.3.14.2InterfaceDefinition
Description**
AnInterfaceDefinitionis aConnectionDefinitionall of whose ends arePortUsages, defining an
interface between elements that interact through such ports.
**General Classes**
ConnectionDefinition
**Attributes**
/interfaceEnd : PortUsage [0..*] {redefines connectionEnd, ordered}
ThePortUsagesthat are theconnectionEndsof thisInterfaceDefinition.
**Operations**
None.
**Constraints**

**282 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


checkInterfaceDefinitionBinarySpecialization
A binaryInterfaceDefinitionmust directly or indirectly specialize theInterfaceDefinition
_Interfaces::BinaryInterface_ from the Systems Model Library.
ownedEndFeature->size() = 2 impliesspecializesFromLibrary("Interfaces::BinaryInterface")

checkInterfaceDefinitionSpecialization
AnInterfaceDefinitionmust directly or indirectly specialize theInterfaceDefinition
_Interfaces::Interface_ from the Systems Model Library.
specializesFromLibrary("Interfaces::Interface")
**8.3.14.3InterfaceUsage
Description**
AnInterfaceUsageis a Usage of anInterfaceDefinitionto represent an interface connecting parts of a
system through specific ports.
**General Classes**
ConnectionUsage
**Attributes**
/interfaceDefinition : InterfaceDefinition [0..*] {redefines connectionDefinition}
TheInterfaceDefinitionsthat type thisInterfaceUsage.
**Operations**
None.
**Constraints**
checkInterfaceUsageBinarySpecialization
A binaryInterfaceUsagemust directly or indirectly specialize theInterfaceUsage
_Interfaces::binaryInterfaces_ from the Systems Model Library.
ownedEndFeature->size() = 2 impliesspecializesFromLibrary("Interfaces::binaryInterfaces")

checkInterfaceUsageSpecialization
AnInterfaceUsagemust directly or indirectly specialize theInterfaceUsage _Interfaces::interfaces_
from the Systems Model Library.
specializesFromLibrary("Interfaces::interfaces")

**8.3.15Allocations Abstract Syntax**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 283**


**8.3.15.1Overview**

```
AllocationDefinition AllocationUsage
```
```
OccurrenceDefinition
```
```
PartDefinition
```
```
ItemDefinition
```
```
Definition
```
```
ConnectionDefinition
```
```
OccurrenceUsage
```
```
ConnectionUsage
```
```
Usage
```
```
PartUsage
```
```
ItemUsage
```
```
{subsets nestedConnection, ordered}
```
```
+/nestedAllocation
0..*
```
```
{subsets connectionOwningUsage}
```
```
+/allocationOwningUsage
0..1
```
```
{subsets definedConnection}
```
```
+/definedAllocation
{redefines connectionDefinition, 0..*
ordered}
```
```
+/allocationDefinition
0..*
```
```
{subsets usage, ordered}
```
```
+/allocation
0..*
```
```
+/featuringAllocationDefinition
{subsets featuringDefinition}0..*
```
```
{subsets ownedConnection, ordered}
```
```
+/ownedAllocation
0..*
```
```
{subsets connectionOwningDefinition}
```
```
+allocationOwningDefinition
0..1
```
**Figure 22. Allocation Definition and Usage
8.3.15.2AllocationDefinition
Description**
AnAllocationDefinitionis aConnectionDefinitionthat specifies that some or all of the responsibility to
realize the intent of thesourceis allocated to thetargetinstances. Such allocations define mappings across the
various structures and hierarchies of a system model, perhaps as a precursor to more rigorous specifications and
implementations. AnAllocationDefinitioncan itself be refined using nestedallocationsthat give a finer-
grained decomposition of the containing allocation mapping.
**General Classes**
ConnectionDefinition
**Attributes**
/allocation : AllocationUsage [0..*] {subsets usage, ordered}
TheAllocationUsagesthat refine the allocation mapping defined by thisAllocationDefinition.
**Operations**

**284 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


None.
**Constraints**
checkAllocationDefinitionSpecialization
AnAllocationDefinitionmust directly or indirectly specialize theAllocationDefinition
_Allocations::Allocation_ from the Systems Model Library.
specializesFromLibrary("Allocations::Allocation")
deriveAllocationDefinitionAllocation
Theallocationsof anAllocationDefinitionare all itsusagesthat areAllocationUsages.
allocation = usage->selectAsKind(AllocationUsage)
**8.3.15.3AllocationUsage
Description**
AnAllocationUsageis a usage of anAllocationDefinitionasserting the allocation of thesourcefeature to
thetargetfeature.
**General Classes**
ConnectionUsage
**Attributes**
/allocationDefinition : AllocationDefinition [0..*] {redefines connectionDefinition, ordered}
TheAllocationDefinitionsthat are the types of thisAllocationUsage.
**Operations**
None.
**Constraints**
checkAllocationUsageSpecialization
AnAllocationUsagemust directly or indirectly specialize theAllocationUsage
_Allocations::allocations_ from the Systems Model Library.
specializesFromLibrary("Allocations::allocations")
**8.3.16Actions Abstract Syntax**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 285**


**8.3.16.1Overview**

```
+isSubactionUsage() : Boolean+argument( i : Integer ) : Expression [0..1]
```
```
+inputParameter( i : Integer ) : Feature [0..1]+inputParameters() : Feature [0..*]
```
```
ActionUsage
```
```
OccurrenceDefinition OccurrenceUsage
```
```
ActionDefinition
```
```
Step
```
```
Definition Usage
```
```
Behavior
```
```
{subsets definedOccurrence, subsets typedStep}
```
```
+/definedAction0..*
```
```
{redefines behavior, redefines occurrenceDefinition, ordered}
0..*+/actionDefinition
```
```
{subsets occurrenceOwningDefinition}
0..1+/actionOwningDefinition
```
```
{subsets ownedOccurrence, ordered}
```
```
+/ownedAction0..*
```
```
{subsets featuringBehavior, subsets featuringDefinition}
```
```
+/featuringActionDefinition0..*
{subsets step, subsets usage, ordered}
```
```
+/action0..*
```
```
{subsets occurrenceOwningUsage}
```
```
+/actionOwningUsage0..1
```
```
{subsets nestedOccurrence, ordered}
```
```
+/nestedAction0..*
```
**Figure 23. Action Definition and Usage**

```
ControlNode
```
```
ActionUsage
```
```
MergeNode DecisionNode JoinNode ForkNode
```
**Figure 24. Control Nodes**

```
+namingFeature() : Feature [0..1]{redefines namingFeature}
```
```
PerformActionUsage
```
```
EventOccurrenceUsage ActionUsage
{redefines eventOccurrence}
```
```
+/performedAction
1
```
```
{subsets referencingOccurrence}
```
```
+/performingAction
0..*
```
**Figure 25. Performed Actions**

**286 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
+isTriggerAction() : Boolean AcceptActionUsage
```
```
+kind : TriggerKind TriggerInvocationExpression
```
```
InvocationExpression
```
```
Expression
```
```
SendActionUsage
```
```
ReferenceUsage
```
```
afterat
```
```
when TriggerKind
```
```
«enumeration»
```
```
ActionUsage
```
```
+/acceptingActionUsage0..1
```
```
0..1+/payloadArgument
```
```
+/acceptActionUsage0..1
```
```
0..1+/receiverArgument
```
```
+/sendingActionUsage0..1
```
```
+/payloadArgument 1
```
```
+/owningAcceptActionUsage
{subsets referenceOwningUsage}0..1
{subsets nestedReference, subsets parameter}
+/payloadParameter 1
```
```
+/senderActionUsage0..1
```
```
+/senderArgument0..1 0..1+/receiverArgument
```
```
0..1 +/sendActionUsage
```
**Figure 26. Send and Accept Actions**

```
AssignmentActionUsage
```
```
ActionUsage
```
```
Expression
```
```
Feature
{subsets namespace}
```
```
+/assignment
0..*
{subsets member}
```
```
+/referent
1
```
```
+/assignmentAction
0..1
```
```
+/targetArgument
1
```
```
+/valueExpression^1
```
```
+/assigningAction0..1
```
**Figure 27. Assignment Actions**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 287**


```
WhileLoopActionUsage
```
```
Expression
```
```
ForLoopActionUsage
```
```
LoopActionUsage
```
```
ReferenceUsage
```
```
IfActionUsage
```
```
ActionUsage
```
```
+/forLoopAction
0..1
```
```
+/seqArgument
1
```
```
+/thenAction
1
```
```
+/ifThenAction
0..1
```
```
+/loopAction
0..1
```
```
+/bodyAction
1
```
```
+/untilArgument
0..1
```
```
0..1 +/untilLoopAction
```
```
+/ifAction0..1
```
```
+/ifArgument 1
```
```
+/elseAction
0..1
+/ifElseAction0..1
```
```
+/whileArgument
1
```
```
+/whileLoopAction0..1 +/forLoopAction0..1
```
```
+/loopVariable 1
```
**Figure 28. Structured Control Actions
8.3.16.2AcceptActionUsage
Description**
AnAcceptActionUsageis anActionUsagethat specifies the acceptance of an _incomingTransfer_ from the
_Occurrence_ given by the result of itsreceiverArgumentExpression. (If noreceiverArgumentis provided,
the default is the _this_ context of the AcceptActionUsage.) The payload of the accepted _Transfer_ is output on its
payloadParameter. Which _Transfers_ may be accepted is determined by conformance to the typing and
(potentially) binding of thepayloadParameter.
**General Types**
ActionUsage
**Features**
/payloadArgument : Expression [0..1]
AnExpressionwhose resultis bound to the _payload_ parameterof this
AcceptActionUsage. If provided, theAcceptActionUsage will only accept a _Transfer_ with
exactly this _payload_.
/payloadParameter : ReferenceUsage {subsets nestedReference, parameter}
ThenestedReferenceof thisAcceptActionUsagethat redefines thepayloadoutputparameterof the base
AcceptActionUsage _AcceptAction_ from the Systems Model Library.

**288 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


/receiverArgument : Expression [0..1]
AnExpressionwhose resultis bound to the _receiver_ input parameterof this
AcceptActionUsage.
**Constraints**
deriveAcceptActionUsageReceiverArgument
ThereceiverArgumentof anAcceptUsageActionis its second argumentExpression.
receiverArgument = argument(2)
deriveAcceptActionUsagePayloadArgument
ThepayloadArgumentof anAcceptUsageActionis its first argumentExpression.
payloadArgument = argument(1)
checkAcceptActionUsageTriggerActionSpecialization
AnAcceptActionUsagethat is thetriggerActionofTransitionUsagemust directly or indirectly specialize
theActionUsage _Actions::TransitionAction::accepter_ from the Systems Model Library.
isTriggerAction() impliesspecializesFromLibrary('Actions::TransitionAction::accepter')

validateAcceptActionUsageParameters
AnAcceptUsageActionmust have at least two inputparameters, corresponding to its _payload_ and _receiver,
respectively (even if they have noFeatureValue). (Note that thepayloadParameteris an input as well as an
output.)_
inputParameters()->size() >= 2
deriveAcceptActionUsagePayloadParameter
ThepayloadParameterof anAcceptActionUsageis its firstparameter.
payloadParameter =if parameter->isEmpty() then null
else parameter->first() endif
checkAcceptActionUsageReceiverBindingConnector
If thepayloadArgumentof anAcceptActionUsageis aTriggerInvocationExpression, then the
AcceptActionusagemust have anownedFeaturethat is aBindingConnectorbetween its _receiver_
parameterand the _receiver_ parameterof theTriggerInvocationExpression.
payloadArgument <> null andpayloadArgument.oclIsKindOf(TriggerInvocationExpression) implies
let invocation : Expression =payloadArgument.oclAsType(Expression) in
parameter->size() >= 2 andinvocation.parameter->size() >= 2 and
ownedFeature->selectByKind(BindingConnector)->exists(b |

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 289**


```
b.relatedFeatures->includes(parameter->at(2)) andb.relatedFeatures->includes(invocation.parameter->at(2)))
```
checkAcceptActionUsageSpecialization
AnAcceptActionUsagethat is not thetriggerActionof aTransitionUsagemust directly or indirectly
specialize theActionUsage _Actions::acceptActions_ from the Systems Model Library.
not isTriggerAction() impliesspecializesFromLibrary('Actions::acceptActions')

checkAcceptActionUsageSubactionSpecialization
A compositeAcceptActionUsagethat is a subaction usage, but is _not_ thetriggerActionof a
TransitionUsage, must directly or indirectly specialize theActionUsage
_Actions::Action::acceptSubactions_ from the Systems Model Library.
isSubactionUsage() and not isTriggerAction() impliesspecializesFromLibrary('Actions::Action::acceptSubactions')

**8.3.16.3ActionDefinition
Description**
AnActionDefinitionis aDefinitionthat is also aBehaviorthat defines an _Action_ performed by a system
or part of a system.
**General Classes**
OccurrenceDefinition
Behavior
**Attributes**
/action : ActionUsage [0..*] {subsets step, usage, ordered}
TheActionUsagesthat arestepsin thisActionDefinition, which define the actions that specify the behavior
of theActionDefinition.
**Operations**
None.
**Constraints**
checkActionDefinitionSpecialization
AnActionDefinitionmust directly or indirectly specialize theActionDefinition _Actions::Action_ from
the Systems Model Library.
specializesFromLibrary('Actions::Action')
deriveActionDefinitionAction
Theactionsof aActionDefinitionare those of itsusagesthat areActionUsages.

**290 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


action = usage->selectByKind(ActionUsage)
**8.3.16.4ActionUsage
Description**
AnActionUsageis aUsagethat is also aStep, and, so, is typed by aBehavior. Nominally, if the type is an
ActionDefinition, anActionUsageis aUsageof thatActionDefinitionwithin a system. However, other
kinds of kernelBehaviorsare also allowed, to permit use ofBehaviorsfrom the Kernel Model Libraries.
**General Classes**
OccurrenceUsage
Step
**Attributes**
/actionDefinition : Behavior [0..*] {redefines behavior, occurrenceDefinition, ordered}
TheBehaviorsthat are thetypesof thisActionUsage. Nominally, these would beActionDefinitions, but
other kinds of Kernel Behaviorsare also allowed, to permit use ofBehaviorsfrom the
Kernel Model Libraries.
**Operations**
argument(i : Integer) : Expression [0..1]
Return thei-th argumentExpressionof an ActionUsage, defined as the valueExpression of
the FeatureValueof the i-th owned inputparameterof the ActionUsage. Return null if
the ActionUsagehas less than i owned input parametersor the i-th owned input
parameterhas no FeatureValue.
**body** else: if inputParameter(i) = null then null
let featureValue : Sequence(FeatureValue) = inputParameter(i).ownedMembership->select(oclIsKindOf(FeatureValue)) in
if featureValue->isEmpty() then nullelse featureValue->at(1).value

endifendif
inputParameter(i : Integer) : Feature [0..1]
Return thei-th owned inputparameterof the ActionUsage. Return null if the ActionUsage
has less than iowned input parameters.
**body** else inputParameters()->at(i): if inputParameters()->size() < i then null
endif
inputParameters() : Feature [0..*]
Return the owned inputparametersof thisActionUsage.
**body** : input->select(f | f.owner = self)

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 291**


isSubactionUsage() : Boolean
Check if thisActionUsageis composite and has anowningTypethat is anActionDefinitionorActionUsage
but is _not_ theentryActionorexitActionof aStateDefinitionorStateUsage. If so, then it represents an
_Action_ that is a _subaction_ of another _Action_.
**body** (owningType.oclIsKindOf(ActionDefinition) or: isComposite and owningType <> null and

(owningFeatureMembership.oclIsKindOf(StateSubactionMembership) impliesowningType.oclIsKindOf(ActionUsage)) and
owningFeatureMembership.oclAsType(StateSubactionMembership).kind =StateSubactionKind::do)

**Constraints**
checkActionUsageAnalysisActionSpecialization
AnActionUsagethat is ananalysisActionof anAnalysisCaseDefinitionor andAnalysisCaseUsage
must directly or indirectly specialize theActionUsage _AnalysisCases::AnalysisCase::analysisSteps_
from the Systems Model Library.
owningType <> null and(owningType.oclIsKindOf(AnalysisCaseDefinition) and
owningType.oclAsType(AnalysisCaseDefinition).analysisAction->includes(self) or
owningType.oclIsKindOf(AnalysisCaseUsage) andowningType.oclAsType(AnalysisCaseUsage).analysisAction->
specializesFromLibrary('AnalysisCases::AnalysisCase::analysisSteps')includes(self)) implies
checkActionUsageOwnedActionSpecialization
A compositeActionUsagewhoseowningTypeisPartDefinitionorPartUsagemust directly or indirectly
specialize theActionUsage _Parts::Part::ownedActions_ from the Systems Model Library.
isComposite and owningType <> null and(owningType.oclIsKindOf(PartDefinition) or
owningType.oclIsKindOf(PartUsage)) impliesspecializesFromLibrary('Parts::Part::ownedActions')

checkActionUsageSpecialization
AnActionUsagemust directly or indirectly specialize theActionUsage _Actions::actions_ from the Systems
Model Library.
specializesFromLibrary('Actions::actions')
checkActionUsageStateActionRedefinition
AnActionUsagethat is the _entry_ , _do_ , or _exitAction_ of aStateDefinitionorStateUsagemust redefine
theentryAction,doAction, orexitActionfeature, respectively, of theStateDefinition
_States::StateAction_ from the Systems Model Library.
owningFeatureMembership <> null andowningFeatureMembership.oclIsKindOf(StateSubactionMembership) implies
let kind : StateSubactionKind =

**292 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


if kind = StateSubactionKind::entry thenowningFeatureMembership.oclAsType(StateSubactionMembership).kind in
else if kind = StateSubactionKind::do thenredefinesFromLibrary('States::StateAction::entryAction')
elseredefinesFromLibrary('States::StateAction::doAction')
endif endifredefinesFromLibrary('States::StateAction::exitAction')
checkActionUsageSubactionSpecialization
A compositeActionUsagethat is a subaction usage must directly or indirectly specialize theActionUsage
_Actions::Action::subactions_ from the Systems Model Library.
isSubactionUsage() impliesspecializesFromLibrary('Actions::Action::subactions')

**8.3.16.5AssignmentActionUsage
Description**
AnAssignmentActionUsageis anActionUsagethat is defined, directly or indirectly, by the
ActionDefinition _AssignmentAction_ from the Systems Model Library. It specifies that the value of the
referentFeature, relative to the target given by the result of thetargetArgumentExpression, should be set
to the result of thevalueExpression.
**General Classes**
ActionUsage
**Attributes**
/referent : Feature {subsets member}
TheFeaturewhose value is to be set.
/targetArgument : Expression
TheExpressionwhose value is an occurrence in the domain of thereferentFeature, for which the value of
thereferentwill be set to the result of thevalueExpressionby thisAssignmentActionUsage.
/valueExpression : Expression
TheExpressionwhose result is to be assigned to thereferentFeature.
**Operations**
None.
**Constraints**
checkAssignmentActionUsageAccessedFeatureRedefinition
The firstownedFeatureof the firstownedFeatureof the firstparameterof anAssignmentActionUsage
must redefine _AssignmentAction::target::startingAt::accessedFeature_.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 293**


let targetParameter : Feature = inputParameter(1) intargetParameter <> null and
targetParameter.ownedFeature->notEmpty() andtargetParameter->first().ownedFeature->notEmpty() and
targetParameter->first().ownedFeature->first().redefines('AssigmentAction::target::startingAt::accessedFeature')

checkAssignmentActionUsageReferentRedefinition
The firstownedFeatureof the firstownedFeatureof the firstparameterof anAssignmentActionUsage
must redefine thereferentof theAssignmentActionUsage.
let targetParameter : Feature = inputParameter(1) intargetParameter <> null and
targetParameter.ownedFeature->notEmpty() andtargetParameter->first().ownedFeature->notEmpty() and
targetParameter->first().ownedFeature->first().redefines(referent)
checkAssignmentActionUsageSpecialization
AnAssignmentActionUsagemust directly or indirectly specialize theActionUsage
_Actions::assignmentActions_ from the Systems Model Library.
specializesFromLibrary('Actions::assignmentActions')
checkAssignmentActionUsageStartingAtRedefinition
The firstownedFeatureof the firstparameterof anAssignmentActionUsagemust redefine
_AssignmentAction::target::startingAt_.
let targetParameter : Feature = inputParameter(1) intargetParameter <> null and
targetParameter.ownedFeature->notEmpty() andtargetParameter.ownedFeature->first().
redefines('AssignmentAction::target::startingAt')
checkAssignmentActionUsageSubactionSpecialization
A compositeAssignmentActionUsagethat is a subaction usage must directly or indirectly specialize the
ActionUsage _Actions::Action::assignments_ from the Systems Model Library.
isSubactionUsage() impliesspecializesFromLibrary('Actions::Action::assignments')

deriveAssignmentActionUsageReferent
Thereferentof anAssignmentActionUsageis the firstFeaturethat is thememberElementof a
ownedMembershipthat is not anOwningMembership.
referent =let unownedFeatures : Sequence(Feature) = ownedMembership->
reject(oclIsKindOf(OwningMembership)).memberElement->selectByKind(Feature) in
if unownedFeatures->isEmpty() then nullelse unownedFeatures->first().oclAsType(Feature)
endif

**294 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


deriveAssignmentActionUsageValueExpression
ThevalueExpressionof aAssignmentActionUsageis its second argumentExpression.
valueExpression = argument(2)
deriveAssignmentUsageTargetArgument
ThetargetArgumentof aAssignmentActionUsageis its first argumentExpression.
targetArgument = argument(1)
**8.3.16.6ControlNode
Description**
AControlNodeis anActionUsagethat does not have any inherent behavior but provides constraints on incoming
and outgoingSuccessionsthat are used to control otherActions. AControlNodemust be a composite owned
usageof anActionDefinitionorActionUsage.
**General Classes**
ActionUsage
**Attributes**
None.
**Operations**
multiplicityHasBounds(mult : Multiplicity, lower : Integer, upper : UnlimitedNatural) : Boolean
Check that the givenMultiplicityhaslowerBoundandupperBoundexpressions that are model-level
evaluable to the givenloweranduppervalues.
**body** if mult.oclIsKindOf(MultiplicityRange) then: mult <> null and

elsemult.oclAsType(MultiplicityRange).hasBounds(lower, upper)
mult.allSuperTypes()->exists(oclisKindOf(MultiplicityRange) and

endif oclAsType(MultiplicityRange).hasBounds(lower, upper)
**Constraints**
checkControlNodeSpecialization
AControlNodemust directly or indirectly specialize theActionUsage _Actions::Action::control_ from the
Systems Model Library.
specializesFromLibrary('Action::Action::controls')
validateControlNodeIncomingSuccessions
All incomingSuccessionsto aControlNodemust have a targetmultiplicityof1..1.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 295**


targetConnector->selectByKind(Succession)->collect(connectorEnd->at(2).multiplicity)->
forAll(targetMult |multiplicityHasBounds(targetMult, 1, 1))

validateControlNodeOutgoingSuccessions
All outgoingSuccessionsfrom aControlNodemust have a sourcemultiplicityof1..1.
sourceConnector->selectByKind(Succession)->collect(connectorEnd->at(1).multiplicity)->
forAll(sourceMult |multiplicityHasBounds(sourceMult, 1, 1))

validateControlNodeOwningType
TheowningTypeof aControlNodemust be anActionDefinitionorActionUsage.
owningType <> null and(owningType.oclIsKindOf(ActionDefinition) or
owningType.oclIsKindOf(ActionUsage))
**8.3.16.7DecisionNode
Description**
ADecisionNodeis aControlNodethat makes a selection from its outgoingSuccessions.
**General Classes**
ControlNode
**Attributes**
None.
**Operations**
None.
**Constraints**
checkDecisionNodeOutgoingSuccessionSpecialization
All outgoingSuccessions from a DecisionNodemust subset the inherited _outgoingHBLink_
featureof the DecisionNode.
sourceConnector->selectByKind(Succession)->forAll(subsetsChain(this,
resolveGlobal("ControlPerformances::MergePerformance::outgoingHBLink")))
checkDecisionNodeSpecialization
ADecisionNodemust directly or indirectly specialize theActionUsage _Actions::Action::decisions_ from
the Systems Model Library.

**296 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


specializesFromLibrary("Actions::Action::decisions")
validateDecisionNodeIncomingSuccessions
ADecisionNodemay have at most one incomingSuccession.
targetConnector->selectByKind(Succession)->size() <= 1
validateDecisionNodeOutgoingSuccessions
All outgoingSuccessionsfrom aDecisionNodemust have a targetmultiplicityof0..1.
sourceConnector->selectAsKind(Succession)->collect(connectorEnd->at(2))->
forAll(targetMult |multiplicityHasBounds(targetMult, 0, 1))

**8.3.16.8ForkNode
Description**
AForkNodeis aControlNodethat must be followed by successorActionsas given by all its outgoing
Successions.
**General Classes**
ControlNode
**Attributes**
None.
**Operations**
None.
**Constraints**
checkForkNodeSpecialization
AForkNodemust directly or indirectly specialize theActionUsage _Actions::Action::forks_ from the
Systems Model Library.
specializesFromLibrary("Actions::Action::forks")
validateForkNodeIncomingSuccessions
AForkNodemay have at most one incomingSuccession.
targetConnector->selectByKind(Succession)->size() <= 1
**8.3.16.9ForLoopActionUsage
Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 297**


AForLoopActionUsageis aLoopActionUsagethat specifies that itsbodyClauseActionUsageshould be
performed once for each value, in order, from the sequence of values obtained as the result of theseqArgument
Expression, with theloopVariableset to the value for each iteration.
**General Classes**
LoopActionUsage
**Attributes**
/loopVariable : ReferenceUsage
TheownedFeatureof thisForLoopActionUsage that acts as the loop variable, which is assigned the successive
values of the input sequence on each iteration. It is theownedFeaturethat redefines _ForLoopAction::var_.
/seqArgument : Expression
TheExpressionwhose result provides the sequence of values to which theloopVariableis set for each iterative
performance of thebodyAction. It is the ownedparameterthat redefines _ForLoopAction::body_.
**Operations**
None.
**Constraints**
checkForLoopActionUsageSpecialization
AForLoopActionUsagemust directly or indirectly specialize theActionUsage _Actions::forLoopActions_
from the Systems Model Library.
specializesFromLibrary('Actions::forLoopActions')
checkForLoopActionUsageSubactionSpecialization
A compositeForLoopActionUsagethat is a subaction usage must directly or indirectly specialize the
ActionUsage _Actions::Action::forLoops_ from the Systems Model Library.
isSubactionUsage() impliesspecializesFromLibrary('Actions::Action::forLoops')

checkForLoopActionUsageVarRedefinition
TheloopVariableof aForLoopActionUsagemust redefine theActionUsage
_Actions::ForLoopAction::var_.
loopVariable <> null andloopVariable.redefinesFromLibrary('Actions::ForLoopAction::var')

deriveForLoopActionUsageLoopVariable
TheloopVariableof aForLoopActionUsageis its firstownedFeature, which must be aReferenceUsage.
loopVariable =if ownedFeature->isEmpty() or

**298 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


not ownedFeature->first().oclIsKindOf(ReferenceUsage) thennull
elseownedFeature->first().oclAsType(ReferenceUsage)
endif
deriveForLoopActionUsageSeqArgument
TheseqArgumentof aForLoopActionUsageis its first inputparameter, which must be anExpression.
seqArgument =let parameter : Feature = inputParameter(1) in
if parameter <> null and parameter.oclIsKindOf(Expression) thenparameter.oclAsType(Expression)
elsenull
endif
**8.3.16.10IfActionUsage
Description**
AnIfActionUsageis anActionUsagethat specifies that thethenActionActionUsageshould be performed if
the result of theifArgumentExpressionis true. It may also optionally specify anelseActionActionUsage
that is performed if the result of theifArgumentis false.
**General Classes**
ActionUsage
**Attributes**
/elseAction : ActionUsage [0..1]
TheActionUsagethat is to be performed if the result of theifArgumentis false. It is the (optional) third
parameterof theIfActionUsage.
/ifArgument : Expression
TheExpressionwhose result determines whether thethenActionor (optionally) theelseActionis performed.
It is the firstparameterof the IfActionUsage.
/thenAction : ActionUsage
TheActionUsagethat is to be performed if the result of theifArgumentis true. It is the secondparameterof
the IfActionUsage.
**Operations**
None.
**Constraints**
checkIfActionUsageSpecialization

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 299**


AIfActionUsagemust directly or indirectly specialize theActionUsage _Actions::ifThenActions_ from the
Systems Model Library. If it has anelseAction, then it must directly or indirectly specialize
_Actions::ifThenElseActions_.
if elseAction = null thenspecifiesFromLibrary('Actions::ifThenActions')
elsespecifiesFromLibrary('Actions::ifThenElseActions')
endif
checkIfActionUsageSubactionSpecialization
A compositeIfActionUsagethat is a subaction usage must directly or indirectly specialize theActionUsage
_Actions::Action::ifSubactions_ from the Systems Model Library.
isSubactionUsage() impliesspecializesFromLibrary('Actions::Action::ifSubactions')

deriveIfActionUsageElseAction
TheelseActionof anifActionUsageis its thirdparameter, if there is one, which must then be an
ActionUsage.
elseAction =let parameter : Feature = inputParameter(3) in
if parameter <> null and parameter.oclIsKindOf(ActionUsage) thenparameter.oclAsType(ActionUsage)
elsenull
endif
deriveIfActionUsageIfArgument
TheifArgumentof anifActionUsageis its firstparameter, which must be anExpression.
ifArgument =let parameter : Feature = inputParameter(1) in
if parameter <> null and parameter.oclIsKindOf(Expression) thenparameter.oclAsType(Expression)
elsenull
endif
deriveIfActionUsageThenAction
ThethenActionof anifActionUsageis its secondparameter, which must be anActionUsage.
thenAction =let parameter : Feature = inputParameter(2) in
if parameter <> null and parameter.oclIsKindOf(ActionUsage) thenparameter.oclAsType(ActionUsage)
elsenull
endif

**300 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.3.16.11JoinNode
Description**
AJoinNodeis aControlNodethat waits for the completion of all the predecessorActionsgiven by incoming
Successions.
**General Classes**
ControlNode
**Attributes**
None.
**Operations**
None.
**Constraints**
checkJoinNodeSpecialization
AJoinNodemust directly or indirectly specialize theActionUsage _Actions::Action::joins_ from the
Systems Model Library.
specializesFromLibrary("Actions::Action::join")
validateJoinNodeOutgoingSuccessions
AJoinNodemay have at most one outgoingSuccession.
sourceConnector->selectByKind(Succession)->size() <= 1
**8.3.16.12LoopActionUsage
Description**
ALoopActionUsageis anActionUsagethat specifies that itsbodyActionshould be performed repeatedly. Its
subclassesWhileLoopActionUsageandForLoopActionUsageprovide different ways to determine how many
times thebodyActionshould be performed.
**General Classes**
ActionUsage
**Attributes**
/bodyAction : ActionUsage
TheActionUsageto be performed repeatedly by theLoopActionUsage. It is the secondparameterof the
LoopActionUsage.
**Operations**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 301**


None.
**Constraints**
deriveForLoopActionUsageBodyAction
ThebodyActionof aLoopActionUsageis its second inputparameter, which must be anAction.
bodyAction =let parameter : Feature = inputParameter(2) in
if parameter <> null and parameter.oclIsKindOf(Action) thenparameter.oclAsType(Action)
elsenull
endif
**8.3.16.13MergeNode
Description**
AMergeNodeis aControlNodethat asserts the merging of its incomingSuccessions. AMergeNodemay have
at most one outgoingSuccessions.
**General Classes**
ControlNode
**Attributes**
None.
**Operations**
None.
**Constraints**
checkMergeNodeIncomingSuccessionSpecialization
All incomingSuccessionsto aMergeNodemust subset the inherited _incomingHBLink_ feature
of the MergeNode.
targetConnector->selectByKind(Succession)->forAll(subsetsChain(this,
resolveGlobal("ControlPerformances::MergePerformance::incomingHBLink")))
checkMergeNodeSpecialization
AMergeNodemust directly or indirectly specialize theActionUsage _Actions::Action::merges_ from the
Systems Model Library.
specializesFromLibrary("Actions::Action::merges")
validateMergeNodeIncomingSuccessions
All incomingSuccessionsto aMergeNodemust have a sourcemultiplicityof0..1.

**302 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


targetConnector->selectByKind(Succession)->collect(connectorEnd->at(1))->
forAll(sourceMult |multiplicityHasBounds(sourceMult, 0, 1))

validateMergeNodeOutgoingSuccessions
AMergeNodemay have at most one outgoingSuccession.
sourceConnector->selectAsKind(Succession)->size() <= 1
**8.3.16.14PerformActionUsage
Description**
APerformActionUsageis anActionUsagethat represents the performance of anActionUsage. Unless it is the
PerformActionUsageitself, theActionUsageto be performed is related to thePerformActionUsageby a
ReferenceSubsettingrelationship. APerformActionUsageis also anEventOccurrenceUsage, with its
performedActionas theeventOccurrence.
**General Classes**
EventOccurrenceUsage
ActionUsage
**Attributes**
/performedAction : ActionUsage {redefines eventOccurrence}
TheActionUsageto be performed by thisPerformedActionUsage. It is theeventOccurrenceof the
PerformActionUsageconsidered as anEventOccurrenceUsage, which must be anActionUsage.
**Operations**
namingFeature() : Feature [0..1]
The namingFeatureof aPerformActionUsageis itsperformedAction.
**body** : exhibitedState
**Constraints**
checkPerformActionUsageSpecialization
If aPerformActionUsagehas anowningTypethat is aPartDefinitionorPartUsage, then it must directly or
indirectly specialize theActionUsage _Parts::Part::performedActions_.
owningType <> null and(owningType.oclIsKindOf(PartDefinition) or
owningType.oclIsKindOf(PartUsage)) impliesspecializesFromLibrary('Parts::Part::performedActions')

validatePerformActionUsageReference
If aPerformActionUsagehas anownedReferenceSubsetting, then itsreferencedFeaturemust be a
ActionUsage.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 303**


ownedReferenceSubsetting <> null impliesownedReferenceSubsetting.referencedFeature.oclIsKindOf(ActionUsage)

**8.3.16.15SendActionUsage
Description**
ASendActionUsageis anActionUsagethat specifies the sending of a payload given by the result of its
payloadArgumentExpressionvia a _MessageTransfer_ whose _source_ is given by the result of the
senderArgumentExpressionand whosetargetis given by the result of thereceiverArgument
Expression. If nosenderArgumentis provided, the default is the _this_ context for the action. If no
receiverArgumentis given, then the receiver is to be determined by, e.g., outgoing _Connections_ from the
sender.
**General Classes**
ActionUsage
**Attributes**
/payloadArgument : Expression
AnExpressionwhose result is bound to the _payload_ input parameter of thisSendActionUsage.
/receiverArgument : Expression [0..1]
AnExpressionwhose result is bound to the _receiver_ input parameter of thisSendActionUsage.
/senderArgument : Expression [0..1]
AnExpressionwhose result is bound to the _sender_ input parameter of thisSendActionUsage.
**Operations**
None.
**Constraints**
checkSendActionUsageSpecialization
ASendActionUsagemust directly or indirectly specialize theActionUsage _Actions::sendActions_ from the
Systems Model Library.
specializesFromLibrary("Actions::sendActions")
checkSendActionUsageSubactionSpecialization
A compositeSendActionUsagethat is a subaction must directly or indirectly specialize theActionUsage
_Actions::Action::sendSubactions_ from the Systems Model Library.
isSubactionUsage() impliesspecializesFromLibrary('Actions::Action::acceptSubactions')

deriveSendActionUsagePayloadArgument

**304 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ThepayloadArgumentof aSendActionUsageis its first argumentExpression.
payloadArgument = argument(1)
deriveSendActionUsageReceiverArgument
ThereceiverArgumentof aSendActionUsageis its third argumentExpression.
receiverArgument = argument(3)
deriveSendActionUsageSenderArgument
ThesenderArgumentof aSendActionUsageis its second argumentExpression.
senderArgument = argument(2)
validateSendActionParameters
ASendActionUsagemust have at least three owned inputparameters, corresponding to its _payload_ , _sender_
and _receiver_ , respectively (whether or not they haveFeatureValues).
inputParameters()->size() >= 3
**8.3.16.16TriggerInvocationExpression
Description**
ATriggerInvocationExpressionis anInvocationExpression that invokes one of the
triggerFunctionsfrom the Kernel Semantic Library _Triggers package, as indicated by
its kind._
**General Classes**
InvocationExpression
**Attributes**
kind : TriggerKind
Indicates which of theFunctionsfrom the _Triggers_ model in the Kernel Semantic Library is to be invoked by
thisTriggerInvocationExpression.
**Operations**
None.
**Constraints**
checkTriggerInvocationExpressionSpecialization
ATriggerInvocationExpressionmust directly or indirectly specialize one of theFunctions _TriggerWhen_ ,
_TriggerAt_ or _TriggerAfter_ , from the Kernel Semantic Library Triggers package, depending on whether its
kindiswhen,atorafter, respectively.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 305**


specializesFromLibrary(if kind = TriggerKind::when then

else if kind = TriggerKind::at then'Triggers::TriggerWhen'
else'Triggers::TriggerAt'
endif endif'Triggers::TriggerAfter'
)
**8.3.16.17TriggerKind
Description**
TriggerKindenumerates the kinds of triggers that can be represented by aTriggerInvocationExpression.
**General Classes**
None.
**Literal Values**
after
Indicates a _relative time trigger_ , corresponding to the _TriggerAfter_ Functionfrom the _Triggers_ model in the
Kernel Semantic Library.
at
Indicates an _absolute time trigger_ , corresponding to the _TriggerAt_ Functionfrom the _Triggers_ model in the
Kernel Semantic Library.
when
Indicates a _change trigger_ , corresponding to the _TriggerWhen_ Functionfrom the _Triggers_ model in the Kernel
Semantic Library.
**8.3.16.18WhileLoopsActionusage
Description**
AWhileLoopActionUsageis aLoopActionUsagethat specifies that thebodyClauseActionUsageshould be
performed repeatedly while the result of thewhileArgumentExpressionis true or until the result of the
untilArgumentExpression(if provided) is true. ThewhileArgumentExpressionis evaluated before each
(possible) performance of thebodyClause, and theuntilArgumentExpressionis evaluated after each
performance of thebodyClause.
**General Classes**
LoopActionUsage
**Attributes**
/untilArgument : Expression [0..1]

**306 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


TheExpressionwhose result, if false, determines that thebodyActionshould continue to be performed. It is the
(optional) third ownedparameterof theWhileLoopActionUsage.
/whileArgument : Expression
TheExpressionwhose result, if true, determines that thebodyActionshould continue to be performed. It is the
first ownedparameterof theWhileLoopActionUsage.
**Operations**
None.
**Constraints**
checkWhileLoopActionUsageSpecialization
AWhileLoopActionUsagemust directly or indirectly specialize theActionUsage
_Actions::whileLoopActions_ from the Systems Model Library.
specializesFromLibrary('Actions::whileLoopActions')
checkWhileLoopActionUsageSubactionSpecialization
A compositeWhileLoopActionUsagethat is a subaction usage must directly or indirectly specialize the
ActionUsage _Actions::Action::whileLoops_ from the Systems Model Library.
isSubactionUsage() impliesspecializesFromLibrary('Actions::Action::whileLoops')

deriveWhileLoopActionUsageUntilArgument
ThewhileArgumentof aWhileLoopActionUsageis its third inputparameter, which, if it exists, must be an
Expression.
untilArgument =let parameter : Feature = inputParameter(3) in
if parameter <> null and parameter.oclIsKindOf(Expression) thenparameter.oclAsType(Expression)
elsenull
endif
deriveWhileLoopActionUsageWhileArgument
ThewhileArgumentof aWhileLoopActionUsageis its first inputparameter, which must be anExpression.
whileArgument =let parameter : Feature = inputParameter(1) in
if parameter <> null and parameter.oclIsKindOf(Expression) thenparameter.oclAsType(Expression)
elsenull
endif

**8.3.17States Abstract Syntax**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 307**


**8.3.17.1Overview**

```
+isParallel : Boolean = false StateDefinition +isParallel : Boolean = false StateUsage
```
```
OccurrenceDefinition
```
```
ActionDefinition
```
```
OccurrenceUsage
```
```
Definition
```
```
ActionUsage
```
```
Usage
```
```
Behavior
```
```
+/stateOwningDefinition{subsets actionOwningDefinition}0..1
```
```
{subsets ownedAction, ordered}
```
```
0..*+/ownedState
```
```
+/stateDefinition{redefines actionDefinition, ordered}0..*
```
```
{subsets definedAction}
```
```
+/definedState0..*
```
```
{redefines actionOwningUsage}
```
```
+/stateOwningUsage0..1
```
```
{subsets nestedAction, ordered}
0..*+/nestedState
```
```
+/exitAction0..1
```
```
0..*+/exitedStateDefinition
```
```
0..*+/enteredStateDefinition
```
```
+/entryAction0..1
```
```
0..*+/activeStateDefintion
```
```
+/doAction0..1
```
```
{subsets action, ordered}
```
```
+/state0..*
{subsets featuringBehavior}
0..*+/featuringStateDefinition
```
```
0..*+/enteredState
```
```
+/entryAction0..1
+/doAction0..1
```
```
0..*+/activeState
```
```
0..*+/exitedState
```
```
+/exitAction0..1
```
**Figure 29. State Definition and Usage**

```
+kind : TransitionFeatureKind
```
```
TransitionFeatureMembership
+kind : StateSubactionKind
```
```
StateSubactionMembership
effectguard
```
```
trigger
```
```
TransitionFeatureKind «enumeration»
```
```
FeatureMembership
```
```
exitdo
```
```
entry
```
```
StateSubactionKind «enumeration»
```
```
ActionUsage Step
```
```
+/action{redefines ownedMemberFeature} 1
```
```
+/stateSubactionMembership{subsets owningFeatureMembership}0..1
```
```
+/transitionFeature{redefines ownedMemberFeature} 1
```
```
+/transitionFeatureMembership{subsets owningFeatureMembership}0..1
```
**Figure 30. State Membership**

**308 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
PerformActionUsage
```
```
ExhibitStateUsage
```
```
StateUsage
{redefines performedAction}
```
```
+/exhibitedState
1
```
```
{subsets performingAction}
```
```
+/exhibitingState
0..*
```
**Figure 31. Exhibited States**

```
TransitionUsage
```
```
AcceptActionUsage
```
```
Definition
```
```
OccurrenceUsage
```
```
ActionUsage
```
```
Usage
```
```
Succession
```
```
Expression
```
```
+/transitionOwningUsage
{subsets owningUsage}
```
```
0..1
```
```
{subsets nestedUsage}
```
```
+/nestedTransition
0..*
```
```
{subsets owningType}
```
```
+/triggeredTransition
0..1
{subsets ownedFeature}
```
```
+/triggerAction
0..*
```
```
{subsets owningType}
```
```
+/guardedTransition
0..1
{subsets ownedFeature}
```
```
+/guardExpression
0..*
```
```
{subsets owningNamespace}
```
```
+/linkedTransition
0..1
{subsets ownedMember}
```
```
+/succession
1
```
```
+/source
1
```
```
+/outgoingTransition
0..*
```
```
{subsets ownedUsage}
```
```
+/ownedTransition
0..*
```
```
+/transitionOwningDefinition{subsets owningDefinition}0..1
```
```
+/incomingTransition
0..*
```
```
+/target
1
```
```
{subsets owningType}
```
```
+/activeTransition
0..1
```
```
{subsets feature}
```
```
+/effectAction
0..*
```
**Figure 32. Transition Usage
8.3.17.2ExhibitStateUsage
Description**
AnExhibitStateUsageis aStateUsagethat represents the exhibiting of aStateUsage. Unless it is the
StateUsageitself, theStateUsageto be exhibited is related to theExhibitStateUsageby a

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 309**


ReferenceSubsettingRelationship. AnExhibitStateUsageis also aPerformActionUsage, with its
exhibitedStateas theperformedAction.
**General Classes**
StateUsage
PerformActionUsage
**Attributes**
/exhibitedState : StateUsage {redefines performedAction}
TheStateUsageto be exhibited by theExhibitStateUsage. It is theperformedActionof the
ExhibitStateUsageconsidered as aPerformActionUsage, which must be aStateUsage.
**Operations**
None.
**Constraints**
checkExhibitStateUsageSpecialization
If anExhibitStateUsagehas anowningTypethat is aPartDefinitionorPartUsage, then it must directly or
indirectly specialize theStateUsage _Parts::Part::exhibitedStates_.
owningType <> null and(owningType.oclIsKindOf(PartDefinition) or
owningType.oclIsKindOf(PartUsage)) impliesspecializesFromLibrary('Parts::Part::exhibitedStates')

**8.3.17.3StateSubactionKind
Description**
AStateSubactionKindindicates whether theactionof a StateSubactionMembership is an entry, do or exit
action.
**General Classes**
None.
**Literal Values**
do
Indicates that theactionof aStateSubactionMembershipis adoAction.
entry
Indicates that theactionof aStateSubactionMembershipis anentryAction.
exit
Indicates that theactionof aStateSubactionMembershipis anexitAction.

**310 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.3.17.4StateSubactionMembership
Description**
AStateSubactionMembershipis aFeatureMembershipfor an entry, do or exitActionUsage of a
StateDefinitionor StateUsage.
**General Classes**
FeatureMembership
**Attributes**
/action : ActionUsage {redefines ownedMemberFeature}
TheActionUsagethat is theownedMemberFeatureof thisStateSubactionMembership.
kind : StateSubactionKind
Whether thisStateSubactionMembershipis for anentry, doorexitActionUsage.
**Operations**
None.
**Constraints**
validateStateSubactionMembershipOwningType
TheowningTypeof aStateSubactionMembershipmust be aStateDefinitionor aStateUsage.
owningType.oclIsKindOf(StateDefinition) orowningType.oclIsKindOf(StateUsage)

**8.3.17.5StateDefinition
Description**
AStateDefinitionis theDefinitionof the Behavior of a system or part of a system in a certain state
condition.
AStateDefinitionmay be related to up to three of itsownedFeaturesbyStateBehaviorMembership
Relationships, all of different kinds, corresponding to the entry, do and exit actions
of the StateDefinition.
**General Classes**
ActionDefinition
**Attributes**
/doAction : ActionUsage [0..1]

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 311**


TheActionUsageof thisStateDefinitionto be performed while in the state defined by the
StateDefinition. It is the ownedActionUsagerelated to theStateDefinitionby a
StateSubactionMembershipwithkind = do.
/entryAction : ActionUsage [0..1]
TheActionUsageof thisStateDefinitionto be performed on entry to the state defined by the
StateDefinition. It is the ownedActionUsagerelated to theStateDefinitionby a
StateSubactionMembershipwithkind = entry.
/exitAction : ActionUsage [0..1]
TheActionUsageof thisStateDefinitionto be performed on exit to the state defined by the
StateDefinition. It is the ownedActionUsagerelated to theStateDefinitionby a
StateSubactionMembershipwithkind = exit.
isParallel : Boolean
Whether theownedStatesof thisStateDefinitionare to all be performed in parallel. If true, none of the
ownedActions(which includesownedStates) may have any incoming or outgoingTransitions. If false, only
oneownedStatemay be performed at a time.
/state : StateUsage [0..*] {subsets action, ordered}
TheStateUsages, which areactionsin theStateDefinition, that specify the discrete states in the behavior
defined by theStateDefinition.
**Operations**
None.
**Constraints**
checkStateDefinitionSpecialization
AStateDefinitionmust directly or indirectly specialize theStateDefinition _States::StateAction_ from
the Systems Model Library.
specializesFromLibrary('States::StateAction')
deriveStateDefinitionDoAction
ThedoActionof aStateDefinitionis theactionof the ownedStateSubactionMembershipwithkind =
do.
doAction =let doMemberships : Sequence(StateSubactionMembership) =
ownedMembership->selectByKind(StateSubactionMembership)->
if doMemberships->isEmpty() then nullselect(kind = StateSubactionKind::do) in
else doMemberships->at(1)endif

deriveStateDefinitionEntryAction

**312 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


TheentryActionof aStateDefinitionis theactionof the ownedStateSubactionMembershipwith
kind = entry.
entryAction =let entryMemberships : Sequence(StateSubactionMembership) =
ownedMembership->selectByKind(StateSubactionMembership)->
if entryMemberships->isEmpty() then nullselect(kind = StateSubactionKind::entry) in
else entryMemberships->at(1)endif

deriveStateDefinitionExitAction
TheexitActionof aStateDefinitionis theactionof the ownedStateSubactionMembershipwithkind
= exit.
exitAction =let exitMemberships : Sequence(StateSubactionMembership) =
ownedMembership->selectByKind(StateSubactionMembership)->
if exitMemberships->isEmpty() then nullselect(kind = StateSubactionKind::exit) in
else exitMemberships->at(1)endif

deriveStateDefinitionState
Thestatesof aStateDefinitionare those of itsactionsthat areStateUsages.
state = action->selectByKind(StateUsage)
validateStateDefinitionIsParallelGeneralization
Every generalization of aStateDefinitionthat is also aStateDefinitionmust have the same value for
isParallelas thisStateDefinition.
ownedGeneralization.general->selectByKind(StateDefinition)->forAll(g | g.isParallel = isParallel)

validateStateDefinitionParallelSubactions
If aStateDefinitionis parallel, then itsownedActions(which includes itsownedStates) must not have any
incomingTransitionsoroutgoingTransitions.
isParallel impliesownedAction.incomingTransition->isEmpty() and
ownedAction.outgoingTransition->isEmpty()
validateStateDefinitionStateSubactionKind
AStateDefinitionmust not have more than one ownedStateSubactionMembershipof eachkind.
ownedMembership->selectByKind(StateSubactionMembership)->
isUnique(kind)

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 313**


**8.3.17.6StateUsage
Description**
AStateUsageis anActionUsagethat is nominally theUsageof aStateDefinition. However, other kinds of
kernelBehaviorsare also allowed astypes, to permit use ofBehaviors
AStateUsagemay be related to up to three of itsownedFeaturesbyStateSubactionMembership
Relationships, all of different kinds, corresponding to the entry, do and exit actions
of the StateUsage.
**General Classes**
ActionUsage
**Attributes**
/doAction : ActionUsage [0..1]
TheActionUsageof thisStateUsageto be performed while in the state defined by theStateDefinition. It is
the ownedActionUsagerelated to theStateUsageby aStateSubactionMembershipwithkind = do.
/entryAction : ActionUsage [0..1]
TheActionUsageof thisStateUsageto be performed on entry to the state defined by theStateDefinition. It
is the ownedActionUsagerelated to theStateUsageby aStateSubactionMembershipwithkind = entry.
/exitAction : ActionUsage [0..1]
TheActionUsageof thisStateUsageto be performed on exit to the state defined by theStateDefinition. It is
the ownedActionUsagerelated to theStateUsageby aStateSubactionMembershipwithkind = exit.
isParallel : Boolean
Whether thenestedStatesof thisStateUsageare to all be performed in parallel. If true, none of the
nestedActions(which includenestedStates) may have any incoming or outgoingTransitions. If false, only
onenestedStatemay be performed at a time.
/stateDefinition : Behavior [0..*] {redefines actionDefinition, ordered}
TheBehaviorsthat are thetypes of thisStateUsage. Nominally, these would be
StateDefinitions, but kernel Behaviorsare also allowed, to permit use ofBehaviors
from the Kernel Model Libraries.
**Operations**
isSubstateUsage(isParallel : Boolean) : Boolean
Check if thisStateUsageis composite and has anowningTypethat is anStateDefinitionorStateUsage
with the given value ofisParallel, but is _not_ anentryActionorexitAction. If so, then it represents a
_StateAction_ that is a _substate_ or _exclusiveState_ (forisParallel = false) of another _StateAction_.
**body** (owningType.oclIsKindOf(StateDefinition) and: owningType <> null and
owningType.oclAsType(StateDefinition).isParallel = isParallel or

**314 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


owningType.oclIsKindOf(StateUsage) andowningType.oclAsType(StateUsage).isParallel = isParallel) and
not owningFeatureMembership.oclIsKindOf(StateSubactionMembership)
**Constraints**
checkStateUsageExclusiveStateSpecialization
AStateUsagethat is a substate usage with a non-parallel owningStateDefinitionorStateUsagemust
directly or indirectly specialize theStateUsage _States::State::exclusiveStates_ from the Systems Model
Library.
isSubstateUsage(true) impliesspecializesFromLibrary('States::State::substates')

checkStateUsageSpecialization
AStateUsagemust directly or indirectly specialize theStateUsage _States::stateActions_ from the Systems
Model Library.
specializesFromLibrary('States::StateAction')
checkStateUsageSubstateSpecialization
AStateUsagethat is a substate usage with a owningStateDefinitionorStateUsagethat is parallel must
directly or indirectly specialize theStateUsage _States::State::substates_ from the Systems Model Library.
isSubstateUsage(false) impliesspecializesFromLibrary('States::State::substates')

deriveStateUsageDoAction
ThedoActionof aStateUsageis theactionof the ownedStateSubactionMembershipwithkind = do.
doAction =let doMemberships : Sequence(StateSubactionMembership) =
ownedMembership->selectByKind(StateSubactionMembership)->
if doMemberships->isEmpty() then nullselect(kind = StateSubactionKind::do) in
else doMemberships->at(1)endif

deriveStateUsageEntryAction
TheentryActionof aStateUsageis theactionof the ownedStateSubactionMembershipwithkind =
entry.
entryAction =let entryMemberships : Sequence(StateSubactionMembership) =
ownedMembership->selectByKind(StateSubactionMembership)->
if entryMemberships->isEmpty() then nullselect(kind = StateSubactionKind::entry) in
else entryMemberships->at(1)endif

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 315**


deriveStateUsageExitAction
TheexitActionof aStateUsageis theactionof the ownedStateSubactionMembershipwithkind =
exit.
exitAction =let exitMemberships : Sequence(StateSubactionMembership) =
ownedMembership->selectByKind(StateSubactionMembership)->
if exitMemberships->isEmpty() then nullselect(kind = StateSubactionKind::exit) in
else exitMemberships->at(1)endif

validateStateUsageIsParallelGeneralization
Every generalization of a StateUsage that is also a StateDefinition or a StateUsage must have the same value for
isParallelas this StateUsage.
let general : Sequence(Type) = ownedGeneralization.general ingeneral->selectByKind(StateDefinition)->

general->selectByKind(StateUsage)->forAll(g | g.isParallel = isParallel) and
forAll(g | g.parallel = isParallel)
validateStateUsageParallelSubactions
If aStateUsageis parallel, then itsnestedActions(which includesnestedStates) must not have any
incomingTransitionsoroutgoingTransitions.
isParallel impliesnestedAction.incomingTransition->isEmpty() and
nestedAction.outgoingTransition->isEmpty()
validateStateUsageStateSubactionKind
AStateUsagemust not have more than one ownedStateSubactionMembershipof eachkind.
ownedMembership->selectByKind(StateSubactionMembership)->
isUnique(kind)
**8.3.17.7TransitionFeatureKind
Description**
ATransitionActionKindindicates whether thetransitionFeatureof aTransitionFeatureMembership
is a trigger, guard or effect.
**General Classes**
None.
**Literal Values**
effect

**316 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Indicates that thetransitionFeatureof aTransitionFeatureMembershipis aneffectAction.
guard
Indicates that thetransitionFeatureof aTransitionFeatureMembershipis aguardExpression.
trigger
Indicates that thetransitionFeatureof aTransitionFeatureMembershipis atriggerAction.
**8.3.17.8TransitionFeatureMembership
Description**
ATransitionFeatureMembershipis aFeatureMembershipfor a trigger, guard or effect of a
TransitionUsage, whosetransitionFeatureis aAcceptActionUsage, _Boolean_ -valued
Expressionor ActionUsage, depending on its kind.
**General Classes**
FeatureMembership
**Attributes**
kind : TransitionFeatureKind
Whether thisTransitionFeatureMembershipis for atrigger,guardoreffect.
/transitionFeature : Step {redefines ownedMemberFeature}
TheStepthat is theownedMemberFeatureof thisTransitionFeatureMembership.
**Operations**
None.
**Constraints**
validateTransitionFeatureMembershipEffectAction
If thekindof aTransitionUsageiseffect, then itstransitionFeaturemust be a kind ofActionUsage.
kind = TransitionFeatureKind::effect impliestransitionFeature.oclIsKindOf(ActionUsage)

validateTransitionFeatureMembershipGuardExpression
If thekindof aTransitionUsageisguard, then itstransitionFeaturemust be a kind ofExpression
whose result is a _Boolean_ value.
kind = TransitionFeatureKind::guard impliestransitionFeature.oclIsKindOf(Expression) and
let guard : Expression = transitionFeature.oclIsKindOf(Expression) inguard.result.specializesFromLibrary('ScalarValues::Boolean') and

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 317**


```
guard.result.multiplicity <> null andguard.result.multiplicity.hasBounds(1,1)
```
validateTransitionFeatureMembershipOwningType
TheowningTypeof aTransitionFeatureMembershipmust be aTransitionUsage.
owningType.oclIsKindOf(TransitionUsage)
validateTransitionFeatureMembershipTriggerAction
If thekindof aTransitionUsageistrigger, then itstransitionFeaturemust be a kind of
AcceptActionUsage.
kind = TransitionFeatureKind::trigger impliestransitionFeature.oclIsKindOf(AcceptActionUsage)

**8.3.17.9TransitionUsage
Description**
ATransitionUsageis anActionUsage representing a triggered transition between
ActionUsagesorStateUsages. When triggered by a triggerAction, when its
guardExpressionis true, the TransitionUsageasserts that its source is exited, then
its effectAction(if any) is performed, and then itstarget is entered.
ATransitionFeatureMembershipTransitionUsagecan be related to some of itsRelationships, corresponding to theownedFeatures usingtriggerAction,
guardExpressionand effectActionof the TransitionUsage.
**General Classes**
ActionUsage
**Attributes**
/effectAction : ActionUsage [0..*] {subsets feature}
TheActionUsagesthat define the effects of thisTransitionUsage, which are theownedFeaturesof the
TransitionUsagerelated to it byTransitionFeatureMembershipswithkind = effect, which must all be
Expressions.
/guardExpression : Expression [0..*] {subsets ownedFeature}
TheExpressionsthat define the guards of thisTransitionUsage, which are theownedFeaturesof the
TransitionUsagerelated to it byTransitionFeatureMembershipswithkind = guard, which must all be
Expressions.
/source : ActionUsage
The sourceActionUsageof thisTransitionUsage, which becomes thesourceof thesuccessionfor the
TransitionUsage.
/succession : Succession {subsets ownedMember}

**318 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


TheSuccessionthat is theownedFeatureof thisTransitionUsage, which, if theTransitionUsageis
triggered, asserts the temporal ordering of thesourceandtarget.
/target : ActionUsage
The targetActionUsageof thisTransitionUsage, which is thetargetFeature of thesuccession
for theTransitionUsage.
/triggerAction : AcceptActionUsage [0..*] {subsets ownedFeature}
TheAcceptActionUsagesthat define the triggers of thisTransitionUsage, which are theownedFeaturesof
theTransitionUsagerelated to it byTransitionFeatureMembershipswithkind = trigger, which must
all beAcceptActionUsages.
**Operations**
triggerPayloadParameter() : ReferenceUsage [0..1]
Return thepayloadParameterof thetriggerActionof thisTransitionUsage, if it has one.
**body** else triggerAction->first().payloadParameter: if triggerAction->isEmpty() then null
endif
**Constraints**
checkTransitionUsageActionSpecialization
A compositeTransitionUsagewhoseowningTypeis aActionDefinitionorActionUsage, but _not_ a
StateDefinitionorStateUsage, must directly or indirectly specialize theActionUsage
_Actions::Action::decisionTransitions_ from the Systems Model Library.
isComposite and owningType <> null and(owningType.oclIsKindOf(ActionDefinition) or

not (owningType.oclIsKindOf(StateDefinition) orowningType.oclIsKindOf(ActionUsage)) and
specializesFromLibrary("Actions::Action::decisionTransitionActions")owningType.oclIsKindOf(StateUsage)) implies
checkTransitionUsagePayloadSpecialization
If aTransitionUsage has atriggerAction, then the _payload_ parameterof the
TransitionUsagesubsets the Featurechain of the triggerActionand its
payloadParameter.
triggerAction->notEmpty() implieslet payloadParameter : Feature = inputParameter(2) in
payloadParameter <> null andpayloadParameter.subsetsChain(triggerAction->at(1), triggerPayloadParameter())

checkTransitionUsageSourceBindingConnector
ATransitionUsagemust have anownedMemberthat is aBindingConnectorbetween itssourceand its first
inputparameter(which redefines _Actions::TransitionAction::transitionLinkSource_ ).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 319**


ownedMember->selectByKind(BindingConnector)->exists(b |b.relatedFeatures->includes(source) and
b.relatedFeatures->includes(inputParameter(2)))
checkTransitionUsageSpecialization
ATransitionUsagemust directly or indirectly specialize theActionUsage _Actions::transitions_ from the
Systems Model Library.
specializesFromLibrary("Actions::actions::transitionActions")
checkTransitionUsageStateSpecialization
A compositeTransitionUsagewhoseowningTypeis aStateDefinitionorStateUsagemust directly or
indirectly specialize theActionUsage _States::State::stateTransitions_ from the Systems Model Library.
isComposite and owningType <> null and(owningType.oclIsKindOf(StateDefinition) or
owningType.oclIsKindOf(StateUsage)) impliesspecializesFromLibrary("States::State::stateTransitions")

checkTransitionUsageSuccessionBindingConnector
ATransitionUsagemust have anownedMemberthat is aBindingConnectorbetween itssuccessionand the
inheritedFeature _TransitionPerformances::TransitionPerformance::transitionLink_.
ownedMember->selectByKind(BindingConnector)->exists(b |b.relatedFeatures->includes(succession) and
b.relatedFeatures->includes(resolveGlobal('TransitionPerformances::TransitionPerformance::transitionLink')))

checkTransitionUsageSuccessionSourceSpecialization
ThesourceFeatureof thesuccessionof aTransitionUsagemust be thesourceof theTransitionUsage
(i.e., the firstconnectorEndof thesuccessionmust have aReferenceSubsettingRelationshipwith the
source).
succession.sourceFeature = source
checkTransitionUsageTransitionFeatureSpecialization
ThetriggerActions,guardExpressions, andeffectActionsof aTransitionUsagemust specialize,
respectively, the _accepter_ , _guard_ , and _effect_ featuresof theActionUsage
_Actions::TransitionActions_ from the Systems Model Library.
triggerAction->forAll(specializesFromLibrary('Actions::TransitionAction::accepter') andguardExpression->forAll(specializesFromLibrary('Actions::TransitionAction::guard') and
effectAction->forAll(specializesFromLibrary('Actions::TransitionAction::effect'))
deriveTransitionUsageEffectAction
TheeffectActionsof aTransitionUsageare thetransitionFeaturesof the
ownedFeatureMembershipsof theTransitionUsagewithkind = effect, which must all be
ActionUsages.

**320 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


triggerAction = ownedFeatureMembership->selectByKind(TransitionFeatureMembership)->
select(kind = TransitionFeatureKind::trigger).transitionFeatures->selectByKind(AcceptActionUsage)

deriveTransitionUsageGuardExpression
ThetriggerActionsof aTransitionUsageare thetransitionFeaturesof the
ownedFeatureMembershipsof theTransitionUsagewithkind = trigger, which must all be
Expressions.
guardExpression = ownedFeatureMembership->selectByKind(TransitionFeatureMembership)->
select(kind = TransitionFeatureKind::trigger).transitionFeature->selectByKind(Expression)

deriveTransitionUsageSource
Thesourceof aTransitionUsageis given by thememberElementof its firstownedMembership, which must
be anActionUsage.
source =if ownedMembership->isEmpty() then null
elselet member : Element =
if not member.oclIsKindOf(ActionUsage) then nullownedMembership->at(1).memberElement in
else member.oclAsKindOf(ActionUsage)endif
endif
deriveTransitionUsageSuccession
Thesuccessionof aTransitionUsageis its firstownedMemberthat is aSuccession.
succession = ownedMember->selectByKind(Succession)->at(1)
deriveTransitionUsageTarget
Thetargetof aTransitionUsageis given by thetargetFeatureof itssuccession, which must be an
ActionUsage.
target =if succession.targetFeature->isEmpty() then null
elselet targetFeature : Feature =
if not targetFeature.oclIsKindOf(ActionUsage) then nullsuccession.targetFeature->at(1) in
else targetFeature.oclAsType(ActionUsage)endif
endif
deriveTransitionUsageTriggerAction
ThetriggerActionsof aTransitionUsageare thetransitionFeaturesof the
ownedFeatureMembershipsof theTransitionUsagewithkind = trigger, which must all be
AcceptActionUsages.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 321**


triggerAction = ownedFeatureMembership->selectByKind(TransitionFeatureMembership)->
select(kind = TransitionFeatureKind::trigger).transitionFeature->selectByKind(AcceptActionUsage)

validateTransitionUsageParameters
ATransitionUsagemust have at least one owned inputparameterand, if it has atriggerAction, it must
have at least two.
if triggerAction->isEmpty() theninputParameters()->size() >= 1
elseinputParameters()->size() >= 2
endif

validateTransitionUsageSuccession
ATransitionUsagemust have anownedMemberthat is aSuccessionwith aActionUsageas its
targetFeature.
let successions : Sequence(Successions) =ownedMember->selectByKind(Succession) in
successions->notEmpty() andsuccessions->at(1).targetFeature->
forAll(oclIsKindOf(ActionUsage))

**8.3.18Calculations Abstract Syntax
8.3.18.1Overview**

```
+modelLevelEvaluable( visited : Feature [0..*] ) : Boolean{redefines modelLevelEvaluable} CalculationUsage
```
```
OccurrenceDefinition
```
```
Definition
```
```
CalculationDefinition
```
```
Function
```
```
ActionDefinition
```
```
OccurrenceUsage
ActionUsage
```
```
Usage
```
```
Expression
{redefines actionDefinition, redefines function, ordered}
```
```
+/calculationDefinition0..1
```
```
{subsets definedAction, subsets typedExpression}
```
```
+/definedCalculation0..*
```
```
{subsets ownedAction, ordered}
```
```
+/ownedCalculation0..*
```
```
{subsets actionOwningDefinition}
```
```
+/calculationOwningDefinition0..1
```
```
{subsets computedFunction, subsets featuringActionDefinition}
```
```
+/featuringCalculationDefinition0..*
{subsets action, subsets expression, ordered}
```
```
+/calculation0..*
```
```
+/calculationOwningUsage
{subsets actionOwningUsage}0..1
```
```
{subsets nestedAction, ordered}
```
```
+/nestedCalculation0..*
```
**Figure 33. Calculation Definition and Usage
8.3.18.2CalculationDefinition
Description**
ACalculationDefinitionis anActionDefinition that also defines aFunctionproducing aresult.

**322 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Classes**
ActionDefinition
Function
**Attributes**
/calculation : CalculationUsage [0..*] {subsets action, expression, ordered}
Theactionsof thisCalculationDefinitionthat areCalculationUsages.
**Operations**
None.
**Constraints**
checkCalculationDefinitionSpecialization
ACalculationDefinitionmust directly or indirectly specialize theCalculationDefinition
_Calculations::Calculation_ from the Systems Model Library.
specializesFromLibrary('Calculations::Calculation')
deriveCalculationUsageCalculation
Thecalculationsof aCalculationDefinitionare those of itsactionsthat areCalculationUsages.
calculation = action->selectByKind(CalculationUsage)
**8.3.18.3CalculationUsage
Description**
ACalculationUsageis anActionUsage that is also anExpression, and, so, is typed by a
Function. Nominally, if thetypeis aCalculationDefinition, aCalculationUsage is a
Usageof that CalculationDefinitionwithin a system. However, other kinds of kernel
Functionsare also allowed, to permit use ofFunctionsfrom the Kernel Model
Libraries.
**General Classes**
Expression
ActionUsage
**Attributes**
/calculationDefinition : Function [0..1] {redefines function, actionDefinition, ordered}
TheFunction that is thetypeof thisCalculationUsage. Nominally, this would be aCalculationDefinition,
but a kernelFunctionis also allowed, to permit use ofFunctionsfrom the Kernel Model Libraries.
**Operations**
modelLevelEvaluable(visited : Feature [0..*]) : Boolean

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 323**


ACalculationUsageis not model-level evaluable.
**body** : false
**Constraints**
checkCalculationUsageSpecialization
ACalculationUsagemust specialize directly or indirectly theCalculationUsage
_Calculations::calculations_ from the Systems Model Library.
specializesFromLibrary('Calculations::calculations')
checkCalculationUsageSubcalculationSpecialization
owningType <> null and(owningType.oclIsKindOf(CalculationDefinition) or
owningType.oclIsKindOf(CalculationUsage)) impliesspecializesFromLibrary('Calculations::Calculation::subcalculations')

**8.3.19Constraints Abstract Syntax
8.3.19.1Overview**

```
+modelLevelEvaluable( visited : Feature [0..*] ) : Boolean{redefines modelLevelEvaluable}+namingFeature() : Feature [0..1]{redefines namingFeature}
```
```
ConstraintUsage
```
```
BooleanExpression
```
```
ConstraintDefinition
```
```
OccurrenceDefinition OccurrenceUsage
```
```
Definition Usage
```
```
Predicate
{redefines predicate}
0..1+/constraintDefinition +/definedConstraint 0..*{subsets typedBooleanExpression}
```
```
{subsets occurrenceOwningDefinition}
0..1+/constraintOwningDefinition
```
```
{subsets ownedOccurrence, ordered}
```
```
+/ownedConstraint0..*
```
```
{subsets occurrenceOwningUsage}
0..1+/constraintOwningUsage
```
```
{subsets nestedOccurrence, ordered}
```
```
+/nestedConstraint0..*
```
**Figure 34. Constraint Definition and Usage**

```
AssertConstraintUsage
```
```
ConstraintUsage
```
```
Invariant
```
```
+/assertedConstraint
1
```
```
+/constraintAssertion0..*
```
**Figure 35. Asserted Constraints
8.3.19.2AssertConstraintUsage
Description**

**324 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


AnAssertConstraintUsageis aConstraintUsagethat is also anInvariantand, so, is asserted to be true
(by default). Unless it is theAssertConstraintUsageitself, the assertedConstraintUsageis related to the
AssertConstraintUsageby a ReferenceSubsettingRelationship.
**General Classes**
Invariant
ConstraintUsage
**Attributes**
/assertedConstraint : ConstraintUsage
TheConstraintUsageto be performed by theAssertConstraintUsage. It is thereferenceFeatureof the
ownedReferenceSubsettingfor theAssertConstraintUsage, if there is one, and, otherwise, the
AssertConstraintUsageitself.
**Operations**
None.
**Constraints**
checkAssertConstraintUsageSpecialization
If aAssertConstraintUsageis negated, then it must directly or indirectly specialize theConstraintUsage
_Constraints::negatedConstraints_. Otherwise, it must directly or indirectly specialize the
ConstraintUsage _Constraints::assertedConstraints_.
if isNegated thenspecializesFromLibrary('Constraints::negatedConstraints')
elsespecializesFromLibrary('Constraints::assertedConstraints')
endif
deriveAssertConstraintUsageAssertedConstraint
If anAssertConstraintUsagehas noownedReferenceSubsetting, then itsassertedConstraintis the
AssertConstraintUsageitself. Otherwise, theassertedConstraintis thereferencedFeatureof the
ownedReferenceSubsetting, which must be aConstraintUsage.
assertedConstraint =if ownedReferenceSubsetting = null then self
else ownedReferenceSubsetting.referencedFeature.oclAsType(ConstraintUsage)endif

**8.3.19.3ConstraintDefinition
Description**
AConstraintDefinitionis anOccurrenceDefinitionthat is also aPredicatethat defines a constraint that
may be asserted to hold on a system or part of a system.
**General Classes**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 325**


OccurrenceDefinition
Predicate
**Attributes**
None.
**Operations**
None.
**Constraints**
checkConstraintDefinitionSpecialization
AConstraintDefinitionmust directly or indirectly specialize the baseConstraintDefinition
_Constraints::ConstraintCheck_ from the Systems Model Library.
specializesFromLibrary('Constraints::ConstraintCheck')
**8.3.19.4ConstraintUsage
Description**
AConstraintUsageis anOccurrenceUsagethat is also aBooleanExpression, and, so, is typed by
a Predicate. Nominally, if the type is aConstraintDefinition, a ConstraintUsageis a
Usageof that ConstraintDefinition. However, other kinds of kernelPredicatesare also
allowed, to permit use ofPredicates from the Kernel Model Libraries.
**General Classes**
OccurrenceUsage
BooleanExpression
**Attributes**
/constraintDefinition : Predicate [0..1] {redefines predicate}
The (single)Predicatethat is the type of thisConstraintUsage. Nominally, this will be a
ConstraintDefinition, but other kinds ofPredicatesare also allowed, to permit use ofPredicatesfrom
the Kernel Model Libraries.
**Operations**
modelLevelEvaluable(visited : Feature [0..*]) : Boolean
AConstraintUsageis not model-level evaluable.
**body** : false
namingFeature() : Feature [0..1]
The namingFeatureof aConstraintUsagethat is owned by aRequirementConstraintMembershipand has
anownedReferenceSubsettingis thereferencedFeatureof thatownedReferenceSubsetting.

**326 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**body** ownedFeatureMembership.oclIsKindOf(RequirementConstraintMembership) and: if ownedFeatureMembership <> null and
ownedReferenceSubsetting <> null thenownedReferenceSubsetting.referencedFeature
elseself.oclAsType(OccurrenceUsage).namingFeature()
endif
**Constraints**
checkConstraintUsageCheckedConstraintSpecialization
AConstraintUsagewhoseowningTypeis anItemDefinitionorItemUsagemust directly or indirectly
specialize theConstraintUsage _Items::Item::checkedConstraints_.
owningType <> null and(owningType.oclIsKindOf(ItemDefinition) or
owningType.oclIsKindOf(ItemUsage)) impliesspecializesFromLibrary('Items::Item::checkedConstraints')

checkConstraintUsageRequirementConstraintSpecialization
AConstraintUsagewhoseowningFeatureMembershipis aRequirementConstraintMembershipmust
directly or indirectly specialize on theConstraintUsages _assumptions_ or _constraints_ from the
ConstraintDefinition _Requirements::RequirementCheck_ in the Systems Model Library, depending on
whether thekindof theRequirementConstraintMembershipisassumptionorrequirement, respectively.
owningFeatureMembership <> null andowningFeatureMembership.oclIsKindOf(RequirementConstraintMembership) implies
if owningFeatureMembership.oclAsType(RequirementConstraintMembership).kind =RequirementConstraintKind::assumption then
elsespecializesFromLibrary('Requirements::RequirementCheck::assumptions')
endifspecializesFromLibrary('Requirements::RequirementCheck::constraints')
checkConstraintUsageSpecialization
AConstraintUsagemust directly or indirectly specialize the baseConstraintUsage
_Constraints::constraintChecks_ from the Systems Model Library.
specializesFromLibrary('Constraints::constraintChecks')
**8.3.20Requirements Abstract Syntax**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 327**


**8.3.20.1Overview**

```
+/text : String [0..*]+reqId : String [0..1]{redefines declaredShortName}
```
```
RequirementDefinition
+/text : String [0..*]+reqId : String [0..1]{redefines declaredShortName}
```
```
RequirementUsage
```
```
OccurrenceDefinition
```
```
Definition
```
```
ConstraintDefinition
```
```
OccurrenceUsage
```
```
Usage
```
```
ConstraintUsage
```
```
PartUsage
```
```
ConcernUsage
```
```
Usage
```
```
+/requirementOwningDefinition{subsets constraintOwningDefinition} 0..1
```
```
+/ownedRequirement0..*{subsets ownedConstraint, ordered}
```
```
{subsets requiredConstraint, ordered}
```
```
+/framedConcern0..*
```
```
+/framingRequirement0..1+/stakholderOwningRequirement{subsets requiringRequirement}
{subsets parameteredStep, subsets partOwningUsage}0..1
```
```
{subsets nestedPart, subsets parameter, ordered}
```
```
+/stakeholderParameter0..*
```
```
{subsets assumingRequirementDefinition}
```
```
+/framingRequirementDefinition0..1
```
```
{subsets requiredConstraint, ordered}
```
```
+/framedConcern0..*
```
```
+/stakholderOwiningRequirementDefinition
{subsets parameteredStep, subsets partOwningUsage}0..1
```
```
{subsets ownedPart, subsets parameter, ordered}
```
```
+/stakeholderParameter0..*
```
```
+/assumingRequirementDefinition
{subsets owningType}0..1
```
```
{subsets ownedFeature, ordered}
```
```
{subsets ownedFeature, ordered}+/assumedConstraint0..*
```
```
+/requiredConstraint0..*
```
```
+/requiringRequirementDefinition
{subsets owningType}0..1
```
```
{subsets constraintOwningUsage}
```
```
+/requirementOwningUsage0..1
```
```
0..*+/nestedRequirement{subsets nestedConstraint, ordered}
```
```
0..1 {subsets parameteredStep, subsets partOwningUsage}+actorOwningRequirement
```
```
{subsets nestedPart, subsets parameter, ordered}
```
```
+/actorParameter0..*
```
```
{subsets definedConstraint}
```
```
+/definedRequirement0..*
{redefines constraintDefinition}
```
```
+/requirementDefinition0..1
```
```
+/actorOwningRequirementDefinition{subsets parameteredBehavior, subsets partOwningDefinition}0..1
```
```
{subsets ownedPart, subsets parameter, ordered}
```
```
+/actorParameter0..*
```
```
{subsets ownedFeature, ordered}+/assumedConstraint
0..*
```
```
+/assumingRequirement0..1{subsets owningType}
```
```
+/subjectOwningRequirement{subsets owningUsage, subsets parameteredStep} 0..1
```
```
{subsets nestedUsage, subsets parameter}
```
```
+/subjectParameter 1
```
```
0..1+/requiringRequirement{subsets owningType}
```
```
{subsets ownedFeature, ordered}+/requiredConstraint
0..*
```
```
0..1 {subsets owningDefinition, subsets parameteredBehavior}+/subjectOwningRequirementDefinition
```
```
{subsets ownedUsage, subsets parameter}
```
```
+/subjectParameter 1
```
**Figure 36. Requirement Definition and Usage**

```
SatisfyRequirementUsage
```
```
RequirementUsage AssertConstraintUsage
```
```
Feature
```
```
{redefines assertedConstraint}+/satisfiedRequirement
1
```
```
{subsets constraintAssertion}
```
```
+/requirementSatisfaction
```
```
0..*
```
```
+/satisfyingFeature 1
```
```
+/satisfiedRequirement 0..*
```
**Figure 37. Satisfied Requirements**

**328 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
OccurrenceDefinition
```
```
Definition
```
```
ConstraintDefinition
```
```
RequirementDefinition
```
```
ConcernDefinition
```
```
ConcernUsage
```
```
OccurrenceUsage
```
```
RequirementUsage
```
```
Usage
```
```
ConstraintUsage
```
```
{subsets definedRequirement}
```
```
+/definedConcern0..1
{redefines requirementDefinition}
0..1+/concernDefinition
```
```
{subsets requirementOwningDefinition}
```
```
+/concernOwningDefinition0..1
```
```
{subsets ownedRequirement}
```
```
+/ownedConcern0..*
```
```
{subsets requirementOwningUsage}
0..1+/concernOwningUsage
```
```
{subsets nestedRequirement}
```
```
+/nestedConcern0..*
```
**Figure 38. Concern Definition and Usage**

```
+kind : RequirementConstraintKind = requirement{redefines kind} FramedConcernMembership
```
```
+kind : RequirementConstraintKind RequirementConstraintMembership
requirementassumption
```
```
RequirementConstraintKind «enumeration»
```
```
FeatureMembership
```
```
RequirementUsage
ConcernUsage
```
```
ConstraintUsage
+/referencingConstraintMembership0..* +/referencedConstraint 1
```
```
{redefines ownedMemberFeature}
```
```
+/requirementConstraintMembership +/ownedConstraint 1
{subsets owningFeatureMembership}0..1
```
```
{subsets requirementConstraintMembership}
0..1+/framedConstraintMembership
{redefines ownedConstraint}
```
```
+/ownedConcern 1
```
```
{subsets referencingConstraintMembership}
0..*+/referencingConcernMembership
{redefines referencedConstraint}
```
```
+/referencedConcern 1
```
**Figure 39. Requirement Constraint Membership**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 329**


```
SubjectMembership ActorMembership StakeholderMembership
```
```
ParameterMembership
```
```
Usage PartUsage
```
```
+/owningStakeholderMembership{subsets
owningParameterMembership}
```
```
0..1
```
```
+/ownedStakeholderParameter
{redefines ownedMemberParameter}^1
```
```
{redefines ownedMemberParameter}
+/ownedActorParameter 1
```
```
+/owningSubjectMembership{subsets owningParameterMembership}0..1 +/owningActorMembership{subsets owningParameterMembership}0..1
```
```
{redefines ownedMemberParameter}
+/ownedSubjectParameter 1
```
**Figure 40. Requirement Parameter Memberships
8.3.20.2ActorMembership
Description**
AnActorMembershipis aParameterMembershipthat identifies aPartUsageas an _actor_ parameter, which
specifies a role played by an external entity in interaction with theowningTypeof theActorMembership.
**General Classes**
ParameterMembership
**Attributes**
/ownedActorParameter : PartUsage {redefines ownedMemberParameter}
ThePartUsagespecifying the actor.
**Operations**
None.
**Constraints**
validateActorMembershipOwningType
TheowningTypeof anActorMembershipmust be aRequirementDefinition,RequirementUsage,
CaseDefinition, orCaseUsage.
owningType.oclIsKindOf(RequirementUsage) orowningType.oclIsKindOf(RequirementDefinition) or
owningType.oclIsKindOf(CaseDefinition) orowningType.oclIsKindOf(CaseUsage)

**8.3.20.3ConcernDefinition
Description**

**330 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


AConcernDefinitionis aRequirementDefinitionthat one or more stakeholders may be interested in having
addressed. These stakeholders are identified by theownedStakeholdersof theConcernDefinition.
**General Classes**
RequirementDefinition
**Attributes**
None.
**Operations**
None.
**Constraints**
checkConcernDefinitionSpecialization
AConcernDefinitionmust directly or indirectly specialize the baseConcernDefinition
_Requirements::ConcernCheck_ from the Systems Model Library.
specializesFromLibrary('Requirements::ConcernCheck')
**8.3.20.4ConcernUsage
Description**
AConcernUsageis aUsageof aConcernDefinition.
TheownedStakeholderfeatures of the ConcernUsage shall all subset the
_ConcernCheck::concernedStakeholders_ feature. If the ConcernUsage is anownedFeatureof a
StakeholderDefinition or StakeholderUsage, then the ConcernUsage shall have anownedStakeholderfeature that
is bound to the _self_ feature of its owner.
**General Classes**
RequirementUsage
**Attributes**
/concernDefinition : ConcernDefinition [0..1] {redefines requirementDefinition}
The ConcernDefinition that is the single type of this ConcernUsage.
**Operations**
None.
**Constraints**
checkConcernUsageFramedConcernSpecialization
If aConcernUsageis owned via aFramedConcernMembership, then it must directly or indirectly specialize the
ConcernUsage _Requirements::RequirementCheck::concerns_ from the Systems Model Library.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 331**


owningFeatureMembership <> null andowningFeatureMembership.oclIsKindOf(FramedConcernMembership) implies
specializesFromLibrary('Requirements::RequirementCheck::concerns')
checkConcernUsageSpecialization
AConcernUsagemust directly or indirectly specialize the baseConcernUsage
_Requirements::concernChecks_ from the Systems Model Library.
specializesFromLibrary('Requirements::concernChecks')
**8.3.20.5FramedConcernMembership
Description**
AFramedConcernMembershipis aRequirementConstraintMembershipfor a framedConcernUsageof a
RequirementDefinitionorRequirementUsage.
**General Classes**
RequirementConstraintMembership
**Attributes**
kind : RequirementConstraintKind {redefines kind}
Thekindof anFramedConcernMembershipmust berequirement.
/ownedConcern : ConcernUsage {redefines ownedConstraint}
TheConcernUsagethat is theownedConstraintof thisFramedConcernMembership.
/referencedConcern : ConcernUsage {redefines referencedConstraint}
TheConcernUsagethat is referenced through thisFramedConcernMembership. It is the
referencedConstraintof theFramedConcernMembershipconsidered as a
RequirementConstraintMembership, which must be aConcernUsage.
**Operations**
None.
**Constraints**
validateFramedConcernUsageConstraintKind
AFramedConcernMembershipmust havekind = requirement.
kind = RequirementConstraintKind::requirement
**8.3.20.6RequirementConstraintKind
Description**

**332 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ARequirementConstraintKindindicates whether aConstraintUsageis an assumption or a requirement in a
RequirementDefinitionorRequirementUsage.
**General Classes**
None.
**Literal Values**
assumption
Indicates that a memberConstraintUsageof aRequirementDefinitionorRequirementUsagerepresents an
assumption.
requirement
Indicates that a memberConstraintUsageof aRequirementDefinitionorRequirementUsagerepresents an
requirement.
**8.3.20.7RequirementConstraintMembership
Description**
ARequirementConstraintMembershipis aFeatureMembershipfor an assumed or required
ConstraintUsageof aRequirementDefinitionorRequirementUsage.
**General Classes**
FeatureMembership
**Attributes**
kind : RequirementConstraintKind
Whether theRequirementConstraintMembershipis for an assumed or requiredConstraintUsage.
/ownedConstraint : ConstraintUsage {redefines ownedMemberFeature}
TheConstraintUsagethat is theownedMemberFeatureof thisRequirementConstraintMembership.
/referencedConstraint : ConstraintUsage
TheConstraintUsagethat is referenced through thisRequirementConstraintMembership. It is the
referencedFeatureof theownedReferenceSubsettingof theownedConstraint, if there is one, and,
otherwise, theownedConstraintitself.
**Operations**
None.
**Constraints**
deriveRequirementConstraintMembershipReferencedConstraint

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 333**


ThereferencedConstraintof aRequirementConstraintMembershipis thereferencedFeatureof the
ownedReferenceSubsettingof theownedConstraint, if there is one, and, otherwise, theownedConstraint
itself.
referencedConstraint =let reference : ReferenceSubsetting =

if reference = null then ownedConstraintownedConstraint.ownedReferenceSubsetting in
else if not reference.referencedFeature.oclIsKindOf(ConstraintUsage) then nullelse reference.referencedFeature.oclAsType(ConstraintUsage)
endif endif
validateRequirementConstraintMembershipIsComposite
TheownedConstraintof aRequirementConstraintMembershipmust be composite.
ownedConstraint.isComposite
validateRequirementConstraintMembershipOwningType
TheowningTypeof aRequirementConstraintMembershipmust be aRequirementDefinitionor a
RequirementUsage.
owningType.oclIsKindOf(RequirementDefinition) orowningType.oclIsKindOf(RequirementUsage)

**8.3.20.8RequirementDefinition
Description**
ARequirementDefinitionis aConstraintDefinitionthat defines a requirement used in the context of a
specification as a constraint that a valid solution must satisfy. The specification is relative to a specified subject,
possibly in collaboration with one or more external actors.
**General Classes**
ConstraintDefinition
**Attributes**
/actorParameter : PartUsage [0..*] {subsets ownedPart, parameter, ordered}
Theparametersof thisRequirementDefinitionthat are owned viaActorMemberships.
/assumedConstraint : ConstraintUsage [0..*] {subsets ownedFeature, ordered}
The ownedConstraintUsagesthat represent assumptions of thisRequirementDefinition, which are the
ownedConstraintsof theRequirementConstraintMembershipsof theRequirementDefinitionwith
kind = assumption.
/framedConcern : ConcernUsage [0..*] {subsets requiredConstraint, ordered}
TheConcernUsagesframed by thisRequirementDefinition, which are theownedConcernsof all
FramedConcernMembershipsof theRequirementDefinition.
reqId : String [0..1] {redefines declaredShortName}

**334 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


An optional modeler-specified identifier for thisRequirementDefinition(used, e.g., to link it to an original
requirement text in some source document), which is thedeclaredShortNamefor the
RequirementDefinition.
/requiredConstraint : ConstraintUsage [0..*] {subsets ownedFeature, ordered}
The ownedConstraintUsagesthat represent requirements of thisRequirementDefinition, derived as the
ownedConstraintsof theRequirementConstraintMembershipsof theRequirementDefinitionwith
kind=requirement.
/stakeholderParameter : PartUsage [0..*] {subsets ownedPart, parameter, ordered}
Theparametersof thisRequirementDefinitionthat are owned viaStakeholderMemberships.
/subjectParameter : Usage {subsets parameter, ownedUsage}
Theparameterof thisRequirementDefinitionthat is owned via aSubjectMembership.
/text : String [0..*]
An optional textual statement of the requirement represented by thisRequirementDefinition, derived from the
bodiesof thedocumentationof theRequirementDefinition.
**Operations**
None.
**Constraints**
checkRequirementDefinitionSpecialization
ARequirementDefinitionmust directly or indirectly specialize the baseRequirementDefinition
_Requirements::RequirementCheck_ from the Systems Model Library.
specializesFromLibrary('Requirements::RequirementCheck')
deriveRequirementDefinitionActorParameter
TheactorParametersof aRequirementDefinitionare theownedActorParametersof the
ActorMembershipsof theRequirementDefinition.
actorParameter = featureMembership->selectByKind(ActorMembership).
ownedActorParameter
deriveRequirementDefinitionAssumedConstraint
TheassumedConstraintsof aRequirementDefinitionare theownedConstraintsof the
RequirementConstraintMembershipsof theRequirementDefinitionwithkind = assumption.
assumedConstraint = ownedFeatureMembership->selectByKind(RequirementConstraintMembership)->
select(kind = RequirementConstraintKind::assumption).ownedConstraint

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 335**


deriveRequirementDefinitionFramedConcern
TheframedConcernsof aRequirementDefinitionare theownedConcernsof the
FramedConcernMembershipsof theRequirementDefinition.
framedConcern = featureMembership->selectByKind(FramedConcernMembership).
ownedConcern
deriveRequirementDefinitionRequiredConstraint
TherequiredConstraintsof aRequirementDefinitionare theownedConstraintsof the
RequirementConstraintMembershipsof theRequirementDefinitionwithkind = requirement.
requiredConstraint = ownedFeatureMembership->selectByKind(RequirementConstraintMembership)->
select(kind = RequirementConstraintKind::requirement).ownedConstraint

deriveRequirementDefinitionStakeholderParameter
ThestakeHolderParametersof aRequirementDefinitionare theownedStakeholderParametersof the
StakeholderMembershipsof theRequirementDefinition.
stakeholderParameter = featureMembership->selectByKind(StakholderMembership).
ownedStakeholderParameter
deriveRequirementDefinitionSubjectParameter
ThesubjectParameterof aRequirementDefinitionis theownedSubjectParameterof its
SubjectMembership(if any).
subjectParameter =let subjects : OrderedSet(SubjectMembership) =

```
if subjects->isEmpty() then nullfeatureMembership->selectByKind(SubjectMembership) in
else subjects->first().ownedSubjectParameterendif
```
deriveRequirementDefinitionText
Thetextsof aRequirementDefinitionare thebodiesof thedocumentationof the
RequirementDefinition.
text = documentation.body
validateRequirementDefinitionOnlyOneSubject
ARequirementDefinitionmust have at most onefeatureMembershipthat is aSubjectMembership.
featureMembership->selectByKind(SubjectMembership)->
size() <= 1
validateRequirementDefinitionSubjectParameterPosition

**336 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ThesubjectParameterof aRequirementDefinitionmust be its firstinput.
input->notEmpty() and input->first() = subjectParameter
**8.3.20.9RequirementUsage
Description**
ARequirementUsageis aUsageof aRequirementDefinition.
**General Classes**
ConstraintUsage
**Attributes**
/actorParameter : PartUsage [0..*] {subsets nestedPart, parameter, ordered}
Theparametersof thisRequirementUsagethat are owned viaActorMemberships.
/assumedConstraint : ConstraintUsage [0..*] {subsets ownedFeature, ordered}
The ownedConstraintUsagesthat represent assumptions of thisRequirementUsage, derived as the
ownedConstraintsof theRequirementConstraintMembershipsof theRequirementUsagewithkind=
assumption.
/framedConcern : ConcernUsage [0..*] {subsets requiredConstraint, ordered}
TheConcernUsagesframed by thisRequirementUsage, which are theownedConcernsof all
FramedConcernMembershipsof theRequirementUsage.
reqId : String [0..1] {redefines declaredShortName}
An optional modeler-specified identifier for thisRequirementUsage(used, e.g., to link it to an original
requirement text in some source document), which is thedeclaredShortNamefor theRequirementUsage.
/requiredConstraint : ConstraintUsage [0..*] {subsets ownedFeature, ordered}
The ownedConstraintUsagesthat represent requirements of thisRequirementUsage, which are the
ownedConstraintsof theRequirementConstraintMembershipsof theRequirementUsagewithkind=
requirement.
/requirementDefinition : RequirementDefinition [0..1] {redefines constraintDefinition}
TheRequirementDefinitionthat is the singledefinitionof thisRequirementUsage.
/stakeholderParameter : PartUsage [0..*] {subsets nestedPart, parameter, ordered}
Theparametersof thisRequirementUsagethat are owned viaStakeholderMemberships.
/subjectParameter : Usage {subsets parameter, nestedUsage}
Theparameterof thisRequirementUsagethat is owned via aSubjectMembership.
/text : String [0..*]

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 337**


An optional textual statement of the requirement represented by thisRequirementUsage, derived from thebodies
of the documentationof the RequirementUsage.
**Operations**
None.
**Constraints**
checkRequirementUsageObjectiveRedefinition
ARequirementUsagewhoseowningFeatureMembershipis aObjectiveMembershipmust redefine the
objectiveRequirementof eachCaseDefinitionorCaseUsagethat is specialized by theowningTypeof the
RequirementUsage.
owningfeatureMembership <> null andowningfeatureMembership.oclIsKindOf(ObjectiveMembership) implies
owningType.ownedSpecialization.general->forAll(gen |(gen.oclIsKindOf(CaseDefinition) implies
(gen.oclIsKindOf(CaseUsage) impliesredefines(gen.oclAsType(CaseDefinition).objectiveRequirement)) and
redefines(gen.oclAsType(CaseUsage).objectiveRequirement))
checkRequirementUsageRequirementVerificationSpecialization
ARequirementUsagewhoseowningFeatureMembershipis aRequirementVerificationMembership
must directly or indirectly specialize theRequirementUsage
_VerificationCases::VerificationCase::obj::requirementVerifications_.
owningFeatureMembership <> null andowningFeatureMembership.oclIsKindOf(RequirementVerificationMembership) implies
specializesFromLibrary('VerificationCases::VerificationCase::obj::requirementVerifications')
checkRequirementUsageSpecialization
ARequirementUsagemust directly or indirectly specialize the baseRequirementUsage
_Requirements::requirementChecks_ from the Systems Model Library.
specializesFromLibrary('Requirements::requirementChecks')
checkRequirementUsageSubrequirementSpecialization
A compositeRequirementUsagewhoseowningTypeis aRequirementDefinitionor
,code>RequirementUsage must directly or indirectly specialize theRequirementUsage
_Requirements::RequirementCheck::subrequirements_ from the Systems Model Library.
isComposite and owningType <> null and(owningType.oclIsKindOf(RequirementDefinition) or

specializesFromLibrary('Requirements::RequirementCheck::subrequirements')owningType.oclIsKindOf(RequirementUsage)) implies
deriveRequirementUsageActorParameter
TheactorParametersof aRequirementUsageare theownedActorParametersof theActorMemberships
of theRequirementUsage.

**338 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


actorParameter = featureMembership->selectByKind(ActorMembership).
ownedActorParameter
deriveRequirementUsageAssumedConstraint
TheassumedConstraintsof aRequirementUsageare theownedConstraintsof the
RequirementConstraintMembershipsof theRequirementDefinitionwithkind = assumption.
assumedConstraint = ownedFeatureMembership->selectByKind(RequirementConstraintMembership)->
select(kind = RequirementConstraintKind::assumption).ownedConstraint

deriveRequirementUsageFramedConcern
TheframedConcernsof aRequirementUsageare theownedConcernsof theFramedConcernMemberships
of theRequirementUsage.
framedConcern = featureMembership->selectByKind(FramedConcernMembership).
ownedConcern
deriveRequirementUsageRequiredConstraint
TherequiredConstraintsof aRequirementUsageare theownedConstraintsof the
RequirementConstraintMembershipsof theRequirementUsagewithkind = requirement.
requiredConstraint = ownedFeatureMembership->selectByKind(RequirementConstraintMembership)->
select(kind = RequirementConstraintKind::requirement).ownedConstraint

deriveRequirementUsageStakeholderParameter
ThestakeHolderParametersof aRequirementUsageare theownedStakeholderParametersof the
StakeholderMembershipsof theRequirementUsage.
stakeholderParameter = featureMembership->selectByKind(AStakholderMembership).
ownedStakeholderParameter
deriveRequirementUsageSubjectParameter
ThesubjectParameterof aRequirementUsageis theownedSubjectParameterof its
SubjectMembership(if any).
subjectParameter =let subjects : OrderedSet(SubjectMembership) =

```
if subjects->isEmpty() then nullfeatureMembership->selectByKind(SubjectMembership) in
else subjects->first().ownedSubjectParameterendif
```
deriveRequirementUsageText
Thetextsof aRequirementUsageare thebodiesof thedocumentationof theRequirementUsage.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 339**


text = documentation.body
validateRequirementUsageOnlyOneSubject
ARequirementDefinitionmust have at most onefeatureMembershipthat is aSubjectMembership.
featureMembership->selectByKind(SubjectMembership)->
size() <= 1
validateRequirementUsageSubjectParameterPosition
ThesubjectParameterof aRequirementUsagemust be its firstinput.
input->notEmpty() and input->first() = subjectParameter
**8.3.20.10SatisfyRequirementUsage
Description**
ASatisfyRequirementUsageis anAssertConstraintUsagethat asserts, by default, that a satisfied
RequirementUsageis true for a specificsatisfyingFeature, or, ifisNegated = true, that the
RequirementUsageis false. The satisfiedRequirementUsageis related to theSatisfyRequirementUsageby
aReferenceSubsettingRelationship.
**General Classes**
AssertConstraintUsage
RequirementUsage
**Attributes**
/satisfiedRequirement : RequirementUsage {redefines assertedConstraint}
TheRequirementUsagethat is satisfied by thesatisfyingSubjectof thisSatisfyRequirementUsage. It is
theassertedConstraintof theSatisfyRequirementUsageconsidered as anAssertConstraintUsage,
which must be aRequirementUsage.
/satisfyingFeature : Feature
TheFeaturethat represents the actual subject that is asserted to satisfy thesatisfiedRequirement. The
satisfyingFeatureis bound to thesubjectParameterof theSatisfyRequirementUsage.
**Operations**
None.
**Constraints**
checkSatisfyRequirementUsageBindingConnector
ASatisfyRequirementUsagemust have exactly oneownedMemberthat is aBindingConnectorbetween its
subjectParameterand someFeatureother than thesubjectParameter.

**340 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ownedMember->selectByKind(BindingConnector)->select(b |
b.relatedElement->includes(subjectParameter) andb.relatedElement->exists(r | r <> subjectParameter))->
size() = 1
deriveSatisfyRequirementUsageSatisfyingFeature
ThesatisfyingFeatureof aSatisfyRequirementUsageis theFeatureto which thesubjectParameter
is bound.
satisfyingFeature =let bindings: BindingConnector = ownedMember->
selectByKind(BindingConnector)->select(b | b.relatedElement->includes(subjectParameter)) in
if bindings->isEmpty() orbindings->first().relatedElement->exits(r | r <> subjectParameter)
then nullelse bindings->first().relatedElement->any(r | r <> subjectParameter)
endif
**8.3.20.11SubjectMembership
Description**
ASubjectMembershipis aParameterMembershipthat indicates that itsownedSubjectParameteris the
subject of itsowningType. TheowningTypeof aSubjectMembershipmust be aRequirementDefinition,
RequirementUsage,CaseDefinition, orCaseUsage.
**General Classes**
ParameterMembership
**Attributes**
/ownedSubjectParameter : Usage {redefines ownedMemberParameter}
TheUsageownedMemberParameterof thisSubjectMembership.
**Operations**
None.
**Constraints**
validateSubjectMembershipOwningType
TheowningTypeof aSubjectMembershipmust be aRequirementDefinition,RequirementUsage,
CaseDefinition, orCaseUsage.
owningType.oclIsType(RequirementDefinition) orowningType.oclIsType(RequiremenCaseRequirementDefinition) or
owningType.oclIsType(CaseDefinition) orowningType.oclIsType(CaseUsage)

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 341**


**8.3.20.12StakeholderMembership
Description**
AStakeholderMembershipis aParameterMembershipthat identifies aPartUsageas a
stakeholderParameterof aRequirementDefinitionorRequirementUsage, which specifies a role played
by an entity with concerns framed by theowningType.
**General Classes**
ParameterMembership
**Attributes**
/ownedStakeholderParameter : PartUsage {redefines ownedMemberParameter}
ThePartUsagespecifying the stakeholder.
**Operations**
None.
**Constraints**
validateStakeholderMembershipOwningType
TheowningTypeof aStakeholderMembershipmust be aRequirementDefinitionorRequirementUsage.
owningType.oclIsKindOf(RequirementUsage) orowningType.oclIsKindOf(RequirementDefinition)

**8.3.21Cases Abstract Syntax**

**342 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.3.21.1Overview**

```
CaseDefinition CaseUsage
```
```
OccurrenceDefinition OccurrenceUsage
```
```
CalculationUsage
```
```
ActionUsage
```
```
Definition
```
```
CalculationDefinition
```
```
RequirementUsage
```
```
ActionDefinition
```
```
Usage
```
```
PartUsage
```
```
Usage
```
```
+/objectiveOwningCaseDefinition
{subsets owningType}0..1
```
```
{subsets ownedRequirement, ordered}
```
```
+/objectiveRequirement0..1
```
```
{subsets requirementOwningUsage}
0..1+/objectiveOwningCase
```
```
{subsets nestedRequirement, ordered}
0..1+/objectiveRequirement
```
```
{subsets ownedCalculation, ordered}
```
```
+/ownedCase0..*
```
```
{subsets calculationOwningDefinition}
0..1+/caseOwningDefinition
```
```
{redefines calculationDefinition}
0..1+/caseDefinition
{subsets definedCalculation}
```
```
+/definedCase0..* {subsets nestedCalculation, ordered}
```
```
+/nestedCase0..*
```
```
{subsets calculationOwningUsage}
0..1+/caseOwningUsage
```
```
{subsets parameteredBehavior, subsets partOwningDefinition}+actorOwningCaseDefinition 0..1
```
```
{subsets ownedPart, subsets parameter,
ordered}
```
```
+/actorParameter0..*
```
```
0..1{subsets parameteredStep, subsets partOwningUsage}+/actorOwningCase
```
```
{subsets nestedPart, subsets parameter,
ordered}
```
```
+/actorParameter0..*
```
```
{subsets owningUsage, subsets parameteredStep}+subjectOwningCase 0..1
```
```
{subsets nestedUsage, subsets parameter}
```
```
+/subjectParameter 1
```
```
{subsets owningDefinition, +/subjectOwningCaseDefinition
subsets parameteredBehavior}
```
```
0..1
```
```
{subsets ownedUsage, subsets parameter}
```
```
+/subjectParameter 1
```
**Figure 41. Case Definition and Usage**

```
FeatureMembership
```
```
ObjectiveMembership
```
```
RequirementUsage
```
```
{subsets owningParameterMembership}
```
```
+/owningObjectiveMembership0..1
```
```
{redefines ownedMemberFeature}
+/ownedObjectiveRequirement 1
```
**Figure 42. Case Membership**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 343**


**8.3.21.2CaseDefinition
Description**
ACaseDefinitionis aCalculationDefinitionfor a process, often involving collecting evidence or data,
relative to a subject, possibly involving the collaboration of one or more other actors, producing a result that meets
an objective.
**General Classes**
CalculationDefinition
**Attributes**
/actorParameter : PartUsage [0..*] {subsets parameter, ownedPart, ordered}
Theparametersof thisCaseDefinitionthat are owned viaActorMemberships, which must subset, directly
or indirectly, thePartUsage _actors_ of the baseCaseDefinition _Case_ from the Systems Model Library.
/objectiveRequirement : RequirementUsage [0..1] {subsets ownedRequirement, ordered}
TheobjectiveRequirementof thisCaseDefinition, that is owned via anObjectiveMembership, and will
redefine, directly or indirectly, theobjectiveRequirementUsage of the baseCaseDefinition _Case_
from the Systems Model Library.
/subjectParameter : Usage {subsets parameter, ownedUsage}
Theparameterof thisCaseDefinitionthat is owned via a SubjectMembership, which must redefine, directly or
indirectly, thesubjectparameter of the baseCaseDefinition _Case_ from the Systems Model Library.
**Operations**
None.
**Constraints**
checkCaseDefinitionSpecialization
ACaseDefinitionmust directly or indirectly specialize the baseCaseDefinition _Cases::Case>_ from the
Systems Model Library.
specializesFromLibrary('Cases::Case')
deriveCaseDefinitionActorParameter
TheactorParametersof aCaseDefinitionare theownedActorParametersof theActorMembershipsof
theCaseDefinition.
actorParameter = featureMembership->selectByKind(ActorMembership).
ownedActorParameter
deriveCaseDefinitionObjectiveRequirement

**344 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


TheobjectiveRequirementof aCaseDefinitionis theownedObjectiveRequirementof its
ObjectiveMembership, if any.
objectiveRequirement =let objectives: OrderedSet(RequirementUsage) =
featureMembership->selectByKind(ObjectiveMembership).
if objectives->isEmpty() then nullownedRequirement in
else objectives->first().ownedObjectiveRequirementendif

deriveCaseDefinitionSubjectParameter
ThesubjectParameterof aCaseDefinitionis theownedSubjectParameterof itsSubjectMembership
(if any).
subjectParameter =let subjectMems : OrderedSet(SubjectMembership) =

```
if subjectMems->isEmpty() then nullfeatureMembership->selectByKind(SubjectMembership) in
else subjectMems->first().ownedSubjectParameterendif
```
validateCaseDefinitionOnlyOneObjective
ACaseDefinitionmust have at most onefeatureMembershipthat is aObjectiveMembership.
featureMembership->selectByKind(ObjectiveMembership)->
size() <= 1
validateCaseDefinitionOnlyOneSubject
ACaseDefinitionmust have at most onefeatureMembershipthat is aSubjectMembership.
featureMembership->selectByKind(SubjectMembership)->size() <= 1
validateCaseDefinitionSubjectParameterPosition
ThesubjectParameterof aCaaseDefinitionmust be its firstinput.
input->notEmpty() and input->first() = subjectParameter
**8.3.21.3CaseUsage
Description**
ACaseUsageis aUsageof aCaseDefinition.
**General Classes**
CalculationUsage
**Attributes**
/actorParameter : PartUsage [0..*] {subsets nestedPart, parameter, ordered}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 345**


Theparametersof thisCaseUsagethat are owned viaActorMemberships, which must subset, directly or
indirectly, thePartUsage _actors_ of the baseCaseUsage _Case_ from the Systems Model Library.
/caseDefinition : CaseDefinition [0..1] {redefines calculationDefinition}
The CaseDefinition that is the type of this CaseUsage.
/objectiveRequirement : RequirementUsage [0..1] {subsets nestedRequirement, ordered}
TheownedFeatureof this CaseUsage that is owned via an ObjectiveMembership, and that must redefine, directly
or indirectly, theobjectiveRequirementUsage of the base CaseDefinition Case from the Systems model library.
/subjectParameter : Usage {subsets parameter, nestedUsage}
Theparameterof thisCaseUsagethat is owned via a SubjectMembership, which must redefine, directly or
indirectly, thesubjectparameter of the baseCaseUsage _Case_ from the Systems Model Library.
**Operations**
None.
**Constraints**
checkCaseUsageSpecialization
ACaseUsagemust directly or indirectly specialize the baseCaseUsage _Cases::cases_ from the Systems Model
Library.
specializeFromLibrary('Cases::cases')
checkCaseUsageSubcaseSpecialization
A compositeCaseUsagewhoseowningTypeis aCaseDefinitionorCaseUsagemust directly or indirectly
specialize theCaseUsage _Cases::Case::subcases_.
isComposite and owningType <> null and(owningType.oclIsKindOf(CaseDefinition) or

specializesFromLibrary('Cases::Case::subcases')owningType.oclIsKindOf(CaseUsage)) implies
deriveCaseUsageActorParameter
TheactorParametersof aCaseUsageare theownedActorParametersof theActorMembershipsof the
CaseUsage.
actorParameter = featureMembership->selectByKind(ActorMembership).
ownedActorParameter
deriveCaseUsageObjectiveRequirement
TheobjectiveRequirementof aCaseUsageis theRequirementUsageit owns via anObjectiveMembership,
if any.
objectiveRequirement =let objectives: OrderedSet(RequirementUsage) =

**346 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
featureMembership->selectByKind(ObjectiveMembership).
if objectives->isEmpty() then nullownedRequirement in
else objectives->first().ownedObjectiveRequirementendif
```
deriveCaseUsageSubjectParameter
ThesubjectParameterof aCaseUsageis theownedSubjectParameterof itsSubjectMembership(if any).
subjectParameter =let subjects : OrderedSet(SubjectMembership) =

```
if subjects->isEmpty() then nullfeatureMembership->selectByKind(SubjectMembership) in
else subjects->first().ownedSubjectParameterendif
```
validateCaseUsageOnlyOneObjective
ACaseUsagemust have at most onefeatureMembershipthat is aObjectiveMembership.
featureMembership->selectByKind(ObjectiveMembership)->
size() <= 1
validateCaseUsageOnlyOneSubject
ACaseUsagemust have at most onefeatureMembershipthat is aSubjectMembership.
featureMembership->selectByKind(SubjectMembership)->
size() <= 1
validateCaseUsageSubjectParameterPosition
ThesubjectParameterof aCaseUsagemust be its firstinput.
input->notEmpty() and input->first() = subjectParameter
**8.3.21.4ObjectiveMembership
Description**
AnObjectiveMembershipis aFeatureMembershipthat indicates that itsownedObjectiveRequirementis
the objectiveRequirementUsage for itsowningType, which must be aCaseDefinitionor
CaseUsage.
**General Classes**
FeatureMembership
**Attributes**
/ownedObjectiveRequirement : RequirementUsage {redefines ownedMemberFeature}
The RequirementUsage that is theownedMemberFeatureof this RequirementUsage.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 347**


**Operations**
None.
**Constraints**
validateObjectiveMembershipIsComposite
TheownedObjectiveRequirementof anObjectiveMembershipmust be composite.
ownedObjectiveRequirement.isComposite
validateObjectiveMembershipOwningType
TheowningTypeof anObjectiveMembershipmust be aCaseDefinitionorCaseUsage.
owningType.oclIsType(CaseDefinition) orowningType.oclIsType(CaseUsage)

**8.3.22Analysis Cases Abstract Syntax
8.3.22.1Overview**

```
AnalysisCaseDefinition
```
```
OccurrenceDefinition
```
```
Definition
```
```
ActionDefinition
CalculationDefinition
CaseDefinition
AnalysisCaseUsage
```
```
CaseUsage
```
```
OccurrenceUsage
```
```
ActionUsage
CalculationUsage
```
```
Usage
```
```
Expression
```
```
{subsets nestedCase, ordered}
```
```
+/nestedAnalysisCase0..*
```
```
+/analysisCaseOwningUsage
{subsets analysisCaseOwningUsage}0..1
```
```
{redefines caseDefinition}
```
```
+/analysisCaseDefinition0..1
{redefines definedCase, ordered}
```
```
+/definedAnalysisCase0..*
```
```
{subsets ownedCase, ordered}
```
```
+/ownedAnalysisCase0..*
```
```
+/analysisCaseOwningDefinition
{subsets caseOwningDefinition}0..1
```
```
+/featuringAnalysisCaseDefinition
{subsets featuringActionDefinition}0..*
```
```
{subsets action, ordered}
```
```
+/analysisAction0..*
```
```
+/analysisCase{subsets owningType}0..1
```
```
{subsets ownedFeature}
0..1+/resultExpression
```
```
+/analysisCaseDefintion{subsets computedFunction, subsets owningType}0..1
```
```
{subsets expression, subsets ownedFeature}
```
```
+/resultExpression0..1
```
```
{subsets typeWithFeature}
```
```
+/featuringAnalysisCase0..*
```
```
+/analysisAction
{subsets usage, ordered}0..*
```
**Figure 43. Analysis Case Definition and Usage**

**348 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.3.22.2AnalysisCaseDefinition
Description**
AnAnalysisCaseDefinitionis aCaseDefinitionfor the case of carrying out an analysis.
**General Classes**
CaseDefinition
**Attributes**
/analysisAction : ActionUsage [0..*] {subsets action, ordered}
The compositeactionsof theAnalysisCaseDefinitionthat are defined asAnalysisActions.
/resultExpression : Expression [0..1] {subsets expression, ownedFeature}
AnExpressionused to compute theresultof theAnalysisCaseDefinition, owned via a
ResultExpressionMembership.
**Operations**
None.
**Constraints**
checkAnalysisCaseDefinitionSpecialization
AnAnalysisCaseDefinitionmust directly or indirectly specialize the baseAnalysisCaseDefinition
_AnalysisCases::AnalysisCase_ from the Systems Model Library.
specializesFromLibrary('AnalysisCases::AnalysisCase')
deriveAnalysisCaseDefinitionAnalysisAction
TheanalysisActionsof aAnalysisCaseDefinitionare all itsactionsthat directly or indirectly specialize
_AnalysisCases::AnalysisAction_.
analysisAction = action->select(isComposite and
specializes('AnalysisCases::AnalysisAction'))
deriveAnalysisCaseDefinitionResultExpression
TheresultExpressionof aAnalysisCaseDefinitionis theownedResultExpressionof its
ResultExpressionMembership, if any.
resultExpression =let results : OrderedSet(ResultExpressionMembership) =
featureMembersip->selectByKind(ResultExpressionMembership) in
if results->isEmpty() then nullelse results->first().ownedResultExpression
endif

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 349**


**8.3.22.3AnalysisCaseUsage
Description**
AnAnalysisCaseUsageis aUsageof anAnalysisCaseDefinition.
**General Classes**
CaseUsage
**Attributes**
/analysisAction : ActionUsage [0..*] {subsets usage, ordered}
The compositeusagesof theAnalysisCaseUsagethat are defined asAnalysisActions.
/analysisCaseDefinition : AnalysisCaseDefinition [0..1] {redefines caseDefinition}
TheAnalysisCaseDefinitionthat is thedefinitionof thisAnalysisCaseUsage.
/resultExpression : Expression [0..1] {subsets ownedFeature}
AnExpressionused to compute theresultof theAnalysisCaseUsage, owned via a
ResultExpressionMembership.
**Operations**
None.
**Constraints**
checkAnalysisCaseUsageSpecialization
AnAnalysisCaseUsagemust directly or indirectly specialize the baseAnalysisCaseUsage
_AnalysisCases::analysisCases_ from the Systems Model Library.
specializesFromLibrary('AnalysisCases::analysisCases')
checkAnalysisCaseUsageSubAnalysisCaseSpecialization
A compositeAnalysisCaseUsagewhoseowningTypeis anAnalysisCaseDefinitionor
AnalysisCaseUsagemust specialize theAnalysisCaseUsage
_AnalysisCases::AnalysisCase::subAnalysisCasesfrom the Systems Model Library._
isComposite and owningType <> null and(owningType.oclIsKindOf(AnalysisCaseDefinition) or

specializesFromLibrary('AnalysisCases::AnalysisCase::subAnalysisCases')owningType.oclIsKindOf(AnalysisCaseUsage)) implies
deriveAnalysisCaseUsageAnalysisAction
TheanalysisActionsof aAnalysisCaseUsageare all itsactionsthat directly or indirectly specialize
_AnalysisCases::AnalysisAction_.

**350 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


analysisAction = usage->select(isComposite and
specializes('AnalysisCases::AnalysisAction'))
deriveAnalysisCaseUsageResultExpression
TheresultExpressionof aAnalysisCaseUsageis theownedResultExpressionof its
ResultExpressionMembership, if any.
resultExpression =let results : OrderedSet(ResultExpressionMembership) =
featureMembersip->selectByKind(ResultExpressionMembership) in
if results->isEmpty() then nullelse results->first().ownedResultExpression
endif

**8.3.23Verification Cases Abstract Syntax
8.3.23.1Overview**

```
VerificationCaseDefinition
```
```
OccurrenceDefinition
```
```
CaseDefinition
```
```
ActionDefinition
```
```
CalculationDefinition
```
```
Definition
OccurrenceUsage
```
```
CalculationUsage
```
```
CaseUsage
```
```
VerificationCaseUsage
```
```
Usage
```
```
ActionUsage
```
```
RequirementUsage
```
```
{subsets nestedCase, ordered}
```
```
+/nestedVerificationCase0..*
```
```
+/verificationCaseOwningUsage
{subsets caseOwningUsage}0..1
```
```
{subsets ownedCase, ordered}
```
```
+/ownedVerificationCase0..*
```
```
+/verificationCaseOwningDefinition
{subsets caseOwningDefinition}0..1
```
```
+/verificationCaseDefinition
{subsets caseDefinition}0..1
```
```
+/definedVerificationCase
{subsets definedCase}0..* 0..* +/verifyingCase
```
```
+/verifiedRequirement
{ordered}0..*
```
```
+verifyingCaseDefinition0..*
```
+/verifiedRequirement
{ordered}0..*
**Figure 44. Verification Case Definition and Usage**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 351**


```
+kind : RequirementConstraintKind = requirement{redefines kind}
```
```
RequirementVerificationMembership
```
```
RequirementConstraintMembership
```
```
RequirementUsage
{redefines referencedConstraint}
```
```
+/verifiedRequirement
1
```
```
{subsets referencingConstraintMembership}
```
```
+/requirementVerification
0..*
```
```
{subsets requirementConstraintMembership}
```
```
+/requirementVerificationMembership0..1
```
```
{redefines ownedConstraint}
+/ownedRequirement 1
```
**Figure 45. Verification Membership
8.3.23.2RequirementVerificationMembership
Description**
ARequirementVerificationMembershipis aRequirementConstraintMembershipused in the objective
of aVerificationCaseto identify aRequirementUsagethat is verified by theVerificationCase.
**General Classes**
RequirementConstraintMembership
**Attributes**
kind : RequirementConstraintKind {redefines kind}
Thekindof aRequirementVerificationMembershipmust berequirement.
/ownedRequirement : RequirementUsage {redefines ownedConstraint}
The ownedRequirementUsagethat acts as theownedConstraintfor this
RequirementVerificationMembership. This will either be theverifiedRequirement, or it will subset the
verifiedRequirement.
/verifiedRequirement : RequirementUsage {redefines referencedConstraint}
TheRequirementUsagethat is identified as being verified. It is thereferencedConstraintof the
RequirementVerificationMembershipconsidered as aRequirementConstraintMembership, which must
be aRequirementUsage.
**Operations**
None.
**Constraints**

**352 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


validateRequirementVerificationMembershipKind
ARequirementVerificationMembershipmust havekind = requirement.
kind = RequirementConstraintKind::requirement
validateRequirementVerificationMembershipOwningType
TheowningTypeof aRequirementVerificationMembershipmust aRequirementUsagethat is owned by
anObjectiveMembership.
owningType.oclIsKindOf(RequirementUsage) andowningType.owningFeatureMembership <> null and
owningType.owningFeatureMembership.oclIsKindOf(ObjectiveMembership)
**8.3.23.3VerificationCaseDefinition
Description**
AVerificationCaseDefinitionis aCaseDefinitionfor the purpose of verification of the subject of the
case against its requirements.
**General Classes**
CaseDefinition
**Attributes**
/verifiedRequirement : RequirementUsage [0..*] {ordered}
TheRequirementUsagesverified by thisVerificationCaseDefinition, which are the
verifiedRequirementsof allRequirementVerificationMembershipsof theobjectiveRequirement.
**Operations**
None.
**Constraints**
checkVerificationCaseSpecialization
AVerificationCaseDefinitionmust directly or indirectly specialize the base
VerificationCaseDefinition _VerificationCases::VerificationCase_ from the Systems Model
Library.
specializesFromLibrary('VerificationCases::VerificationCase')
deriveVerificationCaseDefinitionVerifiedRequirement
TheverifiedRequirementsof aVerificationCaseDefinitionare theverifiedRequirementsof its
RequirementVerificationMemberships.
verifiedRequirement =if objectiveRequirement = null then OrderedSet{}
elseobjectiveRequirement.featureMembership->

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 353**


selectByKind(RequirementVerificationMembership).verifiedRequirement->asOrderedSet()
endif
**8.3.23.4VerificationCaseUsage
Description**
AVerificationCaseUsageis a Usage of aVerificationCaseDefinition.
**General Classes**
CaseUsage
**Attributes**
/verificationCaseDefinition : VerificationCaseDefinition [0..1] {subsets caseDefinition}
TheVerificationCasethat is thedefinitionof thisVerificationCaseUsage.
/verifiedRequirement : RequirementUsage [0..*] {ordered}
TheRequirementUsagesverified by thisVerificationCaseUsage, which are theverifiedRequirements
of allRequirementVerificationMembershipsof theobjectiveRequirement.
**Operations**
None.
**Constraints**
checkVerificationCaseUsageSpecialization
AVerificationCaseUsagemust subset, directly or indirectly, the baseVerificationCaseUsage
_VerificationCases::verificationCases_ from the Systems Model Library.
specializesFromLibrary('VerificationCases::verificationCases')
checkVerificationCaseUsageSubVerificationCaseSpecialization
If it is composite and owned by aVerificationCaseDefinitionorVerificationCaseUsage, then it must
specializeVerificationCaseUsage
_VerificationCases::VerificationCase::subVerificationCases._
isComposite and owningType <> null and(owningType.oclIsKindOf(VerificationCaseDefinition) or
owningType.oclIsKindOf(VerificationCaseUsage))
deriveVerificationCaseUsageVerifiedRequirement
TheverifiedRequirementsof aVerificationCaseUsageare theverifiedRequirementsof its
RequirementVerificationMemberships.
verifiedRequirement =if objectiveRequirement = null then OrderedSet{}
else

**354 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
objectiveRequirement.featureMembership->selectByKind(RequirementVerificationMembership).
endif verifiedRequirement->asOrderedSet()
```
**8.3.24Use Cases Abstract Syntax
8.3.24.1Overview**

```
UseCaseDefinition UseCaseUsage
```
```
Definition
```
```
CalculationDefinition
```
```
CaseDefinition
```
```
OccurrenceDefinition
```
```
ActionDefinition
```
```
CaseUsage
```
```
Usage
```
```
ActionUsage
```
```
OccurrenceUsage
```
```
CalculationUsage
```
```
{subsets ownedCase, ordered}
```
```
+/ownedUseCase0..*
```
```
+/useCaseOwningDefinition
{subsets caseOwningDefinition}0..1
```
```
{redefines caseDefinition}
0..1+/useCaseDefinition
{subsets definedCase}
```
```
+/definedUseCase0..*
```
```
+/includingUseCaseDefinition
0..*
```
```
+/includedUseCase
{ordered}0..*
```
```
+/useCaseOwningUsage
{subsets caseOwningUsage}0..1
```
```
{subsets nestedCase, ordered}
0..*+/nestedUseCase
```
```
+/includingUseCase0..*
```
```
+/includedUseCase
{ordered}0..*
```
**Figure 46. Use Case Definition and Usage**

```
IncludeUseCaseUsage
```
```
PerformActionUsage UseCaseUsage
{redefines performedAction}
```
```
+/useCaseIncluded
1
```
```
{subsets performingAction}
```
```
+/useCaseInclusion
0..*
```
**Figure 47. Included Use Case
8.3.24.2IncludeUseCaseUsage
Description**
AnIncludeUseCaseUsageis aUseCaseUsagethat represents the inclusion of aUseCaseUsageby a
UseCaseDefinitionorUseCaseUsage. Unless it is theIncludeUseCaseUsageitself, theUseCaseUsageto

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 355**


be included is related to theincludedUseCaseby aReferenceSubsettingRelationship. An
IncludeUseCaseUsageis also a PerformActionUsage, with itsuseCaseIncludedas theperformedAction.
**General Classes**
PerformActionUsage
UseCaseUsage
**Attributes**
/useCaseIncluded : UseCaseUsage {redefines performedAction}
TheUseCaseUsageto be included by thisIncludeUseCaseUsage. It is theperformedActionof the
IncludeUseCaseUsageconsidered as aPerformActionUsage, which must be aUseCaseUsage.
**Operations**
None.
**Constraints**
checkIncludeUseCaseSpecialization
AIncludeUseCaseUsagewhoseowningTypeis aUseCaseDefinitionorUseCaseUsagemust directly or
indirectly specialize theUseCaseUsage _UseCases::UseCase::includedUseCases_ from the Systems Model
Library.
owningType <> null and(owningType.oclIsKindOf(UseCaseDefinition) or
owningType.oclIsKindOf(UseCaseUsage) impliesspecializesFromLibrary('UseCases::UseCase::includedUseCases')

**8.3.24.3UseCaseDefinition
Description**
AUseCaseDefinitionis aCaseDefinitionthat specifies a set of actions performed by its subject, in
interaction with one or more actors external to the subject. The objective is to yield an observable result that is of
value to one or more of the actors.
**General Classes**
CaseDefinition
**Attributes**
/includedUseCase : UseCaseUsage [0..*] {ordered}
TheUseCaseUsagesthat are included by thisUseCaseDefinition, which are theuseCaseIncludedsof the
IncludeUseCaseUsagesowned by thisUseCaseDefinition.
**Operations**
None.

**356 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
checkUseCaseDefinitionSpecialization
AUseCaseDefinitionmust directly or indirectly specializes the baseUseCaseDefinition
_UseCases::UseCase_ from the Systems Model Library.
specializesFromLibrary('UseCases::UseCase')
deriveUseCaseDefinitionIncludedUseCase
TheincludedUseCases of aUseCaseDefinitionare theuseCaseIncludeds of the
IncludeUseCaseUsagesowned by the UseCaseDefinition.
includedUseCase = ownedUseCase->selectByKind(IncludeUseCaseUsage).
useCaseIncluded
**8.3.24.4UseCaseUsage
Description**
AUseCaseUsageis aUsageof aUseCaseDefinition.
**General Classes**
CaseUsage
**Attributes**
/includedUseCase : UseCaseUsage [0..*] {ordered}
TheUseCaseUsagesthat are included by thisUseCaseUse, which are theuseCaseIncludedsof the
IncludeUseCaseUsagesowned by thisUseCaseUsage.
/useCaseDefinition : UseCaseDefinition [0..1] {redefines caseDefinition}
TheUseCaseDefinitionthat is thedefinitionof thisUseCaseUsage.
**Operations**
None.
**Constraints**
checkUseCaseUsageSpecialization
AUseCaseUsagemust directly or indirectly specializes the baseUseCaseUsage _UseCases::useCases_ from the
Systems Model Library.
specializesFromLibrary('UseCases::useCases')
checkUseCaseUsageSubUseCaseSpecialization

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 357**


A compositeUseCaseUsagewhoseowningTypeis aUseCaseDefinitionorUseCaseUsagemust specialize
theUseCaseUsage _UseCases::UseCase::subUseCases_ from the Systems Model Library.
isComposite and owningType <> null and(owningType.oclIsKindOf(UseCaseDefinition) or
owningType.oclIsKindOf(UseCaseUsage)) impliesspecializesFromLibrary('UseCases::UseCase::subUseCases')

deriveUseCaseUsageIncludedUseCase
TheincludedUseCases of aUseCaseUsageare theuseCaseIncludeds of the
IncludeUseCaseUsagesowned by the UseCaseUsage.
includedUseCase = ownedUseCase->selectByKind(IncludeUseCaseUsage).
useCaseIncluded
**8.3.25Views and Viewpoints Abstract Syntax
8.3.25.1Overview**

```
ViewDefinition +includeAsExposed( element : Element ) : Boolean ViewUsage
```
```
OccurrenceDefinition OccurrenceUsage
```
```
RenderingUsage
```
```
ViewpointUsage
```
```
Definition
```
```
ItemDefinition
PartDefinition
```
```
Expression
```
```
Element
```
```
ItemUsage
```
```
Usage
```
```
PartUsage
{subsets ownedPart, ordered}
```
```
+/ownedView0..*
```
```
{subsets partOwningDefinition}
```
```
+/viewOwningDefinition0..1
```
```
{redefines partDefinition}
```
```
+/viewDefinition0..1
{subsets definedPart}
```
```
+/definedView0..*
{subsets usage, ordered}
```
```
+/view0..*
{subsets featuringDefinition}
```
```
+/featuringView0..*
```
```
+/viewRendering0..1
```
```
+/renderingOwningViewDefinition{subsets owningDefinition}0..1 0..1{subsets owningUsage}+/renderingOwningView
```
```
+/viewRendering0..1
```
```
{subsets partOwningUsage}0..1+/viewOwningUsage
```
```
+/nestedView{subsets nestedPart, ordered}0..*
```
```
0..1+viewpointSatisfyingViewDefinition{subsets owningDefinition}
{subsets ownedRequirement, ordered}
```
```
+/satisfiedViewpoint0..*
```
```
{subsets ownedMember, ordered}
```
```
+/owningViewDefinition +/viewCondition0..*
{subsets owningType}0..1
```
```
{subsets namespace}
```
```
+/exposingView0..*
{subsets member, ordered}
```
```
+/exposedElement0..*
```
```
{subsets nestedRequirement, ordered}
```
```
+/satisfiedViewpoint0..*
```
```
+/viewpointSatisfyingView{subsets featuringUsage}0..1
```
```
{subsets ownedMember, ordered}
```
```
+/viewCondition0..* +/owningView
{subsets owningType}0..1
```
**Figure 48. View Definition and Usage**

**358 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
RequirementDefinition
```
```
OccurrenceDefinition
```
```
Definition
```
```
ConstraintDefinition
```
```
ViewpointDefinition
```
```
ViewpointUsage
```
```
RequirementUsage
```
```
OccurrenceUsage
```
```
Usage
```
```
ConstraintUsage
```
```
PartUsage
```
```
{redefines requirementDefinition}
0..1+/viewpointDefinition
{subsets definedRequirement}
```
```
{subsets ownedRequirement, ordered}+/definedViewpoint0..*
```
```
+/ownedViewpoint0..*
```
```
{subsets requirementOwningDefinition}
```
```
+/viewpointOwningDefinition0..1
```
```
{subsets nestedRequirement, ordered}
0..*+/nestedViewpoint
```
```
{subsets requirementOwningUsage}
```
```
+/viewpointOwningUsage0..1
```
```
+/viewpointForStakeholder0..1
```
```
+/viewpointStakeholder
{ordered}0..*
```
```
+/viewpointDefinitionForStakeholder0..1
```
+/viewpointStakeholder
{ordered}0..*
**Figure 49. Viewpoint Definition and Usage**

```
RenderingDefinition
```
```
OccurrenceDefinition
```
```
RenderingUsage
```
```
OccurrenceUsage
```
```
Definition
```
```
ItemDefinition
```
```
PartDefinition PartUsage
```
```
Usage
```
```
ItemUsage
```
```
{subsets ownedPart, ordered}
```
```
+/ownedRendering
0..*
```
```
{subsets partOwningDefinition}
```
```
+/redenderingOwningDefinition
0..1
```
```
{subsets nestedPart, ordered}
```
```
+/nestedRendering
0..*
```
```
{subsets partOwningUsage}
```
```
+/renderingOwningUsage
0..1
```
```
{redefines partDefinition}
```
```
+/renderingDefinition
0..1 {subsets definedPart}
```
```
+/definedRendering
0..*
```
```
{subsets usage, ordered}
```
```
+/rendering
0..*
```
```
+/featuringRenderingDefinition
{subsets featuringDefinition}
```
```
0..*
```
**Figure 50. Rendering Definition and Usage**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 359**


```
+isImportAll : Boolean = true{redefines isImportAll}
```
```
Expose
```
```
MembershipExpose
```
```
MembershipImport
```
```
NamespaceExpose
```
```
NamespaceImport
```
```
Import
```
```
Membership
```
```
0..*+/ownedImport +/importOwningNamespace 1 Namespace
+importedNamespace 1
```
```
+import
+import0..* 0..*
```
```
+importedMembership 1
```
**Figure 51. Expose Relationship**

```
ViewRenderingMembership
```
```
FeatureMembership
```
```
RenderingUsage
```
```
+/referencingRenderingMembership
0..*
```
```
+/referencedRendering
1
```
```
{redefines ownedMemberFeature}
+/ownedRendering 1
```
```
+/viewRenderingMembership0..1
```
**Figure 52. View Rendering Membership
8.3.25.2Expose
Description**
AnExposeis anImportofMembershipsinto aViewUsagethat provide theElementsto be included in a view.
Visibility is always ignored for anExpose(i.e.,isImportAll = true).
**General Classes**

**360 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Import
**Attributes**
isImportAll : Boolean {redefines isImportAll}
AnExposealways imports allElements, regardless of visibility (isImportAll = true).
**Operations**
None.
**Constraints**
validateExposeIsImportAll
AnExposealways imports allElements, regardless of visibility.
isImportAll
validateExposeOwningNamespace
TheimportOwningNamespaceof anExposemust be aViewUsage.
importOwningNamespace.oclIsType(ViewUsage)
**8.3.25.3MembershipExpose
Description**
AMembershipExposeis anExposethat exposes a specificimportedMembershipand, ifisRecursive =
true, additionalMembershipsrecursively.
**General Classes**
Expose
MembershipImport
**Attributes**
None.
**Operations**
None.
**Constraints**
None.
**8.3.25.4NamespaceExpose
Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 361**


ANamespaceExposeis anExposeRelationshipthat exposes theMembershipsof a specific
importedNamespaceand, ifisRecursive = true, additionalMembershipsrecursively.
**General Classes**
Expose
NamespaceImport
**Attributes**
None.
**Operations**
None.
**Constraints**
None.
**8.3.25.5RenderingDefinition
Description**
ARenderingDefinitionis aPartDefinitionthat defines a specific rendering of the content of a model view
(e.g., symbols, style, layout, etc.).
**General Classes**
PartDefinition
**Attributes**
/rendering : RenderingUsage [0..*] {subsets usage, ordered}
Theusagesof aRenderingDefinitionthat areRenderingUsages.
**Operations**
None.
**Constraints**
checkRenderingDefinitionSpecialization
ARenderingDefinitionmust directly or indirectly specialize the baseRenderingDefinition
_Views::Rendering_ from the Systems Model Library.
specializesFromLibrary('Views::Rendering')
deriveRenderingDefinitionRendering
Therenderingsof aRenderingDefinitionare all itsusagesthat areRenderingUsages.
rendering = usages->selectByKind(RenderingUsage)

**362 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.3.25.6RenderingUsage
Description**
ARenderingUsageis the usage of aRenderingDefinitionto specify the rendering of a specific model view to
produce a physical view artifact.
**General Classes**
PartUsage
**Attributes**
/renderingDefinition : RenderingDefinition [0..1] {redefines partDefinition}
TheRenderingDefinitionthat is thedefinitionof thisRenderingUsage.
**Operations**
None.
**Constraints**
checkRenderingUsageRedefinition
ARenderingUsagewhoseowningFeatureMembershipis aViewRenderingMembershipmust redefine the
RenderingUsage _Views::View::viewRendering_.
owningFeatureMembership <> null andowningFeatureMembership.oclIsKindOf(ViewRenderingMembership) implies
redefinesFromLibrary('Views::View::viewRendering')
checkRenderingUsageSpecialization
ARenderingUsagemust directly or indirectly specialize the baseRenderingUsage _Views::renderings_ from
the Systems Model Library.
specializeFromLibrary('Views::renderings')
checkRenderingUsageSubrenderingSpecialization
ARenderingUsagewhoseowningTypeis aRenderingDefinitionorRenderingUsagemust directly or
indirectly specialize theRenderingUsage _Views::Rendering::subrenderings_ from the Systems Model
Library.
owningType <> null and(owningType.oclIsKindOf(RenderingDefinition) or
owningType.oclIsKindOf(RenderingUsage)) impliesspecializesFromLibrary('Views::Rendering::subrenderings')

**8.3.25.7ViewDefinition
Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 363**


AViewDefinitionis aPartDefinitionthat specifies how a view artifact is constructed to satisfy a
viewpoint. It specifies aviewConditionsto define the model content to be presented and aviewRenderingto
define how the model content is presented.
**General Classes**
PartDefinition
**Attributes**
/satisfiedViewpoint : ViewpointUsage [0..*] {subsets ownedRequirement, ordered}
The compositeownedRequirementsof thisViewDefinitionthat areViewpointUsagesfor viewpoints
satisfied by theViewDefinition.
/view : ViewUsage [0..*] {subsets usage, ordered}
Theusagesof thisViewDefinitionthat areViewUsages.
/viewCondition : Expression [0..*] {subsets ownedMember, ordered}
TheExpressionsrelated to thisViewDefinitionbyElementFilterMemberships, which specify conditions
onElementsto be rendered in a view.
/viewRendering : RenderingUsage [0..1]
TheRenderingUsageto be used to render views defined by thisViewDefinition, which is the
referencedRenderingof theViewRenderingMembershipof theViewDefinition.
**Operations**
None.
**Constraints**
checkViewDefinitionSpecialization
AViewDefinitionmust directly or indirectly specialize the baseViewDefinition _Views::View_ from the
Systems Model Library.
specializesFromLibrary('Views::View')
deriveViewDefinitionSatisfiedViewpoint
ThesatisfiedViewpointsof aViewDefinitionare itsownedRequirementsthat are composite
ViewpointUsages.
satisfiedViewpoint = ownedRequirement->selectByKind(ViewpointUsage)->
select(isComposite)
deriveViewDefinitionView
Theviewsof aViewDefinitionare all itsusagesthat areViewUsages.

**364 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


view = usage->selectByKind(ViewUsage)
deriveViewDefinitionViewCondition
TheviewConditionsof aViewDefinitionare theconditionsof its ownedElementFilterMemberships.
viewCondition = featureMembership->selectByKind(ElementFilterMembership).
condition
deriveViewDefinitionViewRendering
TheviewRenderingof aViewDefinitionis thereferencedRenderingof its owned
ViewRenderingMembership, if any.
viewRendering =let renderings: OrderedSet(ViewRenderingMembership) =

```
if renderings->isEmpty() then nullfeatureMembership->selectByKind(ViewRenderingMembership) in
else renderings->first().referencedRenderingendif
```
validateViewDefinitionOnlyOneViewRendering
AViewDefinitionmust have at most oneViewRenderingMembership.
featureMembership->selectByKind(ViewRenderingMembership)->
size() <= 1
**8.3.25.8ViewpointDefinition
Description**
AViewpointDefinitionis aRequirementDefinitionthat specifies one or more stakeholder concerns that
are to be satisfied by creating a view of a model.
**General Classes**
RequirementDefinition
**Attributes**
/viewpointStakeholder : PartUsage [0..*] {ordered}
ThePartUsagesthat identify the stakeholders with concerns framed by thisViewpointDefinition, which are
the owned and inheritedstakeholderParametersof theframedConcernsof thisViewpointDefinition.
**Operations**
None.
**Constraints**
checkViewpointDefinitionSpecialization

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 365**


AViewpointDefinitionmust directly or indirectly specialize the baseViewpointDefinition
_Views::Viewpoint_ from the Systems Model Library.
specializesFromLibrary('Views::Viewpoint')
deriveViewpointDefinitionViewpointStakeholder
TheviewpointStakeholdersof aViewpointDefinitionare theownedStakeholderParametersof all
featureMembershipsthat areStakeholderMemberships.
viewpointStakeholder = framedConcern.featureMemberhsip->selectByKind(StakeholderMembership).
ownedStakeholderParameter
**8.3.25.9ViewpointUsage
Description**
AViewpointUsageis aUsageof aViewpointDefinition.
**General Classes**
RequirementUsage
**Attributes**
/viewpointDefinition : ViewpointDefinition [0..1] {redefines requirementDefinition}
TheViewpointDefinitionthat is thedefinitionof thisViewpointUsage.
/viewpointStakeholder : PartUsage [0..*] {ordered}
ThePartUsagesthat identify the stakeholders with concerns framed by thisViewpointUsage, which are the
owned and inheritedstakeholderParametersof theframedConcernsof thisViewpointUsage.
**Operations**
None.
**Constraints**
checkViewpointUsageSpecialization
AViewpointUsagemust directly or indirectly specialize the baseViewpointUsage
_Views::viewpoints_ from the Systems Model Library.
specializesFromLibrary('Views::viewpoints')
checkViewpointUsageViewpointSatisfactionSpecialization
A compositeViewpointUsagewhoseowningTypeis aViewDefinitionorViewUsagemust directly or
indirectly specialize theViewpointUsage _Views::View::viewpointSatisfactions_ from the Systems Model
Library.

**366 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


isComposite and owningType <> null and(owningType.oclIsKindOf(ViewDefinition) or
owningType.oclIsKindOf(ViewUsage)) impliesspecializesFromLibrary('Views::View::viewpointSatisfactions')

deriveViewpointUsageViewpointStakeholder
TheviewpointStakeholdersof aViewpointUsageare theownedStakeholderParameters of all
featureMemberships that areStakeholderMemberships.
viewpointStakeholder = framedConcern.featureMemberhsip->selectByKind(StakeholderMembership).
ownedStakeholderParameter
**8.3.25.10ViewRenderingMembership
Description**
AViewRenderingMembershipis aFeatureMembership that identifies theviewRenderingof a
ViewDefinitionorViewUsage.
**General Classes**
FeatureMembership
**Attributes**
/ownedRendering : RenderingUsage {redefines ownedMemberFeature}
The ownedRenderingUsagethat is either itself thereferencedRenderingor subsets the
referencedRendering.
/referencedRendering : RenderingUsage
TheRenderingUsagethat is referenced through thisViewRenderingMembership. It is the
referencedFeatureof theownedReferenceSubsettingfor theownedRendering, if there is one, and,
otherwise, theownedRenderingitself.
**Operations**
None.
**Constraints**
deriveVewRenderingMembershipReferencedRendering
ThereferencedRenderingof aViewRenderingMembershipis thereferencedFeatureof the
ownedReferenceSubsetting(which must be aRenderingUsage) of theownedRendering, if there is one, and,
otherwise, theownedRenderingitself.
referencedRendering =let reference: ReferenceSubsetting =

```
if reference = null then ownedRenderingownedRendering.ownedReferenceSubsetting in
else if not reference.referencedFeature.oclIsKindOf(RenderingUsage) then null
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 367**


```
else reference.referencedFeature.oclAsType(RenderingUsage)endif
```
validateViewRenderingMembershipOwningType
TheowningTypeof aViewRenderingMembershipmust be aViewDefinitionor aViewUsage.
owningType.oclIsKindOf(ViewDefinition) orowningType.oclIsKindOf(ViewUsage)

**8.3.25.11ViewUsage
Description**
AViewUsageis a usage of aViewDefinitionto specify the generation of a view of themembersof a collection
ofexposedNamespaces. TheViewUsagecan satisfy moreviewpointsthan its definition, and it can specialize
theviewRenderingspecified by its definition.
**General Classes**
PartUsage
**Attributes**
/exposedElement : Element [0..*] {subsets member, ordered}
TheElements that are exposed by thisViewUsage, which are thosememberElementsof the imported
Membershipsfrom all theExposeRelationshipsthat meet all the owned and inheritedviewConditions.
/satisfiedViewpoint : ViewpointUsage [0..*] {subsets nestedRequirement, ordered}
ThenestedRequirementsof thisViewUsagethat areViewpointUsagesfor (additional) viewpoints satisfied by
theViewUsage.
/viewCondition : Expression [0..*] {subsets ownedMember, ordered}
TheExpressionsrelated to thisViewUsagebyElementFilterMemberships, which specify conditions on
Elementsto be rendered in a view.
/viewDefinition : ViewDefinition [0..1] {redefines partDefinition}
TheViewDefinitionthat is thedefinitionof thisViewUsage.
/viewRendering : RenderingUsage [0..1]
TheRenderingUsageto be used to render views defined by thisViewUsage, which is the
referencedRenderingof theViewRenderingMembershipof theViewUsage.
**Operations**
includeAsExposed(element : Element) : Boolean
Determine whether the givenelementmeets all the owned and inheritedviewConditions.

**368 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**body** : let metadataFeatures: Sequence(AnnotatingElement) =element.ownedAnnotation.annotatingElement->

self.membership->selectByKind(ElementFilterMembership).select(oclIsKindOf(MetadataFeature)) in
condition->forAll(cond |metadataFeatures->exists(elem |
cond.checkCondition(elem)))
**Constraints**
checkViewUsageSpecialization
AViewUsagemust directly or indirectly specialize the baseViewUsage _Views::views_ from the Systems Model
Library.
specializesFromLibrary('Views::views')
checkViewUsageSubviewSpecialization
AViewUsagewhoseowningTypeis aViewDefinitionorViewUsagemust specialize theViewUsage
_Views::View::subviews_ from the Systems Library Model.
owningType <> null and(owningType.oclIsKindOf(ViewDefinition) or
owningType.oclIsKindOf(ViewUsage)) impliesspecializesFromLibrary('Views::View::subviews')

deriveViewUsageExposedElement
exposedElement = ownedImport->selectByKind(Expose).importedMemberships(Set{}).memberElement->
select(elm | includeAsExposed(elm))->asOrderedSet()

deriveViewUsageSatisfiedViewpoint
ThesatisfiedViewpointsof aViewDefinitionare itsownedRequirementsthat are composite
ViewpointUsages.
satisfiedViewpoint = ownedRequirement->selectByKind(ViewpointUsage)->
select(isComposite)
deriveViewUsageViewCondition
TheviewConditionsof aViewDefinitionare theconditionsof its ownedElementFilterMemberships.
viewCondition = featureMembership->selectByKind(ElementFilterMembership).
condition
deriveViewUsageViewRendering
TheviewRenderingof aViewDefinitionis thereferencedRenderingof its owned
ViewRenderingMembership, if any.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 369**


viewRendering =let renderings: OrderedSet(ViewRenderingMembership) =

```
if renderings->isEmpty() then nullfeatureMembership->selectByKind(ViewRenderingMembership) in
else renderings->first().referencedRenderingendif
```
validateViewUsageOnlyOneViewRendering
AViewDefinitionmust have at most oneViewRenderingMembership.
featureMembership->selectByKind(ViewRenderingMembership)->
size() <= 1

**8.3.26Metadata Abstract Syntax
8.3.26.1Overview**

```
OccurrenceDefinition
```
```
MetadataDefinition
```
```
Metaclass
```
```
MetadataUsage
```
```
OccurrenceUsage
```
```
MetadataFeature
```
```
Definition Usage
```
```
ItemDefinition ItemUsage
```
```
+/metadataOwningDefinition
{subsets itemOwningDefinition}0..1
```
```
{subsets ownedItem, ordered}
```
```
+/ownedMetadata
0..*
```
```
{subsets definedItem, subsets typedMetadata}
```
```
+/definedMetadata
{redefines itemDefinition, 0..*
redefines metaclass}
```
```
+/metadataDefinition
0..1
```
```
{subsets nestedItem, ordered}
```
```
+/nestedMetadata
0..*
```
```
+/metadataOwningUsage
{subsets itemOwningUsage}0..1
```
**Figure 53. Metadata Definition and Usage
8.3.26.2MetadataDefinition
Description**
AMetadataDefinitionis anItemDefinitionthat is also aMetaclass.
**General Classes**
Metaclass
ItemDefinition
**Attributes**

**370 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


None.
**Operations**
None.
**Constraints**
checkMetadataDefinitionSpecialization
AMetadataDefinitionmust directly or indirectly specialize the baseMetadataDefinition
_Metadata::MetadataItem_ from the Systems Model Library.
specializesFromLibrary('Metadata::MetadataItem')
**8.3.26.3MetadataUsage
Description**
AMetadataUsageis aUsageand aMetadataFeature, used to annotate otherElementsin a system model with
metadata. As aMetadataFeature, its type must be aMetaclass, which will nominally be a
MetadataDefinition. However, any kernelMetaclassis also allowed, to permit use ofMetaclassesfrom the
Kernel Model Libraries.
**General Classes**
ItemUsage
MetadataFeature
**Attributes**
/metadataDefinition : Metaclass [0..1] {redefines itemDefinition, metaclass}
TheMetadataDefinitionthat is thedefinitionof thisMetadataUsage.
**Operations**
None.
**Constraints**
checkMetadataUsageSpecialization
AMetadataUsagemust directly or indirectly specialize the baseMetadataUsage _Metadata::metadataItems_
from the Systems Model Library.
specializesFromLibrary('Metadata::metadataItems')

**8.4Semantics
8.4.1Semantics Overview**
The semantics of constructs in SysML are specified in terms of the constructs defined in KerML supported by reuse
of model elements from the Kernel Semantic Model Library (see [KerML, 9.2]) and the Systems Model Library (see
9.2). This is similar to how the KerML Kernel Layer semantics are build on the KerML Core Layer (see [KerML,

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 371**


8.4.4.1]). The semantic requirements are formalized by _semantic constraints_ included in the SysML abstract syntax
(see also8.3.1on the various kinds of constraints in the abstract syntax). Additionally, other semantic constraints
require relationships between elements within a user model necessary for the model to be semantically well formed.
Specifically, there are four categories of semantic constraints used to specify SysML semantics, each dealing with a
different kind of relationship.

1. _Specialization constraints._ These constraints require thatDefinitionorUsageelements of a certain
    kind directly or indirectly specialize some specific baseDefinitionorUsagefrom the Kernel Semantic
    Library or the Systems Model Library. They are the fundamental means for providing semantics to
    abstract syntax elements in SysML. Specialization constraints always have the wordSpecializationin
    their name. For example,checkPartDefinitionSpecializationrequires that aPartDefinition
    directly or indirectly specialize thePartDefinition _Parts::Part_ from the Systems Model Library.
2. _Redefinition constraints._ These constraints require that certainUsagesin a model haveRedefinition
    relationships with certain otherUsages(or KerMLFeatures) in the model. WhileRedefinitionsare
    kinds ofSpecializations, redefinition constraints differ from the specialization constraints described
    above because of the specific semantics of redefinition. Redefinition constraints always have the word
    Redefinitionin their name. For example,checkRenderingUsageRedefinitionrequires a
    Redefinitionon aRenderingUsageused to specify aviewRendering.
3. _Type-featuring constraints._ These constraints require that certainUsagesin a model have
    TypeFeaturingrelationships with certain otherDefinitionsorUsagesin the model. The SysML
    specification includes only one constraint in this category,checkOccurrenceUsageFeatureTyping,
    which applies toOccurrenceUsagesmodeling time slices or snaphots. However, various type-featuring
    constraints from KerML also apply to corresponding SysML constructs. For instance, the KerML
    checkConnectorTypeFeaturingalso applies to SysMLConnectionUsages.
4. _Binding-connector constraints._ These constraints require thatBindingConnectorsexist between certain
    Featuresin a model. For example,checkSatisfyRequirementUsageBindingConnectorrequires
    that thesatisfyingFeatureof aSatisfyRequirementUsagebe bound to the subject of the
    SatisfyRequirementUsage. (In a SysML model, it is allowable for binding-connector constraints to be
    satisfied by SysMLBindingConnectorAsUsages, rather than plain KerMLBindingConnectors.)
A SysML model parsed from the textual or graphical concrete syntax (see8.2) or obtained through model
interchange (see [KerML, Clause 10]) will not necessarily meet the semantic constraints specified for the abstract
syntax. In this case, a tool may insert certain impliedRelationshipsinto the model in order to meet the semantic
constraints. In all cases, the semantics of a model are only defined if it meets all semantic and validation constraints
(see8.3.1).
For specialization constraints applying toDefinitions, the impliedRelationshipis aSubclassification,
as given inTable 30. For specialization constraints applying toUsages, the impliedRelationshipis a
Subsetting, as given inTable 31. For redefinition, type-featuring and binding-connector constraints, the implied
Relationshipis aRedefinition,TypeFeaturing, orBindingConnector, as given inTable 32. Note that an
implied Relationship should only be added if the constraint would actually be violated otherwise. For the detailed
conditions on when a constraint applies, see its specification in the abstract syntax model (8.3).
When including impliedRelationshipsfor specialization constraints, it is possible that multiple such constraints
may apply to a singleElement. For example, aPartDefinitionis a kind ofItemDefinition, which is a kind
ofOccurrenceDefinition, and there are specialization constraints for all three of these metaclasses, with
corresponding impliedSubclassificationRelationships. However, simply including all three implied
Subclassificationwould be redundant, because theSubclassificationimplied by the
checkPartDefinitionSpecializationconstraint will also automatically satisfy the
checkItemDefinitionSpecializationandcheckOccurrenceDefinitionSpecializationconstraints.

**372 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Therefore, in order to avoid redundantRelationships, a tool should observe the following rules when selecting
whichSpecializationsto actually include for a certain constrainedElement, out of the set of those implied by
all specialization constraints applicable to theElement:

1. If there is anyownedSpecializationor other impliedSpecializationwhosegeneralTypeis a
    direct or indirect subtype of (but not the same as) thegeneralTypeof an impliedSpecialization, or
    if there is anownedSpecializationwith the samegeneralType, then that implied
    Specializationshould _not_ be included.
2. If there are two impliedSpecializationswith the samegeneralType, then only one should be
    included.
Note that the above rules do _not_ apply toRedefinitionsimplied by redefinition constraints, because
Redefinitionrelationships have semantics beyond just basicSpecialization.
The following subclauses specify the semantics for each syntactic area of SysML in terms of the semantic
constraints that must be satisfied for variousElements, the pattern ofRelationshipsthese imply, and the model
libraryElementsthat are reused to support this. For compactness, the textual notation is used in these subclauses to
present model snippets to illustrate the semantic patterns being discussed. However, it should be understood that,
like the semantic constraints themselves, these semantic patterns are actually defined on the abstract syntax
representation of a model, independent of its textual or graphical concrete syntax representation.
**Table 30. Implied Definition Subclassification Relationships
Semantic Constraint Subclassification Target(see Note 1)**
checkLifeClassLifeSpecialization _Occurrences::Life_
checkLifeClassOccurrenceSpecialization individualDefinitionof theLifeClass
checkItemDefinitionSpecialization _Items::Item_
checkPartDefinitionSpecialization _Parts::Part_
checkPortDefinitionSpecialization _Ports::Port_
checkConnectionDefinitionSpecialization _Connections::Connection_
checkConnectionDefinitionBinarySpecialization _Connections::BinaryConnection_
checkFlowConnectionDefinitionSpecialization _Connections::MessageConnection_
checkInterfaceDefinitionSpecialization _Interfaces::Interface_
checkInterfaceDefinitionBinarySpecialization _Interface::BinaryInterface_
checkAllocationDefinitionSpecialization _Allocations::Allocation_
checkActionDefinitionSpecialization _Actions::Action_
checkStateDefinitionSpecialization _States::StateAction_
checkCalculationDefinitionSpecialization _Calculations::Calculation_
checkConstraintDefinitionSpecialization _Constraints::ConstraintCheck_
checkRequirementDefinitionSpecialization _Requirements::RequirementCheck_
checkConcernDefinitionSpecialization _Concerns::ConcernCheck_
checkCaseDefinitionSpecialization _Cases::Case_

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 373**


```
Semantic Constraint Subclassification Target(see Note 1)
checkAnalysisCaseDefinitionSpecialization AnalysisCases::AnalysisCase
checkVerificationCaseDefinitionSpecialization VerificationCases::VerificationCase
checkUseCaseDefinitionSpecialization UseCases::UseCase
checkViewDefinitionSpecialization Views::View
checkViewpointDefinitionSpecialization Views::ViewpointCheck
checkRenderingDefinitionSpecialization Views::Rendering
checkMetadataDefinitionSpecialization Views::MetadataItem
```
**Notes**

1. In all cases, the source of theSubclassificationis theDefinitionto which the constraint applies.
    **Table 31. Implied Usage Subsetting Relationships
Semantic Constraint Subsetting Target(see Note 1)**
checkUsageVariationUsageSpecialization owningVariationUsageof theUsage
checkAttributeUsageSpecialization _Attributes::attributes_
checkEventOccurrenceSpecialization _Occurrences::Occurrence::timeEnclosedOccurrences_
checkLifeClassMultiplicitySpecialization _Base::exactlyOne_ theLifeClass) (source is themultiplicityof
checkOccurrenceUsageSpecialization _Occurrences::occurrences_
checkOccurrenceUsageSuboccurrence
Specialization

```
Occurrences::Occurrence::
suboccurrences
checkItemUsageSpecialization Items::items
checkItemUsageSubitemSpecialization Items::Item::subitems
checkPartUsageSpecialization Parts::parts
checkPartUsageSubpartSpecialization Items::Item::subparts
checkPartUsageActorSpecialization
```
```
Requirements::Requirement::actors or
Cases::Case::actors (depending on the
owningTypeof thePartUsage)
checkPartUsageStakeholderSpecialization Requirements::Requirement::stakeholders
checkPortUsageSpecialization Ports::ports
checkPortSubportSpecialization Ports::Port::subports
checkConnectionUsageSpecialization Connections::connections
checkConnectionUsageBinarySpecialization Connections::binaryConnections
```
**374 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Semantic Constraint Subsetting Target(see Note 1)
```
```
checkFlowConnectionUsageSpecialization
```
```
Connections::messageConnections or
Connections::flowConnections (depending on
whether theFlowConnectionUsagehas
itemFlowEnds)
checkSuccessionFlowConnectionUsage
Specialization Connections::successionFlowConnections
checkInterfaceUsageSpecialization Interfaces::interfaces
checkInterfaceUsageBinarySpecialization Interfaces::binaryInterfaces
checkAllocationUsageSpecialization Allocations::allocations
checkActionUsageSpecialization Actions::actions
checkActionUsageSubactionSpecialization Actions::Action::subactions
checkActionUsageOwnedActionSpecialization Parts::Part::ownedActions
checkActionUsageAnalysisAction
Specialization
```
```
AnalysisCases::AnalysisCase::
analysisActions
checkControlNodeSpecialization Actions::Action::controls
checkJoinNodeSpecialization Actions::Action::joins
checkForkNodeSpecialization Actions::Action::forks
checkMergeNodeSpecialization Actions::Action::merges
checkMergeNodeIncomingSuccession
Specialization
```
```
incomingHBLink of theMergeNode(source is the
incomingSuccession)
checkDecisionNodeSpecialization Actions::Action::decisions
checkDecisionNodeOutgoingSuccession
Specialization
```
```
outgoingHBLink of theDecisionNode(source is the
outgoingSuccession)
checkSendActionUsageSpecialization Actions::sendActions
checkSendActionUsageSubaction
Specialization Actions::Action::sendSubactions
checkAcceptActionUsageSpecialization Actions::acceptActions
checkAcceptActionUsageSubaction
Specialization Actions::Action::acceptSubctions
checkAcceptActionUsageTriggerAction
Specialization Actions::TransitionAction::accepter
checkAssignmentActionUsageSpecialization Actions::assignmentActions
checkAssignmentActionUsageSubaction
Specialization Actions::Action::assignments
checkIfActionUsageSpecialization
```
```
Actions::ifThenActions or
Actions::ifThenElseActions (depending on
whether theIfActionUsagehas anelseClause)
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 375**


```
Semantic Constraint Subsetting Target(see Note 1)
checkIfActionUsageSubactionSpecialization Actions::Action::ifSubactions
checkWhileLoopActionUsageSpecialization Actions::whileLoopActions
checkWhileLoopActionUsageSubaction
Specialization Actions::Action::whileLoops
checkForLoopActionUsageSpecialization Actions::forLoopActions
checkForLoopActionUsageSubaction
Specialization Actions::Action::forLoops
checkPerformActionUsageSpecialization Parts::Part::performedActions
checkStateUsageSpecialization States::stateActions
checkStateUsageSubstateSpecialization States::State::substates
checkStateUsageExclusiveState
Specialization States::State::exclusiveStates
checkTransitionUsageSpecialization Actions::transitions
checkTransitionUsageActionSpecialization Actions::Action::decisionTransitions
checkTransitionUsageStateSpecialization States::StateAction::stateTransitions
checkTransitionUsagePayloadSpecialization
```
```
TransitionAction::triggerAction.
payloadParameter (source is
TransitionAction::payload )
checkTransitionUsageSuccessionSource
Specialization
```
```
sourceof theTransitionUsage(source is the
sourceFeatureof thesuccessionof the
TransitionUsage;Relationshipis a
ReferenceSubsetting)
```
```
checkTransitionUsageTransitionFeature
Specialization
```
```
accepter , guard , or effect of
Actions::TranstionActions (for the
triggerActions,guardExpressions, and
effectActionsof theTransitionUsage,
respectively)
checkExhibitStateUsageSpecialization Parts::Part::exhibitedStates
checkCalculationUsageSpecialization Calculations::calculations
checkCalculationUsageSubcalculation
Specialization Calculations::Calculation::subcalculations
checkConstraintUsageSpecialization Constraints::constraintChecks
checkConstraintUsageCheckedConstraint
Specialization Items::Item::checkConstraints
```
**376 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Semantic Constraint Subsetting Target(see Note 1)
```
```
checkConstraintUsageRequirementConstraint
Specialization
```
```
Requirements::RequirementCheck::assumptions
or
Requirements::RequirementCheck::constraints
(depending on whether the kind of the owning
RequirementConstraintMembershipis
assumptionorrequirement)
```
```
checkAssertConstraintUsageSpecialization
```
```
Either Constraints::assertedConstraints (if
isNegated = false) or
Constraints::negatedConstraints (ifisNegated
= true)
checkRequirementUsageSpecialization Requirements::requirementChecks
checkRequirementUsageSubrequirement
Specialization
```
```
Requirements::RequirementCheck::
subrequirement
checkRequirementUsageRequirement
VerificationSpecialization
```
```
VerificationCases::VerificationCase::obj::
requirementVerifications
checkConcernUsageSpecialization Requirements::concernChecks
checkConcernUsageFramedConcern
Specialization Requirements::RequirementCheck::concerns
checkCaseUsageSpecialization Cases::Cases
checkCaseUsageSubcaseSpecialization Cases::Case::subcases
checkAnalysisCaseUsageSpecialization AnalysisCases::analysisCases
checkAnalysisCaseUsageSubAnalysisCase
Specialization
```
```
AnalysisCases::AnalysisCase::
subAnalysisCases
checkVerificationCaseUsageSpecialization VerificationCases::verificationCases
checkVerificationCaseUsageSubVerification
CaseSpecialization
```
```
VerificationCases::VerificationCase::
subVerificationCases
checkUseCaseUsageSpecialization UseCases::useCases
checkUseCaseUsageSubUseCaseSpecialization UseCases::UseCase::subUseCases
checkIncludeUseCaseUsageSpecialization UseCases::UseCase::includedUseCases
checkViewUsageSpecialization Views::views
checkViewUsageSubviewSpecialization Views::View::subviews
checkViewpointUsageSpecialization Views::viewpoints
checkViewpointUsageViewpointSatisfaction
Specialization Views::View::viewpointSatisfactions
checkRenderingUsageSpecialization Views::renderings
checkRenderingUsageSubrendering
Specialization Views::Rendering::subrenderings
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 377**


```
Semantic Constraint Subsetting Target(see Note 1)
checkMetadataUsageSpecialization Metadata::metadataItems
```
**Notes**

1. Unless otherwise indicated, the source of theSubsettingis theUsageto which the constraint applies.
    **Table 32. Other Implied Relationships
Semantic Constraint Source Target**

```
Redefinition
```
```
checkActionUsageStateAction
Redefinition TheActionUsage
```
```
entryAction,doAction, or
exitAction of
States::StateAction (depending
on whether thekindof the owning
StateSubactionMembershipis
entry,do, orexit, respectively)
checkAssignmentActionUsage
AccessedFeatureRedefinition
```
```
The firstownedFeatureof the first
ownedFeatureof the first
parameterof the
AssignmentActionUsage
```
```
AssignmentAction::target::
startingAt::accessedFeature
```
```
checkAssignmentActionUsage
ReferentRedefinition
```
```
The firstownedFeatureof the first
ownedFeatureof the first
parameterof the
AssignmentActionUsage
```
```
referentof the
AssignmentActionUsage
```
```
checkAssignmentActionUsage
StartingAtRedefinition
```
```
The firstownedFeatureof the first
parameterof the
AssignmentActionUsage
```
```
AssignmentAction::target::
startingAt
```
```
checkRequirementUsage
ObjectiveSpecialization TheRequirementUsage
```
```
TheobjectiveRequirementof
eachCaseDefinitionor
CaseUsagespecialized by the
owningTypeof the
RequirementUsage.
checkRenderingUsage
Redefinition TheRenderingUsage Views::View::viewRendering
TypeFeaturing
checkOccurrenceUsage
TypeFeaturing TheOccurrenceUsage
```
```
occurenceDefinitionof the
OccurrenceUsage
BindingConnector
(see Note 1)
```
**378 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Semantic Constraint Source Target
checkAcceptActionUsage
ReceiverBindingConnector
```
```
The receiver parameter(second
parameter) of the
AcceptActionUsage
```
```
The receiver parameter(second
parameter) of the
TriggerInvocationExpression
checkTransitionUsageSource
BindingConnector
```
```
Thesourceof the
TransitionUsage
```
```
The transitionLinkSource
parameter(first inputparameter)
of theTransitionUsage
checkTransitionUsage
SuccessionBindingConnector
```
```
Thesuccessionof the
TransitionUsage
```
```
TransitionPerformances::
TransitionPerformance::
transitionLink
checkSatisfyRequirement
UsageBindingConnector
```
```
subjectParameterof the
SatisfyRequirementUsage Base::things::that
```
**Notes**

1. It is acceptable to use either KerMLBindingConnectorsor SysMLBindingConnectorAsUsagesas
    the impliedRelationshipsfor binding-connector constraints. However, a conforming tool should
    consistently use one or the other.

**8.4.2Definition and Usage Semantics**
_Abstract syntax reference:8.3.6_
**8.4.2.1Definitions**
A SysMLDefinitionhas the semantics of a KerMLClassifier(see [KerML, 8.4.3.3]). However, a
Definitionelement is always either instantiated as one of its more specific subclasses (e.g.,
AttributeDefinition,ItemDefinition, etc.), or with at least one semantic metadata annotation. In the former
case, theDefinitionhas the semantics of the more specialize kind. In the latter case it has semantics as given by
the baseType(s) from the annotation(s) (see8.4.22).
**8.4.2.2Usages**
A SysMLUsagehas the semantics of a KerMLFeature(see [KerML, 8.4.3.4]). However, aUsageelement is
always either instantiated as on of its mode specific subclasses (e.g.,AttributeUsage,ItemUsage, etc.), or with
at least one semantic metadata annotation. In the former case, theUsagehas the semantics of the more specialized
kind, except that aReferenceUsagehas no additional semantics. In the latter case it has semantics as given by the
base Type(s) from the annotation(s) (see8.4.22).
**8.4.2.3Variation Definitions and Usages**
ADefinitionorUsagewithisVariation = truehas additional semantic restrictions. In this case, the
validateDefinitionVariationMembershipandvalidateUsageVariationMembershipconstraints
require that all theownedMembersof theDefinitionorUsagebevariantUsages. The
checkUsageVariationDefinitionSpecializationandcheckUsageVariationUsageSpecialization
constraints then require that eachvariantUsagedirectly or indirectly specialize its owning variationDefinition
orUsage.
Thus, a variationDefinitionof the form

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 379**


**variationvariantpartpartdef** p1;P {
**variant** ... **part** p2;
}
has, with impliedRelationshipsincluded, the equivalent kernel semantics of
// KerML **class** P **specializes** Parts::Part {
**membermemberfeaturefeature** p1 : Pp2 : P **subsetssubsets** Parts::parts;Parts::parts;
} ...
Note thatVariantMembershipsareOwningMembershipsbut _not_ FeatureMemberships, so variantUsages
areownedMembersbut _not_ ownedFeaturesof the variationDefinition. Similarly, aUsageof the form
**variationvariantpartpart** p {p1;
**variant** ... **part** p2;
}
has, with impliedRelationshipsincluded, the equivalent kernel semantics of
// KerML **feature** p **subsets** Parts::parts {
**membermemberfeaturefeature** p1p2 **subsetssubsets** p;p;
} ...
(PartDefinitionandPartUsageare used in the examples above for concreteness, but the variation semantics
are similar for any kind ofDefinitionorUsage _other_ thanEnumerationDefinitionorEnumerationUsage.)
In addition, the allowable instances of a variationDefinitionorUsageshall be restricted to values of its
corresponding ownedvariantUsages. This is the fundamental intent of enumerating thevariantsin the
variation declaration. Since a variation enumerates in this way a fixed set of allowed variants, it is not valid for a
variation to specialize another variation, since this would imply an inconsistent subsetting of the allowed instances
in the specializedDefinitionorUsage.
**Note.** The semantic restriction on the instances of a variation is not currently formally captured in the _Systems_
semantic model. However, it is required to be enforced by any semantically conformant tool for variability
modeling.

**8.4.3Attributes Semantics**
_Abstract syntax reference:8.3.7_
**8.4.3.1Attribute Definitions**
AnAttributeDefinitionis a kind ofDefinitionand a kind of KerMLDataType. The base
AttributeDefinition _Attributes::AttributeValue_ (see9.2.2.2.1) is just an alias for the KerML
DataType _Base::DataValue_ (see [KerML, 9.2.2]). Therefore, SysMLAttributeDefinitionshave the same
semantics as KerMLDataTypes(see [KerML, 8.4.4.2]), and the KerMLcheckDataTypeSpecialization

**380 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


constraint requires that anAttributeDefinitionspecialize _Base::DataValue_. AnAttributeDefinitionis
also syntactically restricted by thevalidateAttributeDefinitionFeaturesconstraint to have no composite
features.
**attributeref** a **defsubsets** D1 **specializes** Base::things;Base::DataValue {
}
As specified in the Kernel Semantic Library, _DataValue_ is disjoint from _Occurrence_ , which is the baseTypeof
SysMLOccurrenceDefinitions(see8.4.5). This means that anAttributeDefinitioncannot specialize an
OccurrenceDefinition(or any of its more specialized kinds, such asItemDefinition,ActionDefinition
andConstraintDefinition).
**8.4.3.2Attribute Usages**
AnAttributeUsageis a kind ofUsagethat is syntactically required to be defined only byDataTypes(including
AttributeDefinitions). The baseAttributeUsage _Attributes::attributeValues_ (see9.2.2.2.2) is an
alias for the KerMLFeature _Base::dataValues_ (see [KerML, 9.2.2]). The
checkAttributeUsageDataTypeSpecializationconstraint requires that anAttributeUsagespecialize
_Base::dataValues_ , which is typed by _Base::DataValue._ AttributeUsagesare also syntactically restricted
by thevalidateAttributeUsageIsReferenceto be referential (non-composite) and, by the
validateAttributeUsageFeaturesconstraint to have no compositefeatures.
**attributeref attributedef** D2 **specializes** a : ScalarValue::StringBase::DataValue { **subsets** Base::dataValues;
} **ref attribute** d : D2 **subsets** Base::dataValues {
} **ref attribute** b **subsets** a;
**8.4.4Enumerations Semantics**
_Abstract syntax reference:8.3.8_
AnEnumerationDefinitionis a kind ofAttributeDefinition, so the semantic constraints for KerML
DataTypesapply to it, as for anAttributeDefinition(see8.4.3). However, anEnumerationDefinitionis
also required to haveisVariation = true, and itsenumeratedValuesare then just itsvariants(see8.4.2.3
on the semantics of variationDefinitions). Therefore, anEnumerationDefinitionof the form
**enumenumdef** E {e1;
**enum** ... e2;
}
is essentially equivalent to
**variationvariantattributeattributedef** e1 : EE **specializessubsets** Base::dataValues;Base::DataValue {
**variant** ... **attribute** e2 : E **subsets** Base::dataValues;
}
Note, in particular, that this means that theenumeratedValuesare _not_ features of the containing
EnumeratedDefinitionbut, rather, members owned viaVariantMemberships. However, other than when

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 381**


nested in anEnumerationDefinition, anEnumerationUsageis semantically just anAttributeUsagethat is
required to be typed by exactly oneEnumerationDefinition(syntactically enforced by the 1..1 multiplicity of
EnumerationUsage::enumerationDefinition, see8.3.8).
Since anEnumerationDefinitionis already a variation, there is no further concept of a "variation enumeration".
Also, since, in general, a variation cannot specialize another variation (as discussed in8.4.2.3), an
EnumerationDefinitioncannot specialize anotherEnumerationDefinition.

**8.4.5Occurrences Semantics**
_Abstract syntax reference:8.3.9_
**8.4.5.1Occurrence Definitions**
AnOccurrenceDefinitionis a kind ofDefinitionand a kind of KerMLClass. The kernel
checkClassSpecializationconstraint requires that it specialize the baseClass _Occurrences::Occurrence_
from the Kernel Semantic Library (see [KerML, 9.2.4]). Therefore, SysMLOccurrenceDefinitionshave the
same basic semantics as KerMLClasses(see [KerML, 8.4.4.3]). However, there are additional semantic
constraints on anOccurrenceDefinitionif it hasisIndividual = true(see below). TheClass
_Occurrences::Occurrence_ is disjoint with _Base::DataValues_ , the baseTypeforAttributeDefinitions
(see8.4.3), so anOccurrenceDefinitioncannot specialize anAttributeDefinition.
If anOccurrenceDefinitionhasisIndividual = true, then the
validateOccurrenceDefinitionLifeClassconstraint requires that it have a singleownedMemberthat is a
LifeClass. The following constraints apply toLifeClass:

- checkLifeClassLifeSpecializationrequires that it specialize theClass _Life_ from the Kernel
    Semantic LibraryOccurrences(see [KerML, 9.2.4]).
- checkLifeClassOccurrenceSpecializationrequires that it specialize its owning
    OccurrenceDefinition.
- checkLifeClassMultiplicitySpecializationrequires that it havemultiplicity _zeroOrOne_.
- validateLifeClassIsSufficientrequires that it haveisSufficient = true.
Thus, anOccurrenceDefinitiondeclaration of the form
**individualoccurrence def** Ind;
has the equivalent kernel semantics of
// KerML **class** Ind **specializes** Occurrences::Occurrence {
**class allmultiplicity subsets** Life **specializes** Base::zeroOrOne;Occurrences::Life, Ind {
} }
The Kernel Semantic LibraryClass _Life_ classifies all _Occurrences_ that are _maximal portions,_ that is, those
_Occurrences_ that are not a portion of any other _Occurrence_. Every _Occurrence_ is a portion of some _Life_
(possibly itself), as given by the value of its _portionOfLife_ feature(see [KerML, 9.2.4]). An _individual
Occurrence_ is modeled as the subclass that includes a single _Lifeand_ all possible portions (in time and space) of
that _Life_. Colloquially, a _Life_ represents the "identity" of an individual and the totality of its existence in space
and time.

**382 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The requiredSpecializationsand sufficiency of aLifeClassmean that it is the subclass of all _Lives_ that are
also instances of the owningOccurrenceDefinition. The _zeroOrOne_ multiplicityof theLifeClassthen
asserts that theLifeClasshas at most a single instance, meaning that there is at most one instance of the owning
OccurrenceDefinitionthat is a _Life_. If this instance exists, then all other instances of the
OccurrenceDefinitionwill be portions of it, and theOccurrenceDefinitionwill then model exactly a single
individual, as described above. If the instance does not exist, then the extent ofOccurrenceDefinitionwill be
empty, meaning no such individual exits. (The optionalmultiplicityon aLifeClassthus provides for the
ability to model counterfactual situations in which a certain individual is asserted _not_ to exist.)
**8.4.5.2Occurrence Usages**
AnOccurrenceUsageis a kind ofUsagethat is syntactically required to be defined only byClasses(including
OccurrenceDefinitions). The following specialization constraints apply to anOccurrenceUsage:

- checkOccurrenceUsageSpecializationrequires that it specialize theFeature
    _Occurrences::occurrences_ from the Kernel Model Library (see [KerML, 9.2.4]), which is typed by
    _Occurrences::Occurrence_.
- checkOccurrenceUsageSuboccurrenceSpecializationrequires that, if theOccurrenceUsageis
    composite (non-referential) and owned by anOccurrenceDefinitionorOccurrenceUsage, it
    specialize theFeature _Occurrences::Occurrence::suboccurrences_ (see [KerML, 9.2.4]), which
    subsets _Occurrences::occurrences._
**occurrencerefoccurrencedef** Occ **specializes** a **subsets** Occurrences::occurrences;Occurrences::Occurrence {
} **occurrence** b **subsets** Occurrences::Occurrence::suboccurrences;
AnOccurrenceUsagethat has anoccurrenceDefinitionwithisIndividual = truerepresents a usage of
the individual modeled by thatOccurrenceDefinition(or possibly a time slice or snapshot of it, see below).
This is constrained as follows:
- validateOccurranceUsageIndividualDefinitionrequires that anOccurrenceUsagehave at
most one suchoccurrenceDefinitionthat hasisIndividual = true.
- validateOccurrenceUsageIsIndividualrequires that, if theOccurrenceUsagehas
isIndividual = true, it have _exactly_ one suchoccurrenceDefinition(which will then be the
value of itsindividualDefinitionproperty).
If anOccurrenceUsagehas a non-nullportionKind, then it is also required to have aportioningFeature
with the sameportionKind. The following semantic constraints apply to aPortioningFeature:
- checkPortioningFeatureSpecializationrequires that it specialize each of the
occurrenceDefinitionsof its owningOccurrenceUsage.
- checkPortioningFeatureRedefinitionrequires that, if that, ifportionKind = timeslice,
thePortioningFeatureredefine theFeature _Occurrences::Occurrence::timeSliceOf_ and, if
portionKind = snapshot, it redefine theFeature _Occurrences::Occurrence::snapshotOf_ ,
both from the Kernel Semantic Library model forOccurrences(see [KerML, 9.2.4]).
- checkPortioningFeatureMultiplicitySpecializationrequires that it have multiplicity
_exactlyOne_.
Thus, the time slice and snapshot declarations
**timeslicesnapshot occurrenceoccurrence** s : Occ;t : Occ;

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 383**


have, with impliedRelationshipsincluded, the equivalent kernel semantics of
// KerML **feature** t : Occ **subsets** Occurrences::occurrences {
// Portioning feature **featureredefines** Occurrences::Occurrence::timeSliceOf : Occ {
} **multiplicity subsets** Base::exactlyOne;
} **feature** s : Occ **subsets** Occurrences::occurrences {
// Portioning feature **featureredefines** Occurrences::Occurrence::snapshotOf : Occ {
} **multiplicity subsets** Base::exactlyOne;
}
In the semantic model for _Occurrence_ , theFeatures _timeSliceOf_ and _snapshotOf_ are the inverses of the
Features _timeSlices_ and _snapshots_ , respectively. TheportioningFeaturesfor _t_ and _s_ , above, therefore,
require that each value of _t_ or _s_ be one of the _timeSlices_ or _snapshots_ of an instance of the defining
OccurrenceDefinition _Occ_.
**8.4.5.3Event Occurrence Usages**
AnEventOccurrenceUsageis a kind ofOccurrenceUsagethat is required to always be referential by the
validateEventOccurrenceUsageIsReference. All general semantic constraints on anOccurrenceUsage
(see8.4.5.2) also apply to anEventOccurrenceUsage. In addition, if anEventOccurrenceUsageis an
ownedFeatureof anOccurrenceDefinitionorOccurrenceUsage, then the
checkEventOccurrenceUsageSpecializationconstraint requires that it specialize the kernelFeature
_Occurrences::Occurrence::timeEnclosedOccurrences_ (see [KerML, 9.2.4]). In this case, any
_Occurrence_ referenced by theEventOccurrenceUsagemust happen within the lifetime of the featuring
_Occurrence_ of theEventOccurrenceUsage.
For example, the following model:
**occurrenceoccurrence** occ1;occ2 {
**event** // Other than having a name, the above is equivalent to **occurrence** evt **references** occ1;
} // **event** occ1;
is, with impliedRelationshipsincluded, semantically equivalent to
**occurrenceoccurrence** occ1occ2 **subsetssubsets** Occurrences::occurrences;Occurrences::occurrences {
**refoccurrencesubsets** Occurrences::Occurrence::timeEnclosedOccurrences;evt **references** occ1
}
Thus, the values of _occ2.evt_ will be some subset of the _Occurrences_ represented by _occ1_ that happen within the
lifetime of _occ2._
AnEventOccurrenceUsagethat is _not_ anownedFeatureof anOccurrenceDefinitionor
OccurrenceUsagehas the same semantics as a referentialOccurrenceUsage(see8.4.5.2).

**384 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.4.6Items Semantics**
_Abstract syntax reference:8.3.10_
**8.4.6.1Item Definitions**
AnItemDefinitionis a kind ofOccurrenceDefinitionand a kind of KerMLStructure. As such, all the
general semantic constraints for anOccurrenceDefinition(see8.4.5) and aStructure(see [KerML, 8.4.4.4])
also apply to anItemDefinition. In addition, thecheckItemDefinitionSpecializationconstraint requires
that anItemDefinitionspecialize the baseItemDefinition _Items::Item_ (see9.2.3.2.1), which subclassifies
the kernelClass _Objects::Object_ (see [KerML, 9.2.5]).
The _Item_ semantic model also includes additionalfeatureswhose semantics is covered in other subclauses:

- _subparts_ – A subset of _subitems_ and _Parts::parts_ that collects the values of all composite
    PartUsagesfeatured by an _Item_. Covered underParts Semantics (see8.4.7).
- _checkedConstraints–_ A subset of _Constraints::constraintChecks_ and
    _Object::ownedPerformances_ that collects all checks of compositeConstraintUsagesfeatured by
    an _Item._ Covered under Constraints Semantics (see8.4.15).
**8.4.6.2Item Usages**
AnItemUsageis a kind ofOccurrenceUsage. As such, all the general semantic constraints for an
OccurrenceUsage(see8.4.5) also apply to anItemUsage. The following additional specialization constraints
also apply to anItemUsage:
- checkItemUsageSpecializationrequires that anItemUsagespecialize the baseItemUsage
_Items::items_ (see9.2.3.2.2), which subsets the KernelFeature _Objects::objects_ (see [KerML,
9.2.5]).
- checkItemUsageSubitemSpecializationrequires that anItemUsagethat is composite and has an
owningTypethat is anItemDefinitionorItemUsagespecialize theItemUsage
_Items::Item::subitems_ (see9.2.3.2.1), which subsets _Objects::Objects::subobjects_ (see
[KerML, 9.2.5]) and _Items::items_.
**itemrefdefitem** I **specializes** a **subsets** Items::Item {Items::items;
} **item** b **subsets** Items::Item::subitems;
As a kind of _Object_ , an _Item_ may have a physical extent in three-dimensional space as well as existing over time.
The semantic model for an _Item_ contains a number of specializations of the kernel spatial model (see [KerML, 9.2.4
and 9.2.5]), including thefeatures _shape,envelopingShapes,boundingShapes,voids,_ and _isSolid_ (see
9.2.3.2.1for details). This provides the basis for the geometric shape model defined in the Geometry Domain
Library (see9.7).

**8.4.7Parts Semantics**
_Abstract syntax reference:8.3.11_
**8.4.7.1Part Definitions**
APartDefinitionis a kind ofItemDefinition. As such, all the general semantic constraints for an
ItemDefinition(see8.4.6) also apply to aPartDefinition. In addition, the

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 385**


checkPartDefinitionSpecializationconstraint requires that aPartDefinitionspecialize the base
PartDefinition _Parts::Part_ (see9.2.4.2.1), which subclassifies _Items::Item_ (see9.2.3.2.1)_._
The _Part_ semantic model also includes additionalfeatureswhose semantics is covered in other subclauses:

- _ownedPorts_ – A subset of _Ports::ports_ and _Occurrences::timeEnclosedOccurrences_ that
    collects the values of thePortUsagesfeatured by a _Part_. Covered under Ports Semantics (see8.4.8).
- _performedActions_ – A subset of _Actions::actions_ and _Objects::enactedPerformances_ that
    collects the values of thePerformedActionUsagesfeatured by a _Part_. Covered under Actions
    Semantics (see8.4.12).
- _ownedActions_ – A subset of _Actions::actions_ and _Objects::ownedPerformances_ that collects
    the values of the compositeActionUsagesfeatured by a _Part._ Covered under Actions Semantics (see
    8.4.12).
- _exhibitedStates_ – A subset of _States::stateActions_ and _performedActions_ that collectsthe
    values of theExhibitStateUsagesfeatured by a _Part_. Covered under States Semantics (see8.4.13).
- _ownedStates_ – A subset of _States::stateActions_ and _ownedActions_ that collects the values of
    the compositeStateUsagesfeatured by a _Part_. Covered under States Semantics (see8.4.13).
**8.4.7.2Part Usages**
APartUsageis a kind ofItemUsage. As such, all the general semantic constraints for anItemUsage(see8.4.6)
also apply to aPartUsage, as well as the following additional specialization constraints:
- checkPartUsageSpecializationrequires that aPartUsagespecialize the basePartUsage
_Parts::parts_ (see9.2.4.2.2).
- checkPartUsageSubpartSpecializationrequires that aPartUsagethat is composite and has an
owningTypethat is anItemDefinitionorItemUsagespecialize thePartUsage
_Items::Item::subparts_ (see9.2.3.2.1), which subsets _Items::Item::subitems_ (see9.2.3.2.1) and
_Parts::parts_.
**partrefdefpart** P **specializes** a **subsets** Parts::Part {Parts::parts;
**partitem** bc **subsetssubsets** Items::Item::subparts;Items::Item::subitems {
} **part** p : P **subsets** Items::Item::subparts;
}
- checkPartUsageActorSpecializationrequires that aPartUsagethat is owned by a
ActorMembershipspecialize either thePartUsage _Requirements::RequirementCheck::actors_
(see9.2.13.2.8) or _Cases::Case::actors_ (see9.2.14.2.1). See also Requirements Semantics (8.4.16)
and Case Semantics (see8.4.17).
- checkPartUsageStakeholderSpecializationrequires that aPartUsagethat is owned by a
StakeholderMembershipspecialize thePartUsage
_Requirements::RequirementCheck::stakeholders_ (see9.2.13.2.8). See also Requirements
Semantics (8.4.16).

**8.4.8Ports Semantics**
_Abstract syntax reference:8.3.12_

**386 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.4.8.1Port Definitions**
APortDefinitionis a kind ofOccurrenceDefinitionand a kind of KerMLStructure. As such, all the
general semantic constraints for anOccurrenceDefinition(see8.4.5) and aStructure(see [KerML, 8.4.4.4])
also apply to aPortDefinition. The following additional constraints apply to aPortDefinition:

- checkPortDefinitionSpecializationrequires thataPortDefinitionspecialize the base
    PortDefinition _Ports::Port_ (see9.2.5.2.1), which subclassifies the kernelClass
    _Objects::Object_ (see [KerML, 9.2.5]).
- validatePortDefinitionNestedUsagesNotCompositerequires that allnestedUsagesof the
    PortDefinitionthat are _not_ PortUsagesare referential (non-composite).
APortDefinitionis parsed as containing aConjugatedPortDefinitionwith a
ConjugatedPortDefinitionRelationshippointing back to the containingPortDefinition. A
PortConjugationis a kind of KerMLConjugationand, except for being syntactically restricted to be between a
ConjugatedPortDefinitionand a (non-conjugated)PortDefinition, it has the same effect asConjugation.
That is, theConjugatedPortDefinitionis considered to inherit the features of itsPortDefinition, butin
andoutdirections are reversed (see [KerML, 8.3.3.1]).
Thus, aPortDefinitiondeclaration of the form
**port** // Directed features are always referential **def** Pd {
// ( **inrefref** a;keyword is optional).
**outinoutrefref** b;c;
} **refitem** d;
has, with impliedSpecializationsincluded, the equivalent kernel semantics of
// KerML **struct** Pd **specializes** Ports::Port {
**inoutfeaturefeature** ab **subsetssubsets** Base::things;Base::things;
**inoutfeaturefeature** d **subsets** c **subsets** Items::Item;Base::things;
**struct** //* Effective conjugated features:'~Pd' **conjugates** Pd {
**inoutfeaturefeature** b a **subsetssubsets** Base::things;Base::things;
**inoutfeaturefeature** d **subsets** c **subsets** Items::Item;Base::things;
} ***//** }
Note that the KerMLvalidateSpecificationSpecificNotConjugatedconstraint disallows aTypethat is
conjugated from having anownedSpecialization(see [KerML, 8.3.3.1]). Nevertheless,~Pdstill satisfies the
checkPortDefinitionSpecializationconstraint because its originalPortDefinitiondoes.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 387**


**8.4.8.2Port Usages**
APortUsageis a kind ofOccurrenceUsagethat is syntactically restricted to be defined only by
PortDefinitions. As such, all the general semantic constraints for anOccurrenceUsage(see8.4.5) also apply
to aPortUsage, as well as the following additional constraints:

- checkPortUsageSpecializationrequires that aPortUsagespecialize the basePortUsage
    _Ports::ports_ (see9.2.5.2.2), which subsets the kernelFeature _Objects::objects_ (see [KerML,
    9.2.5]).
- checkPortUsageSubportSpecializationconstraint requires that aPortUsagethat is composite
    and has anowningTypethat is anPortDefinitionorPortUsagespecialize thePortUsage
    _Ports::Port::subports_ (see9.2.5.2.1), which subsets
    _Occurrences::Occurrence::timeEnclosedOccurrences_ (see [KerML, 9.2.4]) and
    _Ports::ports_.
- validatePortUsageNestedUsagesNotCompositerequires that allnestedUsagesof the
    PortUsagethat are _not_ PortUsagesare referential (non-composite).
**portport** p : Pdp1 **specializessubsets** Ports::Port::subports;Ports::ports {
} **ref port** p2 **subsets** Ports::ports;
The following constraints apply to aPortUsagethat is _not_ nested in aPortDefinitionorPortUsage:
- validatePortUsageIsReferencerequires that it is referential (non-composite).
- checkPortUsageOwnedPortSpecializationrequires that aPortUsagehas anowningTypethat is
aPartDefinitionorPartUsagespecialize thePortUsage _Parts::Part::ownedPorts_ (see
9.2.4.2.1).
**part** // PortUsages not nested in PortDefinitions or PortUsages **def** P **specializes** Parts::Part {
// are always referential ( **refport** p : Pd **subsets** Parts::Part::ownedPorts; **ref** keyword is optional).
}
APortUsagemay have anownedFeatureTypingthat is aConjugatedPortTyping, in which case the type is
theConjugatedPortDefinitionfor the namedPortDefinition(see8.2.2.12). Thus, the declaration
**port** p : ~Pd;
is equivalent to
**port** p : Pd::'~Pd';
**8.4.9Connections Semantics**
_Abstract Syntax Reference:8.3.13_
**8.4.9.1Connection Definitions**
AConnectionDefinitionis a kind ofPartDefinitionand a kind of KerMLAssociationStructure. As
such, all the general semantic constraints for aPartDefinition(see8.4.7) and anAssociationStructure(see
[KerML, 8.4.4.5.2]) also apply to aConnectionDefinition. In addition, the
checkConnectionDefinitionSpecializationconstraint requires that aConnectionDefinitionspecialize
the baseConnectionDefinition _Connections::Connection_ (see9.2.6.2.3), which subclassifies the

**388 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


PartDefinition _Parts::Part_ (see9.2.4.2.1) and the kernelAssociationStructure
_Objects::LinkObject_ (see [KerML, 9.2.5]).
AConnectionDefinitionmust have at last twoconnectionEndFeatures(unless it is abstract), and it may
also haveownedFeaturesthat are not ends. ThecheckFeatureEndSpecializationand
checkFeatureEndRedefinitionSpecializationconstraints apply to theconnectionEndsof a
ConnectionDefinition. As a result, allconnectionEnds must directly or indirectly specialize the kernel
Feature _Link::participant_ and they must redefine the endFeaturesof anyAssociationsspecialized by
their owningConnectionDefinition(see [KerML, 8.4.4.5]).
**connectionendrefdef** e1C **subsetsspecializes** Links::Link::participant;Connections::Connection {
**endendrefref** e2e3 **subsetssubsets** Links::Link::participant;Links::Link::participant;
} **connection def** D **specializes** C {
**endendrefref** f1f2 **redefinesredefines** C::e1;C::e2;
} **endref** f3 **redefines** C::e3;
In addition, there are special rules for the semantics of the multiplicity of endFeatures(see [KerML, 8.4.4.5]).
ThecheckConnectionDefinitionBinarySpecializationconstraint requires that a binary
ConnectionDefinitionspecialize theConnectionDefinition _Connections::BinaryConnection,_ which
subclassifies _Connection_ and _Objects::BinaryLinkObject_ (see [KerML, 9.2.5]), which is a subclassification
of _Objects::LinkObject_ and _Links::BinaryLink_ (see [KerML, 9.2.3] that restricts a _BinaryConnection_
two have exactly two _participants_ corresponding to two ends called _source_ and _target._ As required by the
checkFeatureEndRedefinitionconstraint, the firstconnectionEndof a binaryAssociationwill redefine
_Connections::BinaryConnection::source_ and its secondconnectionEndwill redefine
_Connections::BinaryConnection::target._
**connection defendref** e1B **redefinesspecializes** Connections::BinaryConnectionConnections::BinaryConnections {::source;
} **endref** e2 **redefines** Connections::BinaryConnection::target;
**8.4.9.2Connection Usages**
AConnectionUsageis aPartUsageand aConnectorAsUsage, which is a kind of KerMLConnector. As
such, all the general semantic constraints for aPartUsage(see8.4.7) and aConnector(see [KerML, 8.4.4.6.1])
also apply to aConnectionUsage. In addition, thecheckConnectionUsageSpecializationconstraint
requires that aConnectionUsagespecialize the baseConnectionUsage _Connections::connections_ (see
9.2.6.2.4), which is defined byConnections::Connectionand subsets thePartUsage _Parts::parts_ (see
9.2.4.2.2) and the kernelFeature _Objects::linkObjects_ (see [KerML, 9.2.5]). AConnectionUsageis
syntactically restricted to be defined only byAssociationStructures(includingConnectionDefinitions).
Further, thecheckFeatureEndRedefinitionconstraint requires that the endFeaturesof aConnectionUsage
redefine of corresponding endFeaturesof itsconnectionDefinitions(see [KerML, 8.4.4.5]).
**connectionendref** c : Ce1 **referencessubsets** Connections::connections {f1 **redefines** C::e1;
**endendrefref** e2e3 **referencesreferences** f2f3 **redefinesredefines** C::e2;C::e1;
}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 389**


Note that therelatedFeaturesof aConnectionUsageare determined by thereferencedFeaturesof its
ends. Therefore, unless theConnectionUsageis abstract, every end must have anownedReferenceSubsetting.
ThecheckConnectionUsageBinarySpecializationconstraint requires that a binaryConnectionUsage
specialize theConnectionUsage _Connections::binaryConnections_ (see9.2.6.2.2), which is defined by
_Connections::BinaryConnection_ and subsets he _Connections::connections_ and the kernelFeature
_Objects::binaryLinkObjects_ (see [KerML, 9.2.5])
**connectionendref** b : Bsource **subsetsreferences** Connections::binaryConnections {f1 **redefines** B::source;
} **endref** target **references** f2 **redefines** B::target;
Since aConnectionUsageis a kind ofPartUsage, thecheckPartUsageSupartSpecializationconstraint
requires that a compositeConnectionUsagenested in anItemDefinitionorItemUsageof any kind specialize
thePartUsage _Items::Item::subparts_ (see9.2.3.2.1) as well as _Connections::connections_ or
_Connections::binaryConnections_ (see also8.4.7.2).
**partpartdef** Pf1 **specializessubsets** Items::Item::subparts;Parts::Part {
**partconnector** f2 **subsets** b : BItems::Item::subparts;
**subsetsconnects** Connections::binaryConnections, Items::Items::subpartsf1 **to** f2;
}
**8.4.9.3Binding Connectors As Usages**
ABindingConnectorAsUsageis a kind ofConnectorAsUsageand a kind of KerMLBindingConnector. As
such, all the general semantic constraints for aUsage(see8.4.2) and aBindingConnector(see [KerML,
8.4.4.6.2]) also apply to aBindingConnectorAsUsage. In particular, the
checkBindingConnectorSpecializationconstraint requires thatBindingConnectorAsUsagesspecialize
the kernelFeature _Links:selfLink,_ which is typed by theAssociation _SelfLink_ (see [KerML, 9.2.3]). A
BindingConnectorAsUsagetherefore has the same basic semantics as a KerMLBindingConnector, asserting
that the (single) values of its two ends must be the same things (see [KerML, 8.4.4.6.2]).
Thus, aBindingConnectorAsUsagedeclaration of the form
**bind** f1 = f2;
has, with impliedSpecializationsincluded, the equivalent kernel semantics of
// KerML **connectorsubsets** Links::selfLinks {
**end featureendfeature** thisThingthatThing **redefinesredefines** Links::SelfLink::thisThingLinks::SelfLink::thatThing **referencesreferences** f1;f2;
}
Note that aBindingConnectorAsUsagedoes _not_ have the semantics of a SysMLConnectionUsage, because a
ConnectionUsagemust be defined byAssociationStructures(see8.4.9.2), and _Links::selfLink_ is an
Associationbut _not_ anAssociationStructure.
The KerMLcheckFeatureValueBindingConnectorconstraint requires that aFeatureValuewith
isDefault = falsehave aBindingConnectorto enforce its semantics (see [KerML, 8.4.4.11]). For a SysML

**390 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


model, it is allowable to use aBindingConnectorAsUsage, rather than a plain KerMLBindingConnector, as
the impliedRelationshipto satisfy this constraint.
**8.4.9.4Successions As Usages**
ASuccessionAsUsageis a kind ofConnectorAsUsageand a kind of KerMLSuccession. As such, all the
general semantic constraints for anUsage(see8.4.2) and aSuccession(see [KerML, 8.4.4.6.3]) also apply to a
SuccessionAsUsage. In particular, thecheckSuccessionSpecializationconstraint requires that a
SuccessionAsUsagespecialize the KerMLFeature _Occurrences::happensBeforeLinks_ (see [KerML,
9.2.4]), which is typed by theAssociation _HappensBefore._ ASuccessionAsUsagetherefore has the same
basic semantics as a KerMLSuccession, asserting that the _Occurrence_ identified by its first end happens
temporally before the one identified by its second end.
Thus, aSuccessionAsUsagedeclaration of the form
**succession first** f1 **then** f2;
has, with impliedSpecificationsincluded, the equivalent kernel semantics of
// KerML **connectorsubsets** Occurrences::happensBeforeLinks {
**endfeatureredefines** earlierOccurrenceOccurrences::HappensBefore::earlierOccurrence; **references** f1
**endfeatureredefines** laterOccurrenceOccurrences::HappensBefore::laterOccurrence; **references** f2
}
Note that aSuccessionAsUsagedoes _not_ have the semantics of a SysMLConnectionUsage, because a
ConnectionUsagemust be defined byAssociationStructures(see8.4.9.2), and
_Occurrences::HappensBefore_ is anAssociationbut _not_ anAssociationStructure.
**8.4.9.5Flow Connection Definitions**
AFlowConnectionDefinitionis a kind ofConnectionDefinition, a kind ofActionDefinition, and a
kind of KerMLInteraction. As such, all the general semantic constraints forConnectionDefinitions(see
8.4.9.1),ActionDefinitions(see8.4.12.1), andInteractions(see [KerML, 8.4.4.10.1]) also apply to
FlowConnectionDefinitions. In addition, thecheckFlowConnectionDefinitionSpecialization
constraint requires that aFlowConnectionDefinitionspecialize the baseFlowConnectionDefinition
_Connections::MessageConnection_ (see9.2.6.2.7), which subclassifies theConnectionDefinition
_BinaryConnection_ (see9.2.6.2.1) and theActionDefinition _Actions::Action_ (see9.2.9.2.4, as well as the
kernelInteraction _Transfers::Transfer_ (see [KerML, 9.2.7]).
AFlowConnectionDefinitionis always binary, with _source_ and _target_ ends corresponding tothe
corresponding ends of _Transfer_. It also inherits _MessageConnection::payload,_ which is a redefinition of
_Transfer::item,_ representing the payload being transferred. These features can be redefined to restrict the
allowedtypeof the ends connected by a flow and thetypeof the payload transferred across the flow, as desired.
Note that the _source_ and _target_ ends must be kinds of _Occurrences,_ but that the _payload_ can be anything,
**flowitemdef** Mi : I **specializesredefines** Connections::MessageConnection {MessageConnection::payload;
**endend** p : Pq : Q **redefinesredefines** MessageConnection::source;MessageConnection::target;
}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 391**


The ends of a _MessageConnection_ identify the _Occurrences_ between which _payload_ values are flowing, but
they do not identify how these values are obtained from the _source_ (the _sourceOutput_ Feature) or to where they
are delivered at the target (the _targetInput_ Feature). In order to restrict the _sourceOutput_ and _targetInput_
in aFlowConnectionDefinition, theFlowConnectionDefinitioncan specialize
_Connections::FlowConnection_ (see9.2.6.2.5), which is a _MessageConnection_ that also subclassifies the
kernelInteraction _FlowTransfer_ (see [KerML, 9.2.7]).
**partportdef** Pp1 : Pd **specializessubsets** Parts::Part {Parts::Part::ownedPorts;
} **partdef** Q **specializes** Parts::Part {
} **port** p2 : ~Pd **subsets** Parts::Part::ownedPorts;
**flowitemdef** Fi : I **specializesredefines** Connections::FlowConnection {MessageConnection::payload;
**end** p : P **port** p1 **redefinesredefines** MessageConnection::source {P::p1, MessageConnection::source::sourceInput;
} **end** q : Q **redefines** MessageConnection::target {
} **port** p2 **redefines** Q::p2, MessageConnection::source::targetOuput;
}
AFlowConnectionDefinitionmay also specialize _Connections::SuccessionFlowConnection_
(see9.2.6.2.9), which is a _FlowConnection_ that also subclassifies the kernelInteraction
_FlowTransferBefore_ (see [KerML, 9.2.7]). A _SuccessionFlowConnection_ not only represents a flow from
the _source_ to the _target,_ but it also asserts that the flow happens after the completion of the lifetime of the
_source_ and before the start of the lifetime of the _target_ (e.g., if the _source_ and _target_ are _Actions,_ then the
_sourceAction_ must complete before the flow can start, and the flow must complete before the _targetAction_
can start).
**8.4.9.6Flow Connection Usages**
AFlowConnectionUsageis a kind ofConnectionUsage, a kind ofActionUsage, and a kind of KerML
ItemFlowthat is syntactically restricted to be defined by only KerMLInteractions(including
FlowConnectionDefinitions). As such, all the general semantic constraints that apply to aConnectionUsage
(see8.4.9.2), anActionUsage(see8.4.12.2), and anItemFlow(see [KerML, 8.4.4.10.2]) also apply to a
FlowConnectionUsage. In addition, thecheckFlowConnectionUsageSpecificationconstraint requires that
aFlowConnectionUsagespecialize the baseFlowConnectionUsage _Connections::messageConnections_
(see9.2.6.2.8), which is typed by theConnectionDefinition _Connections::MessageConnection_ (see
9.2.6.2.7) and subsets the ConnectionUsage _Connections::binaryConnections_ (see9.2.6.2.2), the
ActionUsage _Actions::actions_ (see9.2.9.2.5), and the kernelStep _Transfers::transfers_ (see [KerML,
9.2.7]). Further, if theFlowConnectionUsagehasitemFlowEnds, then it must specialize the
FlowConnectionUsage _Connections::flowConnections_ (see9.2.6.2.6), which is defined by the
FlowConnectionDefinition _Connections::FlowConnection_ (see9.2.6.2.5) and subsets
_Connections::messageConnections_ and the kernelStep _Transfers::flowTransfers_ (see [KerML,
9.2.7]).
A message declaration of the form
**message** m : M **of** i : I **from** evt1 **to** evt2;
is parsed as an abstractFlowConnectionUsage, but without anyconnectionEnds(see8.2.2.13.4), so it is
required bycheckFlowConnectionUsageSpecificationto just specialize
_Connections::messageConnections._ Rather than being parsed asconnectionEnds, _evt1_ and _evt2_ are

**392 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


parsed as inparameters, which are then, by the KerMLcheckFeatureParameterRedefinitionconstraint
(see [KerML, 8.4.4.7]), required to redefine the parameters _sourceEvent_ and _targetEvent_ from
_MessageConnection._ The payload declarationi : Iis parsed as a KerMLItemFeature(see [KerML,
8.4.4.10]) that is required by thecheckItemFeatureRedefinitionconstraint to redefine theFeature
_Transfers::Transfer::item_ (see [KerML, 9.2.7]; this is equivalent to redefining
_Connections::MessageConnection::payload_ ).
**abstract flow** // ItemFeaturem : M **subsets** Connections::messageConnections {
**ref** i : I **redefines** Transfers::Transfer::'item';
// parameters **inredefines** Connections::MessageConnection::sourceEvent
**inreferencesredefines** Connections::MessageConnection::targetEventevt1;
} **references** evt2;
Such aFlowConnectionUsageasserts that there is some _sourceEvent_ that occurs to initiate a flow and provide
the payload and some _targetEvent_ that occurs to accept the flow payload, but it does not constrain what the
actually connected _source_ and _target_ Features are. This allows for, e.g., the case in which the _sourceEvent_ is a
_SendAction_ and the _targetEvent_ is an _AcceptAction,_ but the connected _source_ and _target_ Features are
Ports(see also8.4.12on the semantics ofSendActionUsageandAcceptActionUsage).
A flow declaration of the form
**flow** f : F **of** i : I **from** src.src_out **to** tgt.tgt_in;
is parsed with twoItemFlowEnds(see [KerML, 8.3.4.9]) referencing _src_ and _tgt_ , with nested redefinitions of
_src_out_ and _tgt_in_ (as for a KerMLItemFlow[KerML, 8.4.4.10]), respectively. Since it hasItemFlowEnds,
thecheckFlowConnectionUsageSpecificationconstraint requires it to specialize
_Connections::flowConnections._ The KerMLcheckFeatureEndRedefinitionand
checkFeatureItemFlowFeatureRedefinitionconstraints then require both the redefinition of the end
Features(as for a regularConnectionUsage, see8.4.9.2) and the redefinition of thesourceOutputand
targetInputFeatures.
**flow** // ItemFeaturef : F **subsets** Connections::flowConnections {
**ref** i : I **redefines** Transfers::Transfer::'item';
// First ItemFlowEnd **endredefines** Connections::flowConnections::source **references** src {
} **redefines** Transfers::Transfer::source::sourceOutput, src_out;
// Second ItemFlowEnd **endredefines** Connections::flowConnections::target **references** tgt {
} **redefines** Transfers::Transfer::target::targetInput, tgt_in;
}
In this case, the _sourceEvent_ and _targetEvent_ parameters default to the starting and ending snapshots of the
FlowConnection, which are required to occur during the lifetime of the _source_ and _targetOccurrences,_
respectively.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 393**


Since aFlowConnectionUsageis a kind ofActionUsage, the
checkActionUsageSubactionSpecializationconstraint requires that aFlowConnectionUsagenested in an
ActionDefinitionorActionUsagespecialize _Actions::Action::subactions_ (see9.2.9.2.4) as well as
_Connections::flowConnections_ (see also8.4.12.2).
**action defaction** Aa1 : A1 **specializessubsets** Actions::Action {Actions::Action::subactions;
**actionflowsubsets** a2 : A2Connections::flowConnections, Actions::Action::subactions **subsets** Actions::Action::subactions;
} **from** a1.a1_out **to** a2.a2_in;
**8.4.9.7Succession Flow Connection Usage**
ASuccessionFlowConnectionUsageis a kind ofFlowConnectionUsageand a kind of KerML
SuccessionItemFlow. As such, all the general semantic constraints of aFlowConnectionUsage(see8.4.9.6)
and aSuccessionItemFlow(see [KerML, 8.4.4.10]) also apply to aSuccessionFlowConnectionUsage. A
SuccessionFlowConnectionUsageis semantically the same as aFlowConnectionUsage, except that the
checkSuccessionFlowConnectionUsageSpecializationconstraint requires that it specialize the
FlowConnectionUsage _Connections::successionFlowConnections_ (see9.2.6.2.10), which is defined by
theFlowConnectionDefinition _SuccessionFlowConnection_ (see9.2.6.2.9; see also8.4.9.5) and subsets the
FlowConnectionUsage _Connections::flowConnections_ (see9.2.6.2.6) and the kernelStep
_flowTransfersBefore_ (see [KerML, 9.2.7]). As a result, aSuccessionFlowConnectionUsagehas the
semantics of both a temporal succession from its _source_ to itself to its _target_ and a flow from the _source_ to the
_target._
Thus, a succession flow declaration of the form
**succession flowof** i : I **from** src.src_out **to** tgt.tgt_in;
is semantically equivalent, with impliedSpecializationsincluded, to:
**succession flow** // ItemFeature **subsets** Connections::successionFlowConnections {
**ref** i : I **redefines** Transfers::Transfer::'item';
// First ItemFlowEnd **endredefines** Connections::flowConnections::source **references** src {
} **redefines** Transfers::Transfer::source::sourceOutput, src_out;
// Second ItemFlowEnd **endredefines** Connections::flowConnections::target **references** tgt {
} **redefines** Transfers::Transfer::target::targetInput, tgt_in;
}

**8.4.10Interfaces Semantics**
_Abstract syntax reference:8.3.14_
**8.4.10.1Interface Definitions**
AnInterfaceDefinitionis a kind ofConnectionDefinitionwhoseconnectionEndsare syntactically
restricted to to bePortUsages. As such, all the general semantic constraints that apply to a

**394 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ConnectionDefinition(see8.4.9.1) also apply to anInterfaceDefinition, as well as the following
additional specialization constraints:

- checkInterfaceDefinitionSpecializationrequires that anInterfaceDefinitionspecialize
    the baseInterfaceDefinition _Interfaces::Interface_ (see9.2.7.2.3), which subclassifies the
    ConnectionDefinition _Connection::Connection_ (see9.2.6.2.3).
- checkInterfaceDefinitionBinarySpecializationrequires that anInterfaceDefinitionthat
    is binary specialize theInterfaceDefinition _Interfaces::BinaryInterface_ (see9.2.7.2.1),
    which subclassifies _Interfaces::Interface_ andtheConnectionDefinition
    _Connections::BinaryConnection_ (see9.2.6.2.1), redefining the _source_ and _target_ ends so that
    they arePortUsages.
**interfaceendportdef** p1I1 **subsetsspecializes** Links::Link::participant;Interfaces::Interface {
**endendportport** p2p3 **subsetssubsets** Links::Link::participant;Links::Link::participant;
} **interface def** I2 **specializes** Interfaces::BinaryInterface {
**endendportport** p1p2 **redefinesredefines** Interfaces::BinaryInterface::source;Interfaces::BinaryInterface::target;
}
**8.4.10.2Interface Usages**
AnInterfaceUsageis a kind ofConnectionUsagewhoseconnectionDefinitionsare syntactically
restricted to to be onlyInterfaceDefinitions. SinceInterfaceDefinitionshave ends that are
PortUsages, the ends of anInterfaceUsagemust also be ports. The general semantic constraints of a
ConnectionUsage(see8.4.9.2) also apply to anInterfaceUsage, as well as the following additional
specialization constraints:
- checkInterfaceUsageSpecializationrequires that anInterfaceUsagespecialize the base
InterfaceUsage _Interfaces::interfaces_ (see9.2.7.2.4), which is defined by the
InterfaceDefinition _Interfaces::Interface_ (see9.2.7.2.3) and subsets theConnectionUsage
_Connection::connections_ (see9.2.6.2.4).
- checkInterfaceDefinitionBinarySpecializationrequires that a binaryInterfaceUsage
specialize theInterfaceUsage _Interfaces::binaryInterfaces_ (see9.2.7.2.2), which is defined
by theInterfaceDefinition _Interfaces::BinaryInterface_ (see9.2.7.2.1) and subsets the
ConnectionUsage _Connections::binaryConnections_ (see9.2.6.2.2).
**interfaceendport** i1 : I1p1 **referencessubsets** Interfaces::interfaces {q1 **redefines** I1::e1;
**endendportport** p2p3 **referencesreferences** q2q3 **redefinesredefines** I1::e2;I1::e3;
} **interface** i2 : I2 **subsets** Interfaces::binaryInterfaces {
**endendportport** p1p2 **referencesreferences** q1q2 **redefinesredefines** I2::p1;I2::p2;
}
**partpart** def Pf1 : F1 **specializessubsets** Parts::Part {Items::Item::subparts;
**part** f2 : F2 **subsets** Items::Item::subparts;
// A nested InterfaceUsage also subsets subparts. **interface** b : B
**subsets** Interface::binaryInterfaces, Items::Items::subparts

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 395**


} **connects** f1.p1 **to** f2.p2;
**8.4.11Allocations Semantics**
_Abstract syntax reference:8.3.15_
**8.4.11.1Allocation Definitions**
AnAllocationDefinitionis a kind of binaryConnectionDefinition. The
checkAllocationDefinitionSpecializationconstraint requires that anAllocationDefinition
specialize the baseAllocationDefinition _Allocations::Allocation_ (see9.2.8.2.1), which subclassifies
theConnectionDefinition _Connection::BinaryConnection_ (see9.2.6.2.1). Otherwise, the semantics of an
AllocationDefinitionare the same as for a binaryConnectionDefinition(see8.4.9.1).
**allocation defend** e1 **redefines** A **specializes** Allocations::Allocation::source;Allocations::Allocation {
} **end** e2 **redefines** Allocations::Allocation::target;
**8.4.11.2Allocation Usages**
AnAllocationUsageis a kind of binaryConnectionUsagewhoseconnectionDefinitionsare syntactically
restricted to to be onlyAllocationDefinitions. ThecheckAllocationUsageSpecializationconstraint
requires that anAllocationUsagespecialize the baseAllocationUsage _Allocations::allocations_ (see
9.2.8.2.2), which is defined by theAllocationDefinition _Allocations::Allocation_ (see9.2.8.2.1) and
subsets theConnectionUsage _Connection::binaryConnections_ (see9.2.6.2.4) (see9.2.6.2.2). Otherwise,
the semantics of anAllocationUsageare the same as for aConnectionUsage(see8.4.9.2)
**allocationendref** a : Ae1 **referencessubsets** Allocations::allocations {f1 **redefines** A::e1;
**endref** e2 **references** f2 **redefines** A::e2;
// A nested AllocationUsage is a subpart. **allocation subsets** Allocations::allocations, Items::Item::subparts
} **allocate** e1.x **to** e2.y;

**8.4.12Actions Semantics**
_Abstract syntax reference:8.3.16_
**8.4.12.1Action Definitions**
AnActionDefinitionis a kind ofOccurrenceDefinitionand a kind of KerMLBehavior. As such, all the
general semantic constraints for anOccurrenceDefinition(see8.4.5) and aBehavior(see [KerML, 8.4.4.7.1])
also apply to anActionDefinition. In addition, thecheckActionDefinitionSpecializationconstraint
requires that anActionDefinitionspecialize the baseActionDefinition _Actions::Action_ (see9.2.9.2.4),
which subclassifies the kernelBehavior _Performances::Performance_ (see [KerML, 9.2.6]). Further, the
KerMLcheckFeatureParameterRedefinitionconstraint (see [KerML, 8.4.4.7.1]) requires that any owned
parameters(i.e., directedownedFeatures) of anActionDefinitionredefine correspondingparametersof
anyBehaviorsit specializes (including otherActionDefinitions).
**action definref** Ax[0..*] **specializessubsets** Actions::Action {Base::things;

**396 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**outinoutrefref** y[0..1]z **subsetssubsets** Base::things;Base::things;
} **action def** A1 **specializes** A {
**inoutrefref** x1[1]y1[1] **redefinesredefines** x;y;
} // z is inherited without redefinition
The _Action_ semantic model also includes additional features that collect various composite _subactions_ of an
_Action:_

- _subactions_ – All _subperformances_ of an _Action_ that are _Actions_ (see8.4.12.2).
- _transitions_ – The _subactions_ that are _TransitionActions_ (see8.4.12.3and8.4.13.3).
    ◦ _decisionTransitions_ – The _transitions_ that are _DecisionTransitionActions._
- _controls_ – The _subactions_ that are _ControlActions_ (see8.4.12.4).
    ◦ _merges_ – The _controls_ that are _MergeActions_.
    ◦ _decisions_ – The _controls_ that are _DecisionActions_.
    ◦ _joins_ – The _controls_ that are _JoinActions_.
    ◦ _forks_ – The _controls_ that are _ForkActions_.
- _sendSubactions_ – The _subactions_ that are _SendActions_ (see8.4.12.5).
- • _acceptSubactions_ – The _subactions_ that are _AcceptActions_ (see8.4.12.6).
- _assignments_ – The _subactions_ that are _AssignmentActions_ (see8.4.12.7).
- _ifSubactions_ – The _subactions_ that are _IfThenActions_ (see8.4.12.8).
- _loops_ – The _subactions_ that are _LoopActions_ (see8.4.12.9).
    ◦ _whileLoops_ – The _loops_ that are _WhileLoopActions_.
    ◦ _forLoops_ – The _loops_ that are _ForLoopActions._
**8.4.12.2Action Usages**
AnActionUsageis a kind ofOccurrenceUsageand a kind of KerMLStep. As such, all the general semantic
constraints for anOccurrenceUsage(see8.4.5) and aStep(see [KerML, 8.4.4.7.2]) also apply to an
ActionUsage, as well as the following additional specialization constraints:
- checkActionUsageSpecializationrequires that anActionUsagespecialize the baseActionUsage
_Actions::actions_ (see9.2.9.2.5), which is defined by theActionDefinition _Actions::Action_
(see9.2.9.2.4) and subsets the kernelStep _Performances::performances_ (see [KerML, 9.2.6]).
Further, the KerMLcheckFeatureParameterRedefinitionconstraint requires that any owned
parameters(i.e., directedownedFeatures) of aActionUsageredefine correspondingparametersof
anyBehaviorsorStepsit specializes (includingActionDefinitionsandActionUsages).
**actionin** a : A **ref** x **subsetsredefines** Actions::actions {A::x = x1;
**outinoutrefref** y **redefines** z **redefines** A::y;A::z := z1 ;
}
**actionin** a1 : A1 **ref** x **redefinessubsets** a {A1::x, a::x;
} **outref** y **redefines** A2::y, a::y;
- checkActionUsageSubactionSpecializationrequires that anActionUsagethat is composite, has
anowningTypethat is anActionDefinitionorActionUsage, and is _not_ theentryActionor
exitActionof aStateDefinitionorStateUsage(see8.4.13) specialize theActionUsage

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 397**


```
Actions::Action::subactions (see9.2.9.2.4), which subsets the kernelStep
Performances::Performance::subperformances (see [KerML, 9.2.6]). Note also that, in other
cases, the general KerMLcheckStepEnclosedPerformanceSpecializationand
checkStepSubperformanceSpecializationconstraints will still apply (see [KerML, 8.4.4.7]).
actionactiondef Actact1 subsetssubsets Actions::Action {Actions::Action::subactions;
refaction Performances::Performance::enclosedPerformances;act2 subsets Actions::actions,
}
```
- checkActionUsageOwnedActionSpecializationrequires that a compositeActionUsagewhose
    owningTypeis aPartDefinitionor aPartUsagespecialize theActionUsage
    _Parts::Part::ownedActions_ (see9.2.4.2.1), which subsets theActionUsage _Action::actions_
    and the kernelFeature _Objects::Object::ownedPerformances_ (see [KerML, 9.2.5]). Note also
    that, in other cases, the general KerMLcheckStepOwnedPerformanceSpecializationconstraint
    will still apply (see [KerML, 8.4.4.7]).
**part defaction** PAa : A **specializessubsets** Parts::Part {Parts::Part::ownedActions;
} **item def** IA **specializes** Items::Item {
} **action** a : A **subsets** Objects::Object::ownedPerformances;
- checkActionUsageStateActionRedefinitionrequires that anActionUsagethat is an
    entryAction,exitActionordoActionof aStateDefinitionorStateUsagespecialize,
    respectively, the _entryAction,exitAction_ , or _doAction_ featureof theStateDefinition
    _States::StateAction_ (see9.2.10.2.1), which redefine the _entry,exit,_ and _do_ featuresof the
    kernelBehavior _StatePerformances::StatePerformance_ (see [KerML, 9.2.6]), restricting them to
    be _Actions_ (see9.2.9.2.4). (See also8.4.13on State Semantics.)
- checkActionUsageAnalysisActionSpecializationrequires that anActionUsagethat is an
    analysisActionof anAnalysisCaseDefinitionorAnalysisCaseUsagespecialize the
    ActionUsage _Actions::Action::analysisSteps_ (see9.2.9.2.4). (See also8.4.18on Analysis Case
    Semantics.)
**Semantics of** **_this_**
_Action_ inherits the kernelFeature _Occurrences::Occurrence::this_ (see [KerML, 9.2.4]). The value for
thisFeatureis determined in by the semantic model for _Object::Object_ (see [KerML, 9.2.5]) and
_Performances::Performance_ (see [KerML, 9.2.6]), as further specialized for _Parts::Part::ownedActions_
(see9.2.4.2.1) and _Actions::Action::subactions_ (see9.2.9.2.4). For an _Action_ in a hierarchy of
_subactions,_ the value of _this_ is the top-level _Action_ in the hierarchy (that is, one that is not one of the
_subactions_ of any other _Action_ ), unless that top-level _Action_ is itself one of the _ownedActions_ of a _Part_ (or
on of the _ownedPerformances_ of an _Item_ ), in which case the value is that _Part_ (or _Item_ ).
For example, consider the model
**packageaction def** Pkg { A **specializes** Actions::Action {
} **action** b **subsets** Actions::Action::subactions;
**action** // a1.this == a1a1 : A[1] **subsets** Action::actions {
// b.x == a1

**398 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


} **part** p **subsets** Parts::parts {
**action** // a2.this == pa2: A[1] **subsets** Parts::Part::ownedActions {
} // b.this == p
} }
As indicated, the value of _this_ for both the _Actiona1_ and its _subactiona1.b_ will be (the value of) _a1_ , since the
ActionUsage _a1_ is at "package level", while the value of _this_ for both _p.a2_ and _p.a2.b_ will be (the value of) _p,_
since _a2_ is an _ownedAction_ of _p._
The semantics of _this_ are particularly important in the specification of default semantics forSendActionUsages
(see8.4.12.5) andAcceptActionUsages(see8.4.12.6).
**8.4.12.3Decision Transition Usages**
ASuccessionin the body of anActionDefinitionorActionUsagemay be syntactically declared with a
guardExpression. In this case, it is actually parsed as aTransitionUsage, with the guardExpressionand the
declaredSuccessionnested in theTransitionUsage(see8.2.2.16.7). The
checkTransitionUsageActionSpecializationconstraint requires that a compositeTransitionUsage
whoseownedTypeis anActionDefinitionorActionUsage, but _not_ aStateDefinitionorStateUsage,
specialize theActionUsage _Actions::Action::decisionTransitions_ (see9.2.9.2.4), which is typed by the
ActionDefinition _Actions::DecisionTransitionAction_ (see9.2.9.2.10). _DecisionTransitionAction_
subclassifies theActionDefinition _Actions::TransitionAction_ (see9.2.9.2.24) and the kernelBehavior
_TransitionPerformances::NonStateTransitionPerformance_ (see [KerML, 9.2.10]). It represents a
_TransitionAction_ that has a _guard_ , but no _accepter_ or _effects_.
For example, consider the following model of a conditionalSuccessionbetween toActionUsages:
**action defaction** AC {a1 { **out ref** test : ScalarValues::Boolean; }
**successionaction** a2; sc **first** a1 **if** a1.test **then** a2;
}
With impliedRelationshipsincluded (see8.2.2.17.3on the semantic constraints related to a
TransitionUsage), this has the equivalent kernel semantics of:
// KerML **behavior** AC **specializes** Actions::Action {
**stepout feature** a1 **subsets** Actions::Action::subactions {test : ScalarValues::Boolean;
}
**stepin feature redefines** sc **subsets** Actions::Action::decisionTransitions {
Actions::TransitionAction::transitionLinkSource;
**bool redefines** a1.test Actions::TransitionAction::guard {
}
**membersubsetssuccession** Occurrences::happensBeforeLinkssc_link

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 399**


```
featured byfirst a1 then ACa2;
member TransitionPerformances::TransitionPerformance::transitionLink; bindingfeatured by AC of sc_link =
```
} **member binding featured by** AC **of** s1 = transitionLinkSource;
} **step** a2 **subsets** Actions::Action::subactions;
As specified for a _NonStateTransitionPerformance_ , the _guard_ of a _DecisionTransitionAction_ is
evaluated after the completion of the _Performance_ of the _transitionLinkSource_ , which is thesourceof the
nested _transitionLink_ Succession. If the _guard_ evaluates to true, then the _transitionLink_ may have a
value, meaning that there must be a _Performance_ of thetargetFeatureof theSuccessiontemporally
following the _Performance_ of thesourceFeature. If the _guard_ evaluates to false, the _transitionLink_ does
not have a value, so no such temporal ordering is asserted.
**8.4.12.4Control Nodes**
AControlNodeis a kind ofActionUsagethat has no inherent behavior but is used to control other _Actions_
within a containing _Action_. All the general semantic constraints of anActionUsage(see8.4.12.2) also apply to a
ControlNode, as well as the following additional constraints:

- checkControlNodeSpecializationrequires that aControlNodespecialize theActionUsage
    _Actions::Action::controls_ (see9.2.9.2.4), which is defined by theActionDefinition
    _Actions::ControlAction_ (see9.2.9.2.8) and subsets the compositeActionUsage
    _Actions::Action::subactions_ (further implying that aControlNodemust be composite).
    _ControlAction_ includes a constraint that it's performance is instantaneous.
- validateControlNodeOwningTyperequires that theowningTypeof aControlNodebe an
    ActionDefinitionorActionUsage.
- validateControlNodeIncomingSuccessionsrequires that all incomingSuccessionsto a
    ControlNodehave targetmultiplicity1..1.
- validateControlNodeOutgoingSuccessionsrequires that all outgoingSuccessionsfrom a
    ControlNodehave sourcemultiplicity1..1.
**Note.** Multiplicities are given in a model asMultiplicityRangeswhich haveExpressionsforlowerBound
andupperBound. When checking validation constraints such as the above onMultiplicityRanges, the
lowerBoundandupperBoundExpressionsshall be _model-level evaluable_ to the required values for the bounds
(see [KerML, 8.4.4.9]). If thelowerBoundis empty, then anupperBoundvalue of 1 is equivalent to multiplicity
1..1. The constraints can also be equivalently satisfied bymultiplicitiesthat subset the
MultiplicityRanges _ExactlyOne_ or _ZeroOrOne_ from the Kernel Semantic Library model _Base_ (see [KerML,
9.2.2]).
TheControlNodemetaclass is itself abstract, but it has four concrete subclasses representing various specific
ControlNodeelements. Each of these places additional constraints on incoming and outgoingSuccessions, as
appropriate to achieve the specific control constraints required for each kind of element.
**Join Nodes**
AJoinNodeis a kind ofControlNodethat represents the joining of control. The following additional constraints
apply to aJoinNode:

**400 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


- checkJoinNodeSpecializationrequires that aJoinNodespecialize theActionUsage
    _Actions::Action::joins_ (see9.2.9.2.4), which is defined by theActionDefinition
    _Actions::JoinAction_ (see9.2.9.2.21) and subsets _Actions::Action::controls.JoinAction_
    subclassifies _ControlAction_.
- validateJoinNodeOutgoingSuccessionsrequires that aJoinNodehave at most one outgoing
    Succession.
- validateJoinNodeIncomingSuccessionsconstraint requires that all incomingSuccessionsto a
    JoinNodehave sourcemultiplicity1..1.
The semantics of aJoinNodeare entirely a result of the above constraints. Because of the required
multiplicities, for each performance of aJoinNode, every incomingSuccessionmust have a value,
temporally ordering theJoinNodeas happening after all the source _Occurrences_ (typically _Actions_ ) of the
incomingSuccessions.
For example, consider the following model of aJoinNodewith two incomingSuccessionsand one outgoing
Succession, explicitly showing the requiredSuccessionmultiplicities:
**actionactiondef** A1 {a1;
**action** a2;
**successionsuccession** s1s2 **firstfirst** a1[1..1]a2[1..1] **thenthen** j[1..1];j[1..1];
**joinsuccession** j; s3 **first** j[1..1] **then** a3;

} **action** a3;
With impliedSpecializationsincluded, this is semantically equivalent to:
**actionactiondef** A1a1 **specializessubsets** Actions::Action::subactions;Actions::Action {
**action** a2 **subsets** Actions::Action::subactions;
**successionfirst** a1[1..1]s1 **subsetsthen** Occurrences::happensBeforeLinksm[1..1];
**successionfirst** a2[1..1]s2 **subsetsthen** Occurrences::happensBeforeLinksm[1..1];
**joinsuccession** j **subsets** s3 **subsets** Actions::Action::joins;Occurrences::happensBeforeLinks
**first** j[1..1] **then** a3;
} **action** a3 **subsets** Actions::Action::subactions;
**Fork Nodes**
AForkNodeis a kind ofControlNodethat represents a forking of control.The following additional constraints
apply to aForkNode:

- checkForkNodeSpecializationrequires that aForkNodespecialize theActionUsage
    _Actions::Action::forks_ (see9.2.9.2.4), which is defined by theActionDefinition
    _Actions::ForkAction_ (see9.2.9.2.21) and subsets _Actions::Action::controls.ForkAction_
    subclassifies _ControlAction_.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 401**


- validateForkNodeIncomingSuccessionsrequires that aForkNodehave at most one incoming
    Succession.
- validateForkNodeOutgoingSuccessionsrequires that all outgoingSuccessionsfrom a
    ForkNodehave targetmultiplicity1..1.
The semantics of aForkNodeare entirely a result of the above constraints. Because of the required multiplicities,
for each performance of aForkNode, every outgoingSuccessionmust have a value, temporally ordering the
ForkNodeas happening before all the target _Occurrences_ (typically _Actions_ ) of the outcomingSuccessions.
For example, consider the following model of aForkNodewith two incomingSuccessionsand one outgoing
Succession, explicitly showing the requiredSuccessionmultiplicities:
**actionactiondef** A2 {a1;
**successionfork** f; s1 **first** a1 **then** f[1..1];
**successionsuccession** s2s3 **firstfirst** f[1..1]f[1..1] **thenthen** a2[1..1];a3[1..1];
**actionaction** a2;a3;
}
With impliedSpecializationsincluded, this is semantically equivalent to:
**actionactiondef** A2a1 **specializessubsets** Actions::Action::subactions;Actions::Action {
**successionfirst** a1s1 **thensubsets** f[1..1];Occurrences::happensBeforeLinks
**forksuccession** f **subsets** s2 **subsets** Actions::Action::forks;Occurrences::happensBeforeLinks
**successionfirst** f[1..1]s3 **subsetsthen** Occurrences::happensBeforeLinksa2[1..1];
**first** f[1..1] **then** a3[0..1];
**actionaction** a2a3 **subsetssubsets** Actions::Action::subactions;Actions::Action::subactions;
}
**Merge Nodes**
AMergeNodeis a kind ofControlNodethat represents the merging of control. The following additional
constraints apply to aMergeNode.
- checkMergeNodeSpecializationconstraint requires that aMergeNodespecialize theActionUsage
_Actions::Action::merges_ (see9.2.9.2.4), which is defined by theActionDefinition
_Actions::MergeAction_ (see9.2.9.2.21) and subsets _Actions::Action::controls.MergeAction_
subclassifies _ControlAction_ and the kernelBehavior
_ControlPerformances::MergePerformance_ (see [KerML, 9.2.9]).
- checkMergeNodeIncomingSuccessionSpecializationrequires that any incomingSuccessionto
aMergeNodespecialize theFeature _MergePerformance::incomingHBLink_ (which is inherited by
_MergeAction_ ).
- validateMergeNodeOutgoingSuccessionsrequires that aMergeNodehave at most one outgoing
Succession.

**402 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


- validateMergeNodeIncomingSuccessionsrequires that all incomingSuccessionsto a
    MergeNodehave sourcemultiplicity0..1.
Since _MergePerformance::incomingHBLink_ has a multiplicity of 1 , the result of the above constraints is that,
for any performance of a _MergeAction_ ,there must be exactly one incomingSuccessionthat has a value,
representing the incoming "control" that triggers this specific performance of the _MergeAction_.
For example, consider the following model of aMergeNodewith two incomingSuccessionsand one outgoing
Succession, explicitly showing the requiredSuccessionmultiplicities:
**actionactiondef** A3 {a1;
**action** a2;
**successionsuccession** s1s2 **firstfirst** a1[0..1]a2[0..1] **thenthen** m[1..1];m[1..1];
**mergesuccession** m; s3 **first** m[1..1] **then** a3;

} **action** a3;
With impliedSpecializationsincluded, this is semantically equivalent to:
**actionactiondef** A3a1 **specializessubsets** Actions::Action::subactions;Actions::Action {
**action** a2 **subsets** Actions::Action::subactions;
**successionsubsets** s1m.incomingHBLink **subsets** Occurrences::happensBeforeLinks
**successionfirst** a1[0..1]s2 **subsetsthen** Occurrences::happensBeforeLinksm[1..1];
**subsetsfirst** a2[0..1]m.incomingHBLink **then** m[1..1];
**merge** // m inherits the following feature from MergePerformance:m **subsets** Actions::Action::merges{
} // incomingHBLink : HappensBefore[1];
**successionfirst** m[1..1]s3 **subsetsthen** Occurrences::happensBeforeLinksa3;

} **action** a3 **subsets** Actions::Action::subactions;
**Decision Nodes**
ADecisionNodeis a kind ofControlNodethat represents a control decision. The following additional
constraints apply to aDecisionNode:

- checkDecisionNodeSpecializationrequires that aDecisionNodespecialize theActionUsage
    _Actions::Action::decisions_ (see9.2.9.2.4), which is defined by theActionDefinition
    _Actions::DecisionAction_ (see9.2.9.2.21) and subsets _Actions::Action::controls._
    _DecisionAction_ subclassifies _ControlAction_ and the kernelBehavior
    _ControlPerformances::DecisionPerformance_ (see [KerML, 9.2.9]).
- checkDecisionNodeOutgoingSuccessionSpecializationrequires that any incoming
    Successionto aMergeNodespecialize theFeature _DecisionPerformance::outgoingHBLink_
    (which is inherited by _DecisionAction_ ).

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 403**


- validateDecisionNodeIncomingSuccessionsrequires that aDecisionNodehave at most one
    incomingSuccession.
- validateDecisionNodeOutcomingSuccessionsconstraint requires that all outgoingSuccessions
    from aDecisionNodehave targetmultiplicity0..1.
Since _DecisionPerformance::outgoingHBLink_ has a multiplicity of 1 , the result of these constraints is that,
for any performance of a _DecisionAction_ ,there must be exactly one outgoingSuccessionthat has a value,
representing the outgoing "control" decided on by this specific performance of the _DecisionAction_.
For example, consider the following model of aDecisionNodewith one incomingSuccessionsand two
outgoingSuccessions, explicitly showing the requiredSuccessionmultiplicities:
**actionactiondef** A4 {a1;
**successiondecide** d; s1 **first** a1 **then** d[1..1];
**successionsuccession** s2s3 **firstfirst** d[1..1]d[1..1] **thenthen** a2[0..1];a3[0..1];
**actionaction** a2;a3;
}
With impliedSpecializationsincluded, this is semantically equivalent to:
**actionactiondef** A4a1 **specializessubsets** Actions::Action::subactions;Actions::Action {
**successionfirst** a1[0..1]s1 **subsetsthen** Occurrences::happensBeforeLinksd[1..1];
**decide** // d inherits the following feature from DecisionPerformance:d **subsets** Actions::Action::decisions {
} // outgoingHBLink : HappensBefore[1];
**successionsubsets** s2d.outgoingHBLink **subsets** Occurrences::happensBeforeLinks
**successionfirst** d[1..1]s3 **subsetsthen** Occurrences::happensBeforeLinksa2[0..1];
**subsetsfirst** d[1..1]d.outgoingHBLink **then** a3[0..1];
**actionaction** a2a3 **subsetssubsets** Actions::Action::subactions;Actions::Action::subactions;
}
The semantics of aDecisionNodedo not determine which of the outgoingSuccessionswill have a value for any
specific performance of theDecisionNode. However, the outgoingSuccessionsof aDecisionNodewill
typically have guard conditions, in which case only theSuccession(s)for which the guard is true may have
values.
**actionactiondef** A5 {a1 { **out ref** x : ScalarValues::Integer; }
**successiondecide** d; s1 **first** a1 **then** d[1..1];
**succession** s2 **first** d[1..1] **if** x < 0 **then** a2[0..1];

**404 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**succession** s3 **first** d[1..1] **if** x >= 0 **then** a3[0..1];
**actionaction** a2;a3;
}
Such _conditional_ Successionsare actually parsed asTransitionUsagesdefined by theActionDefinition
_DecisionTransitionAction_ (see8.2.2.16.7), with a nestedSuccession. It is this nestedSuccessionthat
actually has theDecisionNodeas its source, and, therefore, to which the
validateDecisionNodeOutcomingSuccessionsconstraint applies. See8.4.12.3on the semantics of decision
TransitionUsages.
**8.4.12.5Send Action Usages**
ASendActionUsageis a kind ofActionUsage, so all general semantic constraints for anActionUsage(see
8.4.12.2) also apply to aSendActionUsage, as well as the following additional specialization constraints:

- checkSendActionUsageSpecializationrequires that aSendActionUsagespecialize the
    ActionUsage _Actions::sendActions_ (see9.2.9.2.23), which is defined by theActionDefinition
    _Actions::SendAction_ (see9.2.9.2.22) and subsets theActionUsage _Actions::actions_ (see
    9.2.9.2.5) and the kernelFeature _Transfers::sendPerformances_ (see [KerML, 9.2.7]).
- checkSendActionUsageSubactionSpecializationconstraint requires that aSendActionUsage
    that is composite, has anowningTypethat is anActionDefinitionorActionUsage, and is _not_ the
    entryActionorexitActionof aStateDefinitionorStateUsage(see8.4.13) specialize the
    ActionUsage _Actions::Action::sendSubactions_ (see9.2.9.2.4), which subsets
    _Actions::sendActions_ and _Actions::Action::subactions_.
ASendActionUsageprovides arguments for theparametersof a _SendAction._ ASendActionUsage
declaration of the form
**action** snd **send** p **via** src **to** tgt;
(where all of _p,src_ and _tgt_ areExpressions) is parsed (including impliedSpecializations) as (see
8.2.2.16.4):
**actionin** s **refsubsetsredefines** Actions::sendActions {Actions::SendAction::payload = p;
**in refin refredefinesredefines** Actions::SendAction::sender = src;Actions::SendAction::receiver = tgt;
}
_SendAction_ subclassifies theActionDefinition _Actions::Action_ (see9.2.9.2.4) and the kernelBehavior
_Transfers::SendPerformance_ (see [KerML, 9.2.7]). The semantics of _SendPerformance_ is to initiate a
_sentMessage,_ which is a _MessageTransfer_ (for a _SendAction,_ this will also be a _MessageConnection,_ see
9.2.6.2.7) from a given _sender_. The _SendAction::payload_ parameter(which redefines
_SendPerformance::sentItems_ ) provides the values that are transferred.
If given, the _receiver_ parameterspecifies the _target_ of the _sentMessage._ Thisparameteris optional. If no
_receiver_ is given, then the _target_ of the _sentMessage_ is unspecified by the _SendAction,_ and must be
determined from other constraints in the model. (For example, if the _SendAction_ has aPortUsageas its _sender,_
then the _target_ of the _sentMessage_ may be determined by aInterfaceUsageoutgoing from thatPortUsage.)

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 405**


The _sender_ parameteris mandatory. However, if no explicit value is given for thisparameter, it defaults to the
value of _this_ for the _SendAction_ (see8.4.12.2on the semantics of _this_ for _Actions_ in general). This is
particularly important when the _SendAction_ is nested in other containing _Actions_ or _Parts._
For example, consider aSendActionUsagewith no declared _sender_ nested in anActionDefinition:
**action defaction** AS {snd **send** p **to** tgt;
}
This is equivalent to
**actionactiondef** ASsnd **specializessubsets** Actions::Action::sendSubactions {Actions::Action {
**inin refref redefinesredefines** payload = p;sender = this;
} **in ref redefines** receiver = tgt;
}
Therefore, in the model
**packageaction** Sending {as1 : AS[1] **subsets** Action::actions {
} // snd.sender == as1
**partaction** p **subsets** as2: AS[1]Parts::parts { **subsets** Parts::Part::ownedActions {
} // snd.sender == p
} }
the default _sender_ for _as1.snd_ is _as1,_ but the default _sender_ for _p.as2.snd_ is _p._
**8.4.12.6Accept Action Usages**
AnAcceptActionUsageis a kind ofActionUsage, so all general semantic constraints for anActionUsage(see
8.4.12.2) also apply to anAcceptActionUsage, as well as the following additional specialization constraints:

- checkAcceptActionUsageSpecializationrequires that (unless it is thetriggerActionof a
    TransitionUsage, see8.4.13.3) anAcceptActionUsagespecialize theActionUsage
    _Actions::acceptActions_ (see9.2.9.2.2), which is defined by theActionDefinition
    _Actions::AcceptAction_ (see9.2.9.2.1) and subsets _Actions::Action::actions_ (see9.2.9.2.5)
    and the kernelFeature _Transfers::acceptPerformances_ (see [KerML, 9.2.7]).
- checkAcceptActionUsageSubactionSpecializationrequires that anAcceptActionUsagethat
    is composite, has anowningTypethat is anActionDefinitionorActionUsage, and is _not_ the
    triggerActionof aTransitionUsageor theentryActionorexitActionof aStateDefinition
    orStateUsage(see8.4.13) specialize theActionUsage _Actions::Action::acceptSubactions_
    (see9.2.9.2.4), which subsets _Actions::acceptActions_ and _Actions::Action::subactions_.
AnAcceptActionUsageprovides anargumentfor the inputparameter _receiver_ of an _AcceptAction_ and
declares what can be accepted in the outputparameter _payload._ AnAcceptActionUsagedeclaration of the
form
**action** acpt **accept** x : T **via** tgt;

**406 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


(where _src_ and _tgt_ areExpressions) is parsed (including impliedSpecializations) as (see8.2.2.16.4):
**actioninout** acpt **refsubsets** x : TActions::acceptActions { **redefines** Actions::AcceptAction::payload;
} **in refredefines** Actions::AcceptAction::receiver = tgt;
_AcceptAction_ subclassifies theActionDefinition _Actions::AcceptMessageAction_ (see9.2.9.2.3), which
itself subclassifies _Actions::Action_ (see9.2.9.2.4) and the kernelBehavior
_Transfers::AcceptPerformance_ (see [KerML, 9.2.7]). The semantics of _AcceptPerformance_ is to select an
_incomingTransfer_ of the given _receiverOccurrence_ that is a _MessageTransfer_ and whose transferred
values conform to its _acceptedItem_ parameter, as redefined in theAcceptActionUsage
( _AcceptAction::payload_ itself redefines _AcceptPerformance::acceptedItem_ ). _AcceptAction_ has a
nestedStateActionUsage, such that, when the _AcceptAction_ is performed, it waits for the acceptance of a
conforming _MessageTransfer,_ and then completes if and when such a _MessageTransfer_ is eventually accepted.
If so, then the transferred values of the _acceptedMessage_ are placed on the _payload_ outputparameter.
The _receiver_ parameteris mandatory. However, if no explicit value is given for thisparameter, it defaults to
the value of _this_ for the _AcceptAction_ (see8.4.12.2on the semantics of _this_ for _Actions_ in general). This is
particularly important when the _AcceptAction_ is nested in other containing _Actions_ or _Parts._
For example, consider anAcceptActionUsagewith no declared _receiver_ nested in anActionDefinition:
**action defaction** AA {acpt **accept** x : T;
}
This is equivalent to
**actionactiondef** AAacpt **specializessubsets** Actions::Action::acceptSubactions {Actions::Action {
**inoutin refrefredefines** x : T **redefines** Actions::AcceptAction::receiver = this;Actions::AcceptAction::payload;
} }
Therefore, in the model
**packageaction** Accepting {aa1 : AA[1] **subsets** Action::actions {
} // acpt.receiver == aa1
**partaction** p **subsets** aa2: AA[1]Parts::parts { **subsets** Parts::Part::ownedActions {
} // acpt.receiver == p
} }
the default _receiver_ for _aa1.acpt_ is _aa1,_ but the default _receiver_ for _p.aa2.accept_ is _p._
Note also that the _AcceptAction::payload_ parameteractually hasdirection **inout** , which means that an
input value may be optionally provided for it. If athe _payload_ parameterhas aFeatureValueRelationship
to avalueExpression, then any _acceptedMessage_ must have values that match the result of thevalue
Expressionbound to the _payload_ parameter. This is used, in particular, to provide the semantics for
TriggerInvocationExpressionsas used inAcceptActionUsages.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 407**


ATriggerInvocationExpression(see8.3.16.16) is a kind of KerMLInvocationExpression(see [KerML,
8.3.4.8]), with the corresponding semantics (see [KerML, 8.4.4.9]). The
checkTriggerInvocationExpressionSpecializationconstraint requires that a
TriggerInvocationExpressionspecialize (invoke) one of theFunctions _TriggerWhen,TriggerAt_ or
_TriggerAfter,_ from the Kernel Semantic Library _Triggers_ package (see [KerML, 9.2.14]), depending on
whether itskindiswhen,atorafter(seeTriggerKind,8.3.16.17), respectively. AnAcceptActionUsage
with a change ( **when** ), absolute time ( **at** ) or relative time ( **after** ) trigger is parsed as having its _payload_
parameterbound to aTriggerInvocationExpressionof the correspondingkind.
So, the following:
**action defaction** AT {acpt_when **accept when** boolean_expr;
**actionaction** acpt_atacpt_after **accept ataccept after** time_expr;duration_expr;
}
is equivalent to:
**actionactiondef** ATacpt_when **specializessubsets** Actions::Action {Actions::Action:acceptSubactions {
**in ref redefines** Triggers::TriggerWhen({ boolean_expr }, receiver);Actions::AcceptAction::payload =
} **in ref redefines** Actions::AcceptAction::receiver = this;
**actionin ref redefines** acpt_at **subsets** Actions::AcceptAction::payload =Actions::Action:acceptSubactions {
**in ref redefines** Triggers::TriggerAt(time_expr, receiver);Actions::AcceptAction::receiver = this;
} **action** acpt_after **subsets** Actions::Action:acceptSubactions {
**in ref redefines** Triggers::TriggerAfter(duration_expr, receiver);Actions::AcceptAction::payload =
} **in ref redefines** Actions::AcceptAction::receiver = this;
}
Note that thecheckAcceptActionUsageReceiverBindingConnectorconstraint requires that the second
parameterof aTriggerInvocationExpressionbe bound to the _receiver_ parameterof the containing
AcceptActionUsage, indicating that it is theAcceptActionUsage _receiver_ that is to be signaled by the
trigger. Each of the _Triggers_ Functionsalso has two additionalparameters, which all get their default values.

1. _clock_ , typed by _Clocks::Clock_ (see [KerML, 9.2.12]), defaults to
    _Occurrences::Occurrence::localClock_ (see [KerML, 9.2.4]).
2. _monitor,_ typed by _Observation::ChangeMonitor_ (see [KerML, 9.2.13]), defaults to
    _Observation::defaultMonitor._
In particular, the _Occurrences::Occurrence::localClock_ itself defaults to the singleton _universalClock_
(see9.8.8.2.13and [KerML, 9.2.12]). However, for a _suboccurrence,_ this default is overridden to instead be the
_localClock_ of the containing _Occurrence._ This means that binding the _localClock_ featureto a new _Clock_
instance in anOccurrenceDefinitionorOccurrenceUsage(particularly aPartDefinitionorPartUsage)
means that this _Clock_ instance will be used as the default for all contained _suboccurrences_ (particularly
_ownedActions_ and _subactions_ ) at any level of nesting in the composition hierarchy (unless it is further
overridden at some lower level).

**408 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**part defrefredefines** TimeContextlocalClock = Time::Clock(); **specializes** Parts::Part {
**action** // Uses the value bound to TimeContext::localClock,behavior **subsets** Parts::Part::ownedActions {
// not the default universalClock. **action subsets** Actions::Action::acceptSubactions
} **accept after** 30 [SI::s];
}
**8.4.12.7Assignment Action Usages**
AnAssignmentActionUsageis a kind ofActionUsage, so all general semantic constraints for anActionUsage
(see8.4.12.2) also apply to anAssignmentActionUsage, as well as the following additional specialization
constraints:

- checkAssignmentActionUsageSpecializationrequires that anAssignmentActionUsage
    specialize theActionUsage _Actions::assignmentActions_ (see9.2.9.2.7), which is defined by the
    ActionDefinition _Actions::AssignmentAction_ (see9.2.9.2.6) and subsets
    _Actions::Action::actions_ (see9.2.9.2.5).
- checkAssignmentActionUsageSubactionSpecializationconstraint requires that an
    AssignmentActionUsagethat is composite, has anowningTypethat is anActionDefinitionor
    ActionUsage, and is _not_ theentryActionorexitActionof aStateDefinitionorStateUsage
    (see8.4.13) specialize theActionUsage _Actions::Action::assignments_ (see9.2.9.2.4), which
    subsets _Actions::assignmentActions_ and _Actions::Action::subactions_.
AnAssignmentActionUsagehas two inputparametersfor the _target_ Occurrenceand the
_replacementValues_ to be assigned. The _target_ has a time slice called _startingAt_ with a nested feature called
_accessedFeature._ ThereferentFeatureto be assigned by theAssignmentActionUsageis actually parsed
as an alias member of theAssignmentActionUsage(see8.2.2.16.4). The following constraints then apply:
- checkAssignmentActionUsageStartingAtRedefinitionrequires that the firstownedFeatureof
the firstparameterof anAssignmentActionUsage(the _target_ parameter) redefines
_Actions::AssignmentAction::target::startingAt._
- checkAssignmentActionUsageAccessedFeatureRedefinitionrequires that the first
ownedFeatureof the above redefinition ofstartingAtredefines
_Actions::AssignmentAction::target::startingAt::accessedFeature._
- checkAssignmentActionReferentRedefinitionrequires that
_target.startingAt.accessedFeature_ of theAssignmentActionUsageredefine thereferent
Feature.
AnAssignmentActionUsagedeclaration of the form
**action** asgn **assign** tgt.rfnt := val;
(where _tgt_ and _val_ areExpressionsand _rfnt_ is a qualified name or feature chain) is parsed (including implied
Specializations) as
**actionin** asgn **refredefinessubsets** Actions::assignmentActions {Actions::AssignmentAction::target = tgt {
**redefinesredefines** Actions::AssignmentAction::target::startingAt {Actions::AssignmentAction::target::startingAt::accessedFeature,
} rfnt;
}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 409**


} **inout refredefines** Actions::AssignmentAction::replacementValues = val;
_AssignmentAction_ subclassifies the _Actions::Action_ (see9.2.9.2.4) and the kernelBehavior
_ControlPerformances::FeatureWritePerformance_ (see [KerML, 9.2.9]). The semantics of
_FeatureWritePerformance_ is that, at the time it ends, the _accessedFeature_ of the _target_ Occurrencewill
have the given _replacementValues._
**8.4.12.8If Action Usages**
AnIfActionUsageis a kind ofActionUsage, so all general semantic constraints for anActionUsage(see
8.4.12.2) also apply to anIfActionUsage, as well as the following additional specialization constraints:

- checkIfActionUsageSpecializationrequires that
    ◦ If anIfActionUsagedoes _not_ have anelseAction, it specialize theActionUsage
       _Actions::ifThenActions_ (see9.2.9.2.15), which is defined by theActionDefinition
       _Actions::IfThenAction_ (see9.2.9.2.14) and subsets _Actions::Action::actions_ (see
       9.2.9.2.5).
    ◦ If theIfActionUsagehas anelseAction, it specialize theActionUsage
       _Actions::ifThenElseActions_ (see9.2.9.2.17), which is defined by the
       ActionDefinition _Actions::IfThenElseAction_ (see9.2.9.2.14) and subsets
       _Actions::Action::actions_ (see9.2.9.2.5).
- checkIfActionUsageSubactionSpecializationconstraint requires that anIfActionUsagethat is
    composite, has anowningTypethat is anActionDefinitionorActionUsage, and is _not_ the
    entryActionorexitActionof aStateDefinitionorStateUsage(see8.4.13) specialize the
    ActionUsage _Actions::Action::ifSubactions_ (see9.2.9.2.4), which subsets
    _Actions::ifThenActions_ and _Actions::Action::subactions_.
TheActionDefinition _IfThenAction_ has two inputparameters: _ifTest,_ which is a _BooleanEvaluation,_
and _thenClause,_ which is an _Action.IfThenElseAction_ specializes _IfThenAction,_ adding a third input
parameter: _elseClause,_ which is also an _Action._ TheifArgument,thenActionand (optionally)
elseActionof anIfActionUsageare then parsed asparametersof theIfActionUsagethat redefine the
corresponding parameters of the _IfThenAction_ or _IfThenElseAction_.
Thus,IfActionUsagessuch as the following:
**action defaction** AC {if1 **if** test1
**then action** // ... then1 {
}
**actionthen action** if2 **if** test2then2 {
} // ...
**else** // ... **action** else2 {
} }
(where _test1_ and _test2_ can be arbitrary _Boolean_ -valuedExpressions) are parsed, with implied
Specializationsincluded, as (see8.2.2.16.6):

**410 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**action defaction** ACif1 **specializessubsets** Actions::Action::ifSubactions {Actions::Action {
**in calc** test1 **redefines** Actions::IfThenAction::ifTest {
} **in action** then1 **redefines** Actions::IfThenAction::thenClause {
} // ...
}
**action** Actions::ifThenElseActions {if2 **subsets** Actions::Action::ifSubactions,
**in calc** test1 **redefines** Actions::IfThenAction::ifTest {
} **in action** then1 **redefines** Actions::IfThenAction::thenClause {
} // ...
**inaction** // ...else2 **redefines** Actions::IfThenElseAction::elseClause {
} }
_IfThenAction_ specializes the KerMLBehavior _IfThenPerformance,_ whose behavior is to first evaluate the
_ifTest_ and then, if the result of that evaluation is true, perform the _thenClause.IfThenElseAction_ specializes
the KerMLBehavior _IfThenElsePerformance,_ which specializes _IfThenPerformance,_ adding the additional
behavior such that, if the result of the evaluation of the _ifTest_ is false, it performs the _elseClause._
**8.4.12.9Loop Action Usages**
ALoopActionUsageis a kind ofActionUsage, so all general semantic constraints for anActionUsage(see
8.4.12.2) also apply to aLoopActionUsage.LoopActionUsageis abstract. There are two concrete subclasses of
LoopActionUsage,WhileLoopActionUsageandForLoopActionUsage, and further semantic constraints are
specific to those subclasses.
**While Loops**
AWhileLoopActionUsageis a kind ofLoopActionUsage. The following additional specialization constraints
apply to aWhileLoopActionUsage:

- checkWhileLoopActionUsageSpecializationrequires that aWhileLoopActionUsagespecialize
    theActionUsage _Actions::whileLoopActions_ (see9.2.9.2.27), which is defined by the
    ActionDefinition _Actions::WhileLoopAction_ (see9.2.9.2.26) and (indirectly) subsets
    _Actions::Action::actions_ (see9.2.9.2.5).
- checkWhileLoopActionUsageSubactionSpecializationrequires that a
    WhileLoopActionUsagethat is composite, has anowningTypethat is anActionDefinitionor
    ActionUsage,and is _not_ theentryActionorexitActionof aStateDefinitionorStateUsage
    (see8.4.13) specialize theActionUsage _Actions::Action::whileLoops_ (see9.2.9.2.4), which
    subsets _Actions::whileLoopActions_ and (indirectly) _Actions::Action::subactions_.
A _WhileLoopAction_ has three inputparameters:
1. _whileTest_ , which is a _BooleanExpression_ that defaults to _true_
2. _body_ , which is an _Action_
3. _untilTest_ , which is a _BooleanExpression_ that defaults to _false_

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 411**


ThewhileArgument,bodyAction, anduntilArgumentof theWhileLoopActionUsageare then parsed as
ownedparameters(see8.2.2.16.6), which must redefine the corresponding parameters of _WhileLoopAction,_ as
required by the KerMLcheckFeatureParameterRedefinitionconstraint (see [KerML, 8.4.4.7.1]).
Thus, aWhileLoopActionUsagesuch as the following
**action defaction** AW {loop1
**whileaction** test1body1 {
} // ...
} **until** test2;
(where _test1_ and _test2_ can be arbitrary _Boolean_ -valuedExpressions) is parsed, with implied
Specializationsincluded, as:
**action defaction** AWloop1 **specializessubsets** Actions::Action::whileLoops {Actions::Action {
**incalc redefines** test1 Actions::WhileLoopAction::whileTest {
} **in action** body1 **redefines** Actions::WhileLoopAction::body {
} // ...
**incalc redefines** test2 Actions::WhileLoopAction::untilTest {
} }
}
_WhileLoopAction_ specializes the KerMLBehavior _LoopPerformance,_ whose behavior is to perform the _body_
while the _whileTest_ evaluates to true and the _untilTest_ evaluates to false. The _whileTest_ is evaluated before
each (possible) performance of the _body_ , and the _untilTest_ is evaluated after each performance of the _body_.
**For Loops**
AForLoopActionUsageis a kind ofLoopActionUsage. The following additional specialization constraints
apply to aForLoopActionUsage:

- checkForLoopActionUsageSpecializationrequires that aForLoopActionUsagespecialize the
    ActionUsage _Actions::forLoopActions_ (see9.2.9.2.13), which is defined by the
    ActionDefinition _Actions::ForLoopAction_ (see9.2.9.2.12) and (indirectly) subsets
    _Actions::Action::actions_ (see9.2.9.2.5).
- checkForLoopActionUsageSubactionSpecializationconstraint requires that a
    ForLoopActionUsagethat is composite, has anowningTypethat is anActionDefinitionor
    ActionUsage, and is _not_ theentryActionorexitActionof aStateDefinitionorStateUsage
    (see8.4.13) specialize theActionUsage _Actions::Action::forLoops_ (see9.2.9.2.4), which subsets
    _Actions::forLoopActions_ and (indirectly) _Actions::Action::subactions_.
_ForLoopAction_ has two inputparameters:
1. _seq,_ which is a sequence of _Anything_
2. _body,_ which is an _Action_

**412 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


It also has a protectedownedFeature _var_ that is a subset of _seq_ with multiplicity0..1. TheloopVariable,
seqArgument, andbodyActionof aForLoopActionUsageare parsed as follows (see8.2.2.16.6):

1. loopVariableis anownedFeature
2. seqArgumentis related by aFeatureValueto an ownedparameter
3. bodyActionis an ownedparameter
ThecheckForLoopActionUsageVarRedefinitionconstraint then requires that theloopVariableredefine
_ForLoopAction::var._ The KerMLcheckFeatureParameterRedefinitionconstraint (see [KerML,
8.4.4.7.1]) requires that the two parameters redefine the corresponding parameters _seq_ and _body_ of
_ForLoopAction_.
Thus, aForLoopActionUsagesuch as the following
**action defaction** AF {loop2 **for** v : T **in** vals
**action** // ...body2 {
} }
(where _vals_ is anExpression) is parsed, with impliedSpecializationsincluded, as:
**action defaction** AFloop2 **specializessubsets** Actions::Action::forLoops {Actions::Action {
**protectedinref redefines** v : T **redefines** Actions::ForLoopAction::seq = vals;Actions::ForLoopAction::var;
**in action** // ...body2 **redefines** Actions::ForLoopAction::body {
} }
}
_ForLoopAction_ uses a nestedWhileLoopActionUsageto iteratively perform its _bodyAction_ , with its _var_
assigned to each successive value from _seq_ in turn.
**8.4.12.10Perform Action Usages**
APerformActionUsageis a kind ofActionUsageand a kind ofEventOccurrenceUsage. As such, all general
semantic constraints on anActionUsage(see8.4.12.2) and anEventOccurrenceUsage(see8.4.5.3) also apply
to aPerformActionUsage. In particular,validateEventOccurrenceUsageIsReferencerequires a
PerformActionUsageto be referential. In addition, if aPerformActionUsageis anownedFeatureof a
PartDefinitionorPartUsage, then thecheckPerformActionUsageSpecializationconstraint requires
that it specialize theActionUsage _Parts::Part::performedActions_ (see9.2.4.2.1), which subsets
_Actions::actions_ (see9.2.9.2.5) and the kernel Feature
_Occurrences::Occurrence::enactedPerformances_ (see [KerML, 9.2.4]). In this case, any _Action_
referenced by thePerformActionUsageis considered to have been performed by the containing _Part_ within its
lifetime.
For example, the following model:
**actionpart** p {act;
**perform** // Other than having a name, the above is equivalent to **action** perf **references** act;

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 413**


} // **perform** act;
is, with impliedSpecializationsincluded, semantically equivalent to
**actionpart** p act1 **subsetssubsets** Parts::parts {Actions::actions;
**refsubsetsaction** perfParts::Part::performedActions; **references** act
}
Thus, the values of _p.perf_ will be some subset of the _Actions_ represented by _act_ that are performed by _p._
As a referentialActionUsage, aPerformActionUsagethat is anownedFeatureof anActionDefinitionor
ActionUsageis required by the KerMLcheckStepEnclosedPerformanceSpecializationconstraint (see
[KerML, 8.4.4.7.2]) to specialize _Performances::Performance::enclosedPerformance_ (see [KerML,
9.2.6]). If thePerformActionUsagehas aReferenceSubsetting, then this will suffice to satisfy the
checkActionUsageSpecializationconstraint, if the referencedActionUsagedoes. However, if it does not
have aReferenceSubsetting(or other relevant explicitownedSpecialization), it requires an implied
Subsettingof _Actions::actions._
**actionperform actiondef** APA **specializes** pa1 **references** Actions::Action {act
**performsubsetsaction** Performances::Performance::enclosedPerformances;pa2 **subsets** Actions::actions
} **subsets** Performances::Performance::enclosedPerformances;
APerformActionUsagethat is anownedFeatureof anOccurrenceDefinitionorOccurrenceUsagebut
_not_ aPartDefinition,PartUsage,ActionDefinitionorActionUsagehas the same semantics as an
EventOccurrenceUsagein that context, with anActionUsageas its referencedOccurrenceUsage(see
8.4.5.3). Otherwise, aPerformActionUsagehas the same semantics as a referentialActionUsage(see8.4.12.2).

**8.4.13States Semantics**
_Abstract syntax reference:8.3.17_
**8.4.13.1State Definitions**
AStateDefinitionis a kind ofActionDefinition. As such, all the general semantic constraints for an
ActionDefinition(see8.4.12.1) also apply to aStateDefinition. In addition, the
checkStateDefinitionSpecializationconstraint requires that aStateDefinitionspecialize the base
StateDefinition _States::StateAction_ (see9.2.10.2.1), which specializes theActionDefinition
_Actions::Action_ (see9.2.9.2.4) and the kernelBehavior _StatePerformances::StatePerformance_ (see
[KerML, 9.2.6]).
**state defstatedef** SS1 **specializesspecializes** States::StateAction;S;

Further, thecheckActionUsageStateActionRedefinitionconstraint (see8.4.12.2) requires that an
ActionUsagethat is anentryAction,exitActionordoActionof aStateDefinition(i.e., is owned via a
StateSubactionMembership) redefine, respectively, the _entryAction,exitAction_ , or _doAction_ feature
of _StateAction_ (see9.2.10.2.1), which redefine the _entry,exit,_ and _do_ featuresof
_StatePerformances::StatePerformance_ (see [KerML, 9.2.6]), restricting them to be _Actions_ (see9.2.9.2.4).

**414 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**state defentry** SA **actiospecializesn** entAct **redefines** States::StateAction {States::StateAction::entryAction;
**do actionexitactio** doAct **n** extAct **redefinesredefines** States::StateAction::doAction;States::StateAction::exitAction;
}
A _StateAction_ is a kind of _StatePerformance_ , which specifies the basic semantics of entry into a state, the
performance of behaviors while in a state, and the acceptance of an _incomingTransfer,_ causing an exit from the
state (see [KerML, 9.2.6]). See also the descriptions of the semantics ofStateUsages(see8.4.13.2) and
TransitionUsages(see8.4.13.3). The _StateAction_ semantic model also includes various additional features
related to various kinds of _subactions_ of _StateActions:_

- _subactions_ – Redefines _Action::subactions_ to subset _StatePeformances::middle,_ thus
    excluding _entryActions_ and _exitActions_ from the collection of _subactions_ for a _StateAction_
    (see8.4.13.2)_._
- _substates_ – The _subactions_ that are _StateActions_ (see8.4.13.2).
- _exclusiveStates_ – The _substates_ that are _mutually exclusive,_ that is whose performances do not
    overlap in time. If aStateDefinitionorStateUsageis _not_ parallel (i.e.,isParallel = false),
    than all the _substates_ of its _StateActions_ will be _exclusiveStates_ (see8.4.13.2).
- _stateTransitions_ – The subset of _transitions_ (inherited from _Action;_ see8.4.12.1) that are
    _StateTransitionActions_ (see8.4.13.3).
**8.4.13.2State Usages**
AStateUsageis a kind ofActionUsage. As such, all the general semantic constraints for anActionUsage(see
8.4.12.2) also apply to aStateUsage, as well as the following additional specialization constraints:
- checkStateUsageSpecializationrequires that aStateUsagespecialize the baseStateUsage
_States::stateActions_ (see9.2.10.2.2), which is defined by theStateDefinition
_States::StateAction_ (see9.2.10.2.1) and subsets theActionUsage _Actions::actions_ (see
9.2.9.2.5).
**statestate** s : Ss1 : S1 **subsetssubsets** States::StateActions;s;
- checkStateUsageSubstateSpecializationrequires that a compositeStateUsagewhose whose
owningTypeis aStateDefinitionorStateUsage, but is _not_ theentryActionorexitAction,
specialize theStateUsage _States::StateAction::substates_ (see9.2.10.2.1), which subsets
_State::StateAction::subactions_.
- checkStateUsageExclusiveStateSpecializationrequires that a compositeStateUsagewhose
whoseowningTypeis aStateDefinitionorStateUsagefor whichisParallel = false, but is
_not_ theentryActionorexitAction, specialize theStateUsage
_States::StateAction::exclusiveStates_ (see9.2.10.2.1), which subsets
_State::StateAction::substates_. This constraint enforces the semantic requirement that a non-
parallel _StateAction_ perform only one _substate_ at a time.
**state defstate** SEse1 **specializessubsets** States::StateAction::exclusiveStates;States::StateAction {
} **state** se2 **subsets** States::StateAction::exclusiveStates;
**statestatedef** SPsp1 **specializessubsets** States::StateAction::substates;States::StateAction **parallel** {
} **state** sp2 **subsets** States::StateAction::substates;

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 415**


- checkStateUsageOwnedStateSpecializationrequires that a compositeStateUsagewhose
    owningTypeis aPartDefinitionor aPartUsagespecialize theStateUsage
    _Parts::Part::ownedStates_ (see9.2.4.2.1), which subsets theActionUsage
    _Parts::Part::ownedActions_. Note also that, in other cases, the general
    KerMLcheckStepEnclosedPerformanceSpecialization,
    checkStepSubperformanceSpecializationand
    checkStepOwnedPerformanceSpecializationconstraints will still apply (see [KerML, 8.4.4.7]), as
    well as checkActionUsageSubactionSpecialization (see8.4.12.2).
**actionref statedef** AS **subsets** st1 **subsets** Action::Action {Performances::Performance::enclosedPerformance;
} **state** st2 **subsets** Actions::Action::ownedActions;
**part defstate** PSs : S **specializessubsets** Parts::Part {Parts::Part::ownedStates;
} **item def** IS **specializes** Items::Item {
} **state** s : S **subsets** Objects::Object::ownedPerformances;
In addition, thecheckActionUsageStateActionRedefinitionconstraint (see8.4.12.2) requires that an
ActionUsagethat is anentryAction,exitActionordoActionof aStateUsage(i.e., is owned via a
StateSubactionMembership) redefine, respectively, the _entryAction,exitAction_ , or _doAction_ feature
of theStateDefinition _StateAction_ (see9.2.10.2.1), which redefine the _entry,exit,_ and _do_ featuresof
the kernelBehavior _StatePerformances::StatePerformance_ (see [KerML, 9.2.6]), restricting them to be
_Actions_ (see9.2.9.2.4).
**stateentry** sa **subsetsaction** States::stateActions {entAct **redefines** States::StateAction::entryAction;
**do actionexitactio** doAct **n** extAct **redefinesredefines** States::StateAction::doAction;States::StateAction::exitAction;
}
**8.4.13.3Transition Usages**
ATransitionUsageis a kind ofActionUsage. As such, all the general semantic constraints for an
ActionUsage(see8.4.12.2) also apply to aTransitionUsage, as well as the following additional specialization
constraints:
- checkTransitionUsageSpecializationrequires that aTransitionUsagespecialize the
ActionUsage _Actions::transitionActions_ (see9.2.9.2.25), which is defined bythe
ActionDefinition _Actions::TransitionAction_ (see9.2.9.2.24) and subsets theActionUsage
_Actions::actions_ (see9.2.9.2.5).
- checkTransitionUsageActionSpecializationrequires that a compositeTransitionUsage
whoseownedTypeis anActionDefinitionorActionUsage, but _not_ aStateDefinitionor
StateUsage, specialize theActionUsage _Actions::Action::decisionTransitions_ (see
9.2.9.2.4), which is typed by theActionDefinition _Actions::DecisionTransitionAction_ (see
9.2.9.2.10) and subsets theActionUsageActions::Action::transitions(see9.2.9.2.4). (For the
semantics ofTransitionUsagesof _DecisionTransitionActions,_ see8.4.12.3.)
- checkTransitionUsageStateSpecializationrequires that a compositeTransitionUsagewhose
ownedTypeis aStateDefinitionorStateUsagespecialize theActionUsage
_States::StateAction::stateTransitions_ (see9.2.10.2.1), which is typed by the
ActionDefinition _States::StateTransitionAction_ (see9.2.10.2.3) and subsets the
ActionUsageActions::Action::transitions(see9.2.9.2.4).

**416 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


_StateTransitionAction_ subclassifies _Actions::TransitionAction_ (see9.2.9.2.24) and the kernel
Behavior _StatePerformances::StateTransitionPerformance_ (see [KerML, 9.2.11]). The
_transitionLinkSource_ of a _StateTransitionAction_ must be a _StateAction._ The
_StateTransitionAction_ then represents a possible transition from the source _StateAction_ to a target _Action._
ATransitionUsageis parsed as having the followingownedMemberships(see8.2.2.17.3):

- An alias (non-owning)Membershipto itssourceStateUsage(or aFeaturechain identifying the
    source).
- AParameterMembershipfor the _transitionLinkSource_ parameter.
- AParameterMembershipfor the _payload_ parameter (if theTransitionUsagehas a
    triggerAction).
- Zero to threeTransitionFeatureMembershipsfor up to one each of atriggerAction,
    guardExpression, andeffectAction. Note also that atriggerActionis parsed as an
    AcceptActionUsage, with _payload_ and, optionally, _receiver_ parameters(see8.4.12.6).
- AnOwningMembershipforthesuccessionof theTransitionUsage, which is aSuccessionwhose
    targetFeatureis thetargetof theTransitionUsage(or aFeaturechain identifying thetarget).
The following semantic constraints then apply:
- checkFeatureParameterRedefinition(see [KerML, 8.4.4.7]) requires that the
_transitionLinkSource_ and _payload_ parametersof aTransitionUsageredefinition the
correspondingparametersof _StateTransitionAction_ (see9.2.10.2.3), as inherited from _Transition_
- checkTransitionUsagePayloadSpecializationrequires that the _payload_ parameterof a
TransitionUsagealsosubsetthepayloadParameterof thetriggerAction. Note also that the
effectivenameof aReferenceUsageused as the _payload_ parameterof aTransitionUsageis
defined to be thenameof thepayloadParameterit subsets, rather than the name of the
_StateTransitionAction::payload_ featureit redefines.
- checkTransitionUsageTransitionFeatureSpecializationrequires that thetriggerAction,
guardExpression, andeffectActionof aTransitionUsage(if they exist) specialize, respectively,
the _accepter,guard,_ and _effect_ featuresof _TransitionAction_ (9.2.9.2.24; see also [KerML,
9.2.10, 9.2.11] for inherited features).
- checkTransitionUsageSuccessionSourceSpecializationrequires that thesourceFeatureof
thesuccessionof aTransitionUsagebe the aliasedsourcefor theTransitionUsage.
- checkTransitionUsageSuccessionBindingConnectorrequires that aTransitionUsagehave an
ownedMemberthat is aBindingConnectorbetween itssuccessionand the inherited
_TransitionPerformances::TransitionPerformance::transitionLink_ feature.
- checkTransitionUsageSourceBindingConnectorrequires that aTransitionUsagehave an
ownedMemberthat is aBindingConnectorbetween itssourceand its _transitionLinkSource_
parameter.
- checkConnectorTypeFeaturing(see [KerML, 8.4.4.6.1]) then determines thefeaturingTypeof the
Successionand twoBindingConnectorsowned by aTransitionUsage(typically theowningType
of theTransitionUsage).
As a result of all the above semantic constraints, aTransitionUsagesuch as in the following model
**state defstate** ST {s1;
**transitionfirst** s1trns
**acceptif** testx : T **via** tgt
**effect action** efct {

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 417**


} // ...
**statethen** s2;s2;
}
(where _test_ is a _Boolean_ -valued Expression) has, with impliedRelationshipsincluded, the equivalent kernel
semantics of:
// KerML **behavior** ST **specializes** States::StateAction {
**step** s1 **subsets** States::StateAction::exclusiveStates;
**stepalias** trns **subsets** s1 **of** SC::s1;States::State::stateTransitions {
**in feature redefines** States::StateTransitionAction::transitionLinkSource;
**infeatureredefines** x States::StateTransitionAction::payload
**subsets** accepter.x;
**step redefinesinoutref** x : TActions::TransitionAction::accepter { **redefines** Actions::AcceptAction::payload;
} **in ref redefines** Actions::AcceptAction::receiver = tgt;
**bool redefines** test Actions::TransitionAction::guard {
}
**step** // ...efct **redefines** Actions::TransitionAction::effect {
}
**membersubsetssuccession** Occurrences::happensBeforeLinkstrns_link
**featured byfirst** s1 **then** STs2;
**member** TransitionPerformances::TransitionPerformance::transitionLink **bindingfeatured by** ST **of** trns_link = ;

} **member binding featured by** ST **of** s1 = transitionLinkSource;
} **step** s2 **subsets** States::StateAction::exclusiveStates;
A _StateTransitionAction_ is a kind of _StateTransitionPerformance,_ which specifies the fundamental
semantics of transition out of a state. The _guard_ of a _StateTransitionAction_ is evaluated during the
performance of its source _StateAction,_ and, if the _guard_ evaluates to true and the transition accepts a _Transfer,_
then its _accepter_ is also performed during the source _StateAction,_ after which the _exitAction_ of the
_StateAction_ is performed (if it has one), and then the _effect_ of the _StateTransitionAction_ is performed (if
it has one). Finally, the _transitionLink_ of the _StateTransitionAction_ is asserted to have a value, meaning
that there must be a target _Action_ temporally following the source _StateAction._ (For a complete description of the
semantics of _StateTransitionPerformance,_ see [KerML, 9.2.10].)

**418 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.4.13.4Exhibit State Usages**
AnExhibitStateUsageis a kind ofStateUsageand a kind ofPerformActionUsage. As such, all general
semantic constraints on aStateUsage(see8.4.13.2) and aPerformActionUsage(see8.4.12.10) also apply to a
ExhibitStateUsage. In particular,validateEventOccurrenceUsageIsReferencerequires an
ExhibitStateUsageto be referential. In addition, if anExhibitStateUsageis anownedFeatureof a
PartDefinitionorPartUsage, then thecheckExhibitStateUsageSpecializationconstraint requires that
it specialize theStateUsage _Parts::Part::exhibitStates_ (see9.2.4.2.1), which subsets _State::states_
(see7.17) and _Parts::Part::performedActions_. In this case, any _State_ referenced by the
ExhibitStateUsageis considered to have been exhibited by the containing _Part_ within its lifetime.
For example, the following model:
**statepart** p {st;
} **exhibit state** exhb **references** st;
is, with impliedSpecializationsincluded, semantically equivalent to
**statepart** pst **subsetssubsets** Parts::parts {State::states;
**refsubsetsstate** exhbParts::Part::exhibitedStates; **references** st
}
Thus, the values of _p.exhb_ will be the subset of the _States_ represented by _st_ that are performed by _p._
As a referentialStateUsage, anExhibitStateUsagethat is anownedFeatureof anActionDefinitionor
ActionUsage(including aStateDefinitionorStateUsage) is required by the KerML
checkStepEnclosedPerformanceSpecializationconstraint (see [KerML, 8.4.4.7.2]) to specialize
_Performances::Performance::enclosedPerformance_ (see [KerML, 9.2.6]). If theExhibitStateUsage
has aReferenceSubsetting, then this will suffice to satisfy thecheckStateUsageSpecialization
constraint, if the referencedStateUsagedoes. However, if it does not have aReferenceSubsetting(or other
relevant explicitownedSpecialization), it requires an impliedSubsettingof _State::states._
**state defexhibit state** SES **specializes** es1 **references** States::State {st
**exhibit statesubsets** Performances::Performance::enclosedPerformances;es2 **subsets** State::states
} **subsets** Performances::Performance::enclosedPerformances;
AnExhibitStateUsagethat is anownedFeatureof anOccurrenceDefinitionorOccurrenceUsagebut
_not_ aPartDefinition,PartUsage,ActionDefinitionorActionUsagehas the same semantics as an
EventOccurrenceUsagein that context, with aStateUsageas its referencedOccurrenceUsage(see8.4.5.3).
Otherwise, anExhibitStateUsagehas the same semantics as a referentialStateUsage(see8.4.13.2).

**8.4.14Calculations Semantics**
_Abstract syntax reference:8.3.18_

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 419**


**8.4.14.1Calculation Definitions**
ACalculationDefinitionis a kind ofActionDefinitionand a kind of KerMLFunction. As such, all the
general semantic constraints for anActionDefinition(see8.4.12.1) and aFunction(see [KerML, 8.4.4.8.1])
apply to aCalculationDefinition. In addition, thecheckCalculationDefinitionSpecialization
constraint requires that aCalculationDefinitionspecialize the baseCalculationDefinition
_Calculations::Calculation_ (see9.2.11.2.1), which subclassifies theActionDefinition
_Actions::Action_ (see9.2.9.2.4) and the kernelBehavior _Performances::Evaluation_ (see [KerML, 9.2.6]).
Further, in addition to the KerMLcheckFeatureParameterRedefinitionconstraint, that applies to all kinds of
ActionDefinitions(see8.4.12.1), the KerMLcheckFeatureResultRedefinitionconstraint (see [KerML,
8.4.4.8.1]) constraint also requires that theresultparameterof aCalculationDefinitionredefinethe
resultparametersof anyFunctionsit specializes (including otherCalculationDefinitions), which
means that it ultimately directly or indirectly specializes _Performances::Evaluation::result._
**calc defin ref** C **specializes** a **redefines** Calculations::Calculation {Base::things;
**inreturn refref** b **redefines** result **redefines** Base::things;Calculations::Calculation::result;
} **calc def** C1 **specializes** C {
**in ref** // The result parameter can be in any position.a **redefines** C::a;
**return refin ref** b **redefines** result **redefines** C::b; C::result;
}
Further, if aCalculationDefinitionowns anExpressionvia aResultExpressionMembership, then the
KerMLcheckFunctionResultBindingConnectorconstraint (see [KerML, 8.4.4.8.1]) requires that the
CalculationDefinitionhave, as anownedFeature, aBindingConnectorbetween theresultparameter
of theExpressionand theresultparameterof theCalculationDefinition.
**calc defreturn** C2 **redefinesspecializes** Calculations::Calculation::result;Calculations::Calculation {
**binding** resultExprresult = resultExpr.result; // Implied
}
where _resultExpr_ is an arbitraryExpressionand _resultExpr.result_ represents aFeaturechain to the
Expressionresult.
**8.4.14.2Calculation Usages**
ACalculationUsageis a kind ofActionUsageand a kind of KerMLExpression. As such, all the general
semantic constraints for anActionUsage(see8.4.12.2) and anExpression(see [KerML, 8.4.4.8.2]) apply to a
CalculationUsage, as well as the following additional specialization constraints:

- checkCalculationUsageSpecializationrequires that aCalculationUsagespecialize the base
    CalculationUsage _Calculations::calculations_ (see9.2.11.2.2), which is defined by the
    CalculationDefinition _Calculations::Calculation_ (see9.2.11.2.1) and subsets the
    ActionUsage _Actions::actions_ (see9.2.9.2.4) and the kernelStep
    _Performances::evaluations_ (see [KerML, 9.2.6]). Further, in addition to the KerML
    checkFeatureParameterRedefinitionconstraint, that applies to all kinds ofActionUsages(see
    8.4.12.2), the KerMLcheckFeatureResultRedefinitionconstraint (see [KerML, 8.4.4.8.1]) also
    requires that theresultparameterof aCalculationUsageredefinetheresultparametersof

**420 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
anyFunctionsorExpressionsit specializes (includingCalculationDefinitionsand
CalculationUsages).
calcin ref c : C subsets a redefines Calculations::calculations {C::a;
in refreturn bresult redefinesredefines C::b;C::result, Calculation::calculations::result;
} calc c1 : C1 subsets c {
} returnref result redefines C1::result, c::result;
```
- checkCalculationUsageSubcalculationSpecializationrequires that aCalculationUsage
    that is composite and has anowningTypethat is aCalculationDefinitionorCalculationUsage
    specialize theCalculationUsage _Calculations::Calculation::subcalculations_ (see
    9.2.11.2.1), which subsets _Calculations::calculations_ and theActionUsage
    _Actions::Action::subactions_ (see9.2.9.2.4). Note also that, in other cases, the general
    checkActionUsageSubactionSpecializationconstraint (see8.4.12.2) and the
    KerMLcheckStepEnclosedPerformanceSpecializationand
    checkStepSubperformanceSpecializationconstraints (see [KerML, 8.4.4.7]) will still apply.
**calccalcdef** Clcclc1 **subsetssubsets** Calculations::Calculation {Calculations::Calculation::subcalculations;
**refcalc** Performances::Performance::enclosedPerformances;clc2 **subsets** Calculations::calculations,
} **action def** AClc **subsets** Actions::Action {
**calc** Actions::Action::subactions;clc3 **subsets** Calculations::calculations,
}
Further, if aCalculationUsageowns anExpressionvia aResultExpressionMembership, then the KerML
checkExpressionResultBindingConnectorconstraint (see [KerML, 8.4.4.8.1]) requires that the
CalculationUsagehave, as anownedFeature, aBindingConnectorbetween theresultparameterof the
Expressionand theresultparameterof theCalculationUsage.
**calcbinding** c2 **subsets** result = resultExpr.result; // ImpliedCalculations::calculations {
} resultExpr
where _resultExpr_ is an arbitraryExpressionand _resultExpr.result_ represents aFeaturechain to the
Expressionresult.

**8.4.15Constraints Semantics**
_Abstract syntax reference:8.3.19_
**8.4.15.1Constraint Definitions**
AConstraintDefinitionis a kind ofOccurrenceDefinitionand a kind of KerMLPredicate. As such, all
the general semantic constraints for anOccurrenceDefinition(see8.4.5) and aPredicate(see [KerML,
8.4.4.8.1]) also apply to aConstraintDefinition. In addition, the
checkConstraintDefinitionSpecializationconstraint requires that aConstraintDefinitionspecialize

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 421**


the baseConstraintDefinition _Constraints::ConstraintCheck_ (see9.2.9.2.4), which subclassifies the
kernelPredicate _Performances::BooleanEvaluation_ (see [KerML, 9.2.6]).
AConstraintDefinitionis not aCalculationDefinition, but, since aPredicateis a kind of KerML
Function, theKerML checkFeatureParameterRedefinitionconstraint (see [KerML, 8.4.4.7.1]) and
checkFeatureResultRedefinition(see [KerML, 8.4.4.8.1]) constraints also apply to theparametersof a
ConstraintDefinition, as for aCalculationDefinition(see8.4.14.1). However, theresultparameter
of _BooleanEvaluation_ hastype _ScalarValues::Boolean_ , so theresultof aConstraintDefinition
must also havetype _Boolean_ (or a specialization of it), and, therefore, it is often just inherited into the
ConstraintDefinition.
Also as for aCalculationDefinition, if aConstraintDefinitionowns anExpressionvia a
ResultExpressionMembership, then the KerMLcheckFunctionResultBindingConnectorconstraint (see
[KerML, 8.4.4.8.1]) requires that theConstraintDefinitionhave, as anownedFeature, a
BindingConnectorbetween theresultparameterof theExpressionand theresultparameterof the
ConstraintDefinition. The resultExpressionmust therefore be _Boolean-_ valued.
**constraint definattribute** Cstx : ScalarValues::Real **specializes** Constraints::ConstraintCheck { **subsets** Base::dataValues;
**//** // and the result of the Expression x > 0.Implied binding between the inherited result parameter
} x > 0
**8.4.15.2Constraint Usages**
AConstraintUsageis a kind ofOccurrenceUsageand a kind of KerMLExpression. As such, all the general
semantic constraints for anOccurrenceUsage(see8.4.5) and anExpression(see [KerML, 8.4.4.8.2]) also apply
to aConstraintUsage, as well as the following additional specialization constraints:

- checkConstraintUsageSpecializationrequires that aConstraintUsagespecialize the base
    ConstraintUsage _Constraints::constraintChecks_ (see9.2.12.2.3), which is defined by the
    ConstraintDefinition _Constraints::ConstraintCheck_ (see9.2.12.2.2) and subsets the kernel
    Step _Performances::booleanEvaluations_ (see [KerML, 9.2.6]). Further, theKerML
    checkFeatureParameterRedefinitionconstraint (see [KerML, 8.4.4.7.1]) and
    checkFeatureResultRedefinition(see [KerML, 8.4.4.8.1]) constraints also apply to the
    parametersof aConstraintUsage, as for aConstraintDefinition(see8.4.15.1).
**constraintinref** cst : Cstx **redefinessubsets** Cst::x = 2;Constraints::constraintChecks {
} // Inherits result parameter and result Expression from Cst.
- checkConstraintUsageCheckedConstraintSpecializationrequires that a composite
    ConstraintUsagewhoseowningTypeis anItemDefinitionor anItemUsage(including a
    PartDefinitionorPartUsage) specialize theConstraintUsage
    _Items::Item::checkedConstraints_ (see9.2.4.2.1), which subsets theConstraintUsage
    _Constraints::constraintChecks_ and the kernelFeature
    _Objects::Object::ownedPerformances_ (see [KerML, 9.2.5]). Note also that, in other cases, the
    general KerMLcheckStepOwnedPerformanceSpecializationconstraint will still apply (see
    [KerML, 8.4.4.7]).
**item defconstraint** ICst **specializes** c : Cst **subsets** Items::Item {Items::Item::checkedConstraints;
}

**422 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
action defconstraint ACstc : Cst specializessubsets Actions::Action {Objects::Object::ownedPerformances;
}
```
- checkConstraintUsageRequirementConstraintSpecializationrequires that a
    ConstraintUsagewhoseowningFeatureMembershipis aRequirementConstraintMembership
    specialize either the _assumptions_ (if it is anassumedConstraint) or _constraints_ (if it is a
    requiredConstraint)featureof theRequirementDefinition
    _Requirements::RequirementCheck_ (see9.2.13.2.8). (See also8.4.16on requirements semantics.)
**8.4.15.3Assert Constraint Usages**
AnAssertConstraintUsageis a kind ofConstraintUsageand a kind of KerMLInvariant. As such, all the
general semantic constraints for aConstraintUsage(see8.4.15.2) and anInvariant(see [KerML, 8.4.4.8.2]).
In addition, thecheckAssertConstraintUsageSpecializationconstraint requires that an
AssertConstraintUsagespecialize one of the following:
- If theAssertConstraintUsageis _not_ negated,ConstraintUsage
_Constraints::assertedConstraintChecks_ (see9.2.12.2.1), which subsets theConstraintUsage
_Constraints::constraintChecks_ (see9.2.12.2.3) and the kernelExpression
_Performances::trueEvaluations_ (see [KerML, 9.2.6]).
- If theAssertConstraintUsage _is_ negated, theConstraintUsage
_Constraints::negatedConstraintChecks_ (see9.2.12.2.4), which subsets theConstraintUsage
_Constraints::constraintChecks_ (see9.2.12.2.3) and the kernelExpression
_Performances::falseEvaluations_ (see [KerML, 9.2.6]).
**assertassert constraintconstraint** astast1 : Cst **referencessubsets** cst **subsets** Constraints::assertedConstraints {Constraints::assertedConstraints;
} **redefines** x = 3;
**assert not constraintredefines** x = -3;ast2 : Cst **subsets** Constraints::negatedConstraints {
}
In general, a _ConstraintCheck_ of aConstraintUsageat a certain point in time produces a _Boolean_ result
indicating whether the modeled constraint holds or not at that point in time. This may be true at some times and false
at other times. However, _assertedConstraintChecks_ subsets _trueEvaluations,_ which only includes
_BooleanEvaluations_ that have trueresults. Therefore, a _ConstraintCheck_ of a non-negated
AssertConstraintUsagemust have a trueresult—that is, the constraint modeled by the
AssertConstraintUsageis asserted to _always_ hold. Similarlty, _negatedConstraintChecks_ subsets
_falseEvaluations,_ which only includes _BooleanEvaluations_ that have falseresults. Therefore, a
_ConstraintCheck_ of a negatedAssertConstraintUsagemust have a falseresult—that is, the constraint
modeled by theAssertConstraintUsageis asserted to _never_ hold.

**8.4.16Requirements Semantics**
_Abstract syntax reference:8.3.20_
**8.4.16.1Requirement Definitions**
ARequirementDefinitionis a kind ofConstraintDefinition. As such, all the general semantic constraints
for aConstraintDefinition(see8.4.15.1) also apply to aRequirementDefinition. In addition, the
checkRequirementDefinitionSpecializationconstraint requires that aRequirementDefinition

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 423**


specialize the baseRequirementDefinition _Requirements::RequirementCheck_ (see9.2.13.2.8), which
specializes theConstraintDefinition _Constraints::ConstraintCheck_ (see9.2.12.2.2).
**requirement defrequirement def** RR1 **specializesspecializes** Requirements::RequirementCheck;R;

ARequirementDefinitionsdiffers from a plainConstraintDefinitionin that it represents a condition on a
_subject_ in terms of _assumed_ and _required_ constraints.

- validateRequirementDefinitionSubjectParameterPositionrequires that the
    subjectParameterof aRequirementDefinitionbe its first parameter. Thus, as a result of the
    KerMLcheckFeatureParameterRedefinitionconstraint (see [KerML, 8.4.4.7.1]), the
    subjectParameterof aRequirementDefinitionwill always redefine thesubjectParameterof
    anyRequirementDefinitionsit specializes, and so will directly or indirectly redefine the base subject
    parameter _Requirements::RequirementCheck::subj_ (see9.2.13.2.8)_._
- checkConstraintUsageRequirementConstraintSpecialization(see8.4.15.2) requires that a
    ConstraintUsagethat is anassumedConstraintorrequiredConstraintof a
    RequirementDefinitionspecialize, respectively, the _assumptions_ or _constraints_ feature of
    RequirementCheck, both of which subset _Constraints::constraintChecks_ (see9.2.12.2.3).
**requirement defsubject** subjR2 **redefinesspecializes** Requirements::RequirementCheck::subj;Requirements::RequirementCheck {
**assume constraintrequire constraint** cacr **subsetssubsets** Requirements::RequirementCheck::assumptions;Requirements::RequirementCheck::constraints;
}
Theresultof aRequirementCheckis defined to be the following logical test: if all the _assumptions_ have a
trueresult, then all the _constraints_ must have atrueresult. In addition to theassumedConstraintsand
requiredConstraintsdeclared as above, _RequirementCheck_ includes two other features that contribute to the
requiredConstraintsthat are checked:
- _subrequirements–_ Collects the values of the compositeRequirementUsagesfeatured by a
_RequirementCheck,_ subsetting _constraints._ (See8.4.16.2on the semantics of
RequirementUsages.)
- _concernChecks_ – Collects the values of the compositeConcernUsagesfeatured by a
_RequirementCheck,_ subsetting _subrequirements_ (sinceConcernUsagesare kinds of
RequirementUsages). (See8.4.16.5on the semantics ofConcernUsages.)
Finally, _RequirementCheck_ includes twofeaturesthat collect the values ofPartUsagesrepresenting entities
playing actor and stakeholder roles relative to aRequirementDefinition(orRequirementUsage):
- _actors_ – Collects the values ofPartUsagesthat are owned viaActorMemberships. (See also8.4.7.2
on the semantics ofPartUsages.)
- _stakeholders_ – Collects the values ofPartUsagesthat are owned viaStakeholderMemberships.
(See also8.4.7.2on the semantics ofPartUsages.)
**requirement defactor** a **subsets** R3 **specializes** Requirements::RequirementCheck::actors;Requirements::RequirementCheck {
} **stakeholder** s **subsets** Requirements::RequirementCheck::stakeholders;

**424 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.4.16.2Requirement Usages**
ARequirementUsageis a kind ofConstraintUsage. As such, all the general semantic constraints for a
ConstraintUsage(see8.4.15.2) also apply to aRequirementUsage, as well as the following additional
specialization constraints:

- checkRequirementUsageSpecializationrequires that aRequirementUsagespecialize the base
    RequirementUsage _Requirements::requirementChecks_ (see9.2.13.2.9), which subsets
    _Constraints::constraintChecks_ (see9.2.12.2.3).
**requirement** r : R **subsets** Requirements::requirementChecks;
- checkRequirementUsageSubrequirementSpecializationrequires that a composite
    RequirementUsagewhoseowningTypeis aRequirementDefinitionorRequirementUsage
    specialize theRequirementUsage _Requirements::RequirementCheck::subrequirements_ (see
    9.2.13.2.8), which subsets _Requirements::RequirementCheck::constraints_ (see also8.4.16.1).
**requirement defrequirement** Rqtrqt1 **specializessubsets** Requirements::RequirementCheck::subrequirements;Requirements::RequirementCheck {
**refrequirement** Performances::enclosedPerformances;rqt2 **subsets** Requirements::requirements,
}
- checkRequirementUsageObjectiveRedefinitionrequires that aRequirementUsageowned by a
    CaseDefinitionorCaseUsagevia anObjectiveMembershipredefine the
    objectiveRequirementof eachCaseDefinitionorCaseUsagespecialized by its owningType. (See
    also8.4.17on Case Semantics.)
- checkRequirementUsageRequirementVerificationSpecializationrequires that a
    RequirementUsagethat is owned by the objective of aCaseDefinitionorCaseUsagevia a
    RequirementVerificationMembershipspecializes theRequirementUsage
    _VerificationCases::VerificationCase::obj::requirementVerifications_ (see
    VerificationCase).
Similarly toRequirementDefinitions, aRequirementUsagealso has a _subject_ and _assumed_ and _required_
constraints (see also8.4.16.1).
- validateRequirementUsageSubjectParameterPositionrequires that thesubjectParameterof
aRequirementUsagebe its first parameter. Thus, as a result of the KerML
checkFeatureParameterRedefinitionconstraint (see [KerML, 8.4.4.7.1]), thesubjectParameter
of aRequirementUsagewill always redefine thesubjectParameterof any
RequirementDefinitionsandRequirementUsagesit specializes, and so will directly or indirectly
redefine the base subject parameter _Requirements::RequirementCheck::subj_ (see9.2.13.2.8)_._
- checkConstraintUsageRequirementConstraintSpecialization(see8.4.15.2) requires that a
ConstraintUsagethat is anassumedConstraintorrequiredConstraintof a
RequirementUsagespecialize, respectively, the _assumptions_ or _constraints_ feature of
RequirementCheck, both of which subset _Constraints::constraintChecks_ (see9.2.12.2.3).
**requirementsubject** r1 : R1subj **redefinessubsets** R1::subj;Requirements::requirementChecks {
**assume constraintrequire constraint** cacr **subsetssubsets** Requirements::RequirementCheck::assumptions;Requirements::RequirementCheck::constraints;
}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 425**


**8.4.16.3Satisfy Requirement Usages**
ASatisfyRequirementUsageis a kind ofRequirementUsageand a kind ofAssertConstraintUsage. As
such, all the general semantic constraints for aRequirementUsage(see8.4.16.2) and an
AssertConstraintUsage(see8.4.15.3) also apply to aSatisfyRequirementUsage. In addition, the
checkSatisfyRequirementUsageBindingConnectorconstraint requires that aSatisfyRequirementUsage
have aBindingConnectorbetween itssubjectParameterand some otherFeature, which is then considered
to be thesatisfyingFeatureof theSatisfyRequirementUsage. Further, the
checkAssertConstraintUsageSpecializationapplies to aSatisfyRequirementUsage, so it must either
specialize _Constraints::assertedConstraintChecks_ (see9.2.12.2.1), or
_Constraints::negatedConstraintChecks_ (see9.2.12.2.4), if negated. Together, these constraints mean that a
SatisfyRequirementUsageasserts the satisfaction (or not, if negated) of a requirement when the
satisfyingFeatureis bound as the subject of the requirement
ASatisfyRequirementUsageof the form
**satisfy requirement** sr : R **by** f;
is parsed with _f_ bound to thesubjectParameterof theSatisfyRequirementUsageusing aFeatureValue
Relationship (see8.2.2.20.2). The KerMLcheckFeatureValueBindingConnectorconstraint (see [KerML,
8.4.4.11]) then requires that theSatisfyRequirementUsagehave aBindingConnectorthat effectively also
meets thecheckSatisfyRequirementUsageBindingConnectorconstraint.
**satisfy requirement** Constraints::assertedConstraintChecks {sr : R **subsets** Requirements::requirementChecks,
**subject** // Implicit BindingConnector for the FeatureValue also meetssubj **redefines** R::subj = f;
// the checkSatisfyRequirementUsageBindingConnector constraint. **bind** subj = subj:: _f_expr_ .result;
}
where _f_expr_ is theFeatureReferenceExpressionthat references _f_ as thevalueExpressionof the
FeatureValue.
If aSatisfyRequirementUsageis declared _without_ an explicitsatisfyingFeature: then the implicit
BindingConnectorfor thecheckSatisfyRequirementUsageBindingConnectorconstraint targets the
Feature _Base::things::that_ (see [KerML, 9.2.2]). This means that aSatisfyRequirementUsagenested in
aDefinitionorUsage, such as
**partsatisfy requirement** p { sr1 : R1;
}
is asserted to satisfy the featuring instance of that containingDefinitionorUsage.
**partsatisfy requirement** p **subsets** Parts::parts {sr1 : R1 **subsets** Requirements::requirementCheck,
Constraints::assertedConstraintChecks { **subject** subj **redefines** R1::subj;
// The implied BindingConnector means that sr1 is effectively// satisfied by the containing Part p.
} **bind** subj = Base::things::that;
}

**426 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.4.16.4Concern Definitions**
AConcernDefinitionis a kind ofRequirementDefinition. As such, all the general semantic constraints for
aRequirementDefinition(see8.4.16.1) also apply to aConcernDefinition. In addition, the
checkConcernDefinitionSpecializationconstraint requires that aConcernDefinitionspecialize the base
ConcernDefinition _Requirements::ConcernCheck_ (see9.2.13.2.1), which specializes the
RequirementDefinition _Requirements::RequirementCheck_ (see9.2.13.2.8).
**concern defconcern def** CrnCrn1 **specializesspecializes** Requirements::ConcernCheck;Crn;

**8.4.16.5Concern Usages**
AConcernUsageis a kind ofRequirementUsage. As such, all the general semantic constraints for a
RequirementUsage(see8.4.16.2) also apply to aConcernUsage, as well as the following additional
specialization constraints:

- checkConcernUsageSpecializationrequires that aConcernUsagespecialize the base
    ConcernUsage _Requirements::concernChecks_ (see9.2.13.2.2), which subsets
    _Requirements::requirementChecks_ (see9.2.13.2.9).
**concern** crn : Crn **subsets** Requirements::concernChecks;
- checkConcernUsageFramedConcernSpecializationrequires that aConcernUsagethat is owned
    by aRequirementDefinitionorRequirementUsagevia aFramedConcernMembershipspecialize
    theConcernUsage _Requirements::RequirementCheck::concerns_ (see9.2.13.2.8), which subsets
    _Requirements::concernChecks_ and _Requirements::RequirementCheck::subrequirements_.
**requirement defconcern** crn1 : Crn1Rcrn **subsetssubsets** Requirements::RequirementCheck {Requirements::RequirementCheck::concerns;
}
**8.4.17Cases Semantics**
_Abstract syntax reference:8.3.21_
**8.4.17.1Case Definitions**
ACaseDefinitionis a kind ofCalculationDefinition. As such, all the general semantic constraints for a
CalculationDefinition(see8.4.14.1) apply to aCaseDefinition. In addition, the
checkCaseDefinitionSpecializationconstraint requires that aCaseDefinitionspecialize the base
CaseDefinition _Cases::Case_ (see9.2.14.2.1), which subclassifies theCalculationDefinition
_Calculations::Calculation_ (see9.2.11.2.1). Further, the KerMLcheckFeatureParameterRedefinition
andcheckFeatureResultRedefinitionconstraints (see [KerML, 8.4.4.8.1]) also apply to aCaseDefinition,
as for anyCalculationDefinition(see8.4.14.1).
**case defreturn** Cs **refspecializes** result **redefines** Cases::Case {Cases::Case::result;
} **case def** cs1 : Cs1 **specializes** cs {
} **returnref** result **redefines** Cs1:result, cs::result;
ACaseDefinitiondiffers from a plainCalculationDefinitionin that it has a _subject_ and an _objective,_ and it
may also have one or more _actor_ features.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 427**


- validateCaseDefinitionSubjectParameterPositionrequires that thesubjectParameterof a
    CaseDefinitionbe its first parameter. Thus, as a result of the KerML
    checkFeatureParameterRedefinitionconstraint (see [KerML, 8.4.4.7.1]), thesubjectParameter
    of aCaseDefinitionwill always redefine thesubjectParameterof anyCaseDefinitionsit
    specializes, and so will directly or indirectly redefine the base subject parameter _Case::Case::subj_ (see
    9.2.14.2.1)_._
- checkRequirementUsageObjectiveRedefinition(see8.2.2.20.2) effectively requires that the
    objectiveRequirementof aCaseDefinitionredefine theobjectiveRequirementsof any
    CaseDefinitionsspecialized by the firstCaseDefinition, which means that it will directly or
    indirectly redefined theRequirementUsage _Cases::Case::obj_. The _obj_ feature has a default binding
    to the _result_ of the _Case,_ so, unless the default is overridden, thesubjectParameterof the
    objectiveRequirementof aCaseDefinitionshould conform to theresultof the
    CaseDefinition.
- checkPartUsageActorSpecializationrequires that aPartUsagethat is owned by a
    CaseDefinitionvia anActorMembershipspecialize thePartUsage _Cases::Case::actors_ (see
    8.4.7.2).
**case defsubject** Cs2subj **specializesredefines** Cases::Case {Cases::Case::subj;
**objectiveactor** a **subsets** obj **redefines** Cases::Case::actors;Cases::Case::obj;
} **return** result : T **redefines** Cases::Case::result;
Additional semantics are defined for each of the more specialized kinds ofCaseDefinition(see8.4.18.1on
AnalysisCaseDefinitions,8.4.19.1onVerificationCaseDefinitions, and8.4.20.1on
UseCaseDefinitions).
**8.4.17.2Case Usages**
ACaseUsageis a kind ofCalculationUsage. As such, all the general semantic constraints for an
CalculationUsage(see8.4.14.2) apply to aCaseUsage, as well as the following additional specialization
constraints:
- checkCaseUsageSpecializationrequires that aCaseUsagespecialize the baseCaseUsage
_Cases::cases_ (see9.2.11.2.2), which is defined by theCaseDefinition _Cases::Case_ (see
9.2.11.2.1) and subsets theCalculationUsage _Calculations::calculations_ (see9.2.9.2.4)_._
Further, the KerMLcheckFeatureParameterRedefinitionand
checkFeatureResultRedefinitionconstraints (see [KerML, 8.4.4.8.1]) also apply to aCaseUsage,
as for anyCalculationUsage(see8.4.14.2).
**casereturn** cs : Csresult **subsetsredefines** Cases::cases {Cs::result;
} **case** cs1 : Cs1 **subsets** cs {
} **returnref** result **redefines** Cs1::result, cs::result;
- checkCaseUsageSubcaseSpecializationrequires that aCaseUsagethat is composite and has an
owningTypethat is aCaseDefinitionorCaseUsagespecialize theCaseUsage
_Cases::Case::subcases_ (see9.2.11.2.1), which subsets _Cases::cases_ and theCalculationUsage
_Calculations::Calculation::subcalculations_ (see9.2.9.2.4).
**casecasedef** Csccsc1 **subsetssubsets** Cases::Case {Cases::Case::subcases;

**428 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**refcase** Performances::Performance::enclosedPerformances;csc2 **subsets** Cases::cases,
}
Similarly to aCaseDefinition, aCaseUsagealso has a _subject_ and an _objective_ , and may have one or more _actor_
features(see also8.4.17.1).

- validateCaseUsageSubjectParameterPositionrequires that thesubjectParameterof a
    CaseUsagebe its first parameter. Thus, as a result of the KerML
    checkFeatureParameterRedefinitionconstraint (see [KerML, 8.4.4.7.1]), thesubjectParameter
    of aCaseUsagewill always redefine thesubjectParameterof anyCaseDefinitionorCaseUsage
    it specializes, and so will directly or indirectly redefine the base subject parameter _Case::Case::subj_
    (see9.2.14.2.1)_._
- checkRequirementUsageObjectiveRedefinition(see8.2.2.20.2) effectively requires that the
    objectiveRequirementof aCaseUsageredefine theobjectiveRequirementsof any
    CaseDefinitionsorCaseUsagesspecialized by the firstCaseUsage, which means that it will directly
    or indirectly redefined theRequirementUsage _Cases::Case::obj_. The _obj_ feature has a default
    binding to the _result_ of the _Case,_ so, unless the default is overridden, thesubjectParameterof the
    objectiveRequirementof aCaseUsageshould conform to theresultof theCaseUsage.
- checkPartUsageActorSpecializationrequires that aPartUsagethat is owned by aCaseUsage
    via anActorMembershipspecialize thePartUsage _Cases::Case::actors_ (see8.4.7.2).
**casesubject** cs2 **specializes** subj **redefines** Cases::cases {Cases::Case::subj;
**objectiveactor** a **subsets** obj **redefines** Cases::Case::actors;Cases::Case::obj;
} **return** result **redefines** Cases::Case::result;
Additional semantics are defined for each of the more specialized kinds ofCaseUsage(see8.4.18.2on
AnalysisCaseUsages,8.4.19.2onVerificationCaseUsages, and8.4.20.2onUseCaseUsages).

**8.4.18Analysis Cases Semantics**
_Abstract syntax reference:8.3.22_
**8.4.18.1Analysis Case Definitions**
AnAnalysisCaseDefinitionis a kind ofCaseDefinition. As such, all the general semantic constraints for a
CaseDefinition(see8.3.21.2) apply to anAnalysisCaseDefinition. In addition, the
checkAnalysisCaseDefinitionSpecializationconstraint requires that anAnalysisCaseDefinition
specialize the baseAnalysisCaseDefinition _AnalysisCases::AnalysisCase_ (see9.2.15.2.2), which
subclassifies theCaseDefinition _Cases::Case_ (see9.2.14.2.1).
As discussed in8.4.17.1, thecheckRequirementUsageObjectiveRedefinitionconstraint implies that the
objectiveRequirementof anyCaseDefinitiondirectly or indirectly redefines theRequirementUsage
_Cases::Case::obj._ The _obj_ feature is then redefined in _AnalysisCases_ , with itssubjectParameterbound
to the _result_ of the _AnalysisCase,_ so that the objective is _about_ the _result._ This means that the
objectiveRequirementfor anAnalysisCaseDefinitionmust have asubjectParameterthat is consistent
with theresultof theAnalysisCaseDefinition.
TheanalysisActionproperty of anAnalysisCaseDefinition(see8.3.22.2) collects all the composite
actionsof theAnalysisCaseDefinitionthat are directly or indirectly defined by theActionDefinition
_ActivityCases::AnalysisAction_ (see9.2.15.2.1). TheAnalysisCaseDefinition

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 429**


_AnalysisCases::AnalysisCase_ then has an _analysisSteps_ feature that subsets
_Actions::Action::subaction_ (see9.2.9.2.4) and collects the values of theanalysisActions. The
checkActionUsageAnalysisActionSpecializationconstraint requires that anyActionUsagethat is an
analysisActionof anAnalysisCaseDefinitionspecialize
_AnalysisCases::AnalysisCase::analysisSteps_ (see8.4.12.2).
**analysis case defsubject** subj **redefines** AC **specializes** AnalysisCases::AnalysisCase::subj;AnalysisCases::AnalysisCase {
**objective** // AnalysisCases::AnalysisCase::obj::subj is bound toobj **redefines** AnalysisCases::AnalysisCase::obj {
// AnalysisCases::AnalysisCase::result. **subject** subj : T **redefines** AnalysisCases::AnalysisCase::obj::subj;
} **action** aa : Actions::AnalysisAction
**returnsubsets** result : TAnalysisCases::AnalysisCase::analysisSteps; **redefines** AnalysisCases::AnalysisCase::result;
}
**8.4.18.2Analysis Case Usages**
AnAnalysisCaseUsageis a kind ofCaseUsage. As such, all the general semantic constraints for aCaseUsage
(see8.4.17.2) apply to anAnalysisCaseUsage, as well as the following additional specialization constraints:

- checkAnalysisCaseUsageSpecializationconstraint requires that anAnalysisCaseUsage
    specialize the baseAnalysisCaseUsage _AnalysisCases::analysisCases_ (see9.2.15.2.3), which is
    defined by theAnalysisCaseDefinition _AnalysisCases::AnalysisCase_ (see9.2.15.2.2) and
    subsets theCaseUsage _Cases::cases_ (see9.2.14.2.2).
- checkAnalysisCaseUsageSubAnalysisCaseSpecializationrequires that an
    AnalysisCaseUsagethat is composite and has anowningTypethat is anAnalysisCaseDefinition
    orAnalysisCaseUsagespecialize theAnalysisCaseUsage
    _AnalysisCases::AnalysisCase::subAnalysisCases_ (see9.2.15.2.2), which subsets
    _AnalysisCases::analysisCases_ and theCaseUsage _Cases::Case::subcases_ (see9.2.14.2.1).
As for anAnalysisCaseDefinition(see8.4.18.1), thecheckRequirementUsageObjectiveRedefinition
constraint and the binding of _AnalysisCases::AnalysisCase::obj::subj_ imply that the
objectiveRequirementfor anAnalysisCaseUsagemust have asubjectParameterthat is consistent with
theresultof theAnalysisCaseUsage. Also similarly to anAnalysisCaseDefinition, theanalysisAction
property of anAnalysisCaseUsage(see8.3.22.3) collects all the compositeactionsof the
AnalysisCaseUsagethat are directly or indirectly defined by theActionDefinition
_ActivityCases::AnalysisAction_ (see9.2.15.2.1), and the
checkActionUsageAnalysisActionSpecializationconstraint also requires that anyActionUsagethat is an
analysisActionof anAnalysisCaseUsagespecialize _AnalysisCases::AnalysisCase::analysisSteps_
(see8.4.12.2).
**analysis casesubject** subjac **specializesredefines** AnalysisCases::AnalysisCase::subj;AnalysisCases::analysisCases {
**objective** // AnalysisCases::AnalysisCase::obj::subj is bound toobj **redefines** AnalysisCases::AnalysisCase::obj {
// AnalysisCases::AnalysisCase::result. **subject** subj : T **redefines** AnalysisCases::AnalysisCase::obj::subj;
} **action** aa : Actions::AnalysisAction
**analysis casesubsets** AnalysisCases::AnalysisCase::analysisSteps;anl1 **subsets** AnalysisCases::subAnalysisCases;
} **return** result : T **redefines** AnalysisCases::AnalysisCase::result;

**430 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**8.4.19Verification Cases Semantics**
_Abstract syntax reference:8.3.23_
**8.4.19.1Verification Case Definitions**
AVerificationCaseDefinitionis a kind ofCaseDefinition. As such, all the general semantic constraints
for aCaseDefinition(see8.3.21.2) apply to aVerificationCaseDefinition. In addition, the
checkVerificationCaseDefinitionSpecializationconstraint requires that a
VerificationCaseDefinitionspecialize the baseVerificationCaseDefinition
_VerificationCases::VerificationCase_ (see9.2.16.2.2), which subclassifies theCaseDefinition
_Cases::Case_ (see9.2.14.2.1).
As discussed in8.4.17.1, thecheckRequirementUsageObjectiveRedefinitionconstraint implies that the
objectiveRequirementof anyCaseDefinitiondirectly or indirectly redefines theRequirementUsage
_Cases::Case::obj._ The _obj_ feature is then redefined in _VerificationCase_ , with its _subj_ parameterbound
to the _subj_ parameterof the _VerificationCase,_ so that the objective is _about_ the subject of the
_VerificationCase._ This means that theobjectiveRequirementfor aVerificationCaseDefinitionmust
have asubjectParameterthat is consistent with thesubjectParameterof the
VerificationCaseDefinition.
The intent is that the objective of aVerificationCaseDefinitionis to verify the satisfaction of requirements
on the subject of theVerificationCaseDefinition. In addition to regular
RequirementConstraintMemberships(see8.4.16.2), theobjectiveRequirementof a
VerificationCaseDefinitioncan haveRequirementVerificationMembershipswhose
ownedRequirementsreference theverifiedRequirementsof theVerificationCaseDefinition. The
checkRequirementUsageRequirementVerificationSpecializationconstraint (see8.4.16.2) then requires
that aRequirementUsageowned by the objective of aVerificationCaseDefinitionvia
aRequirementVerificationMembershipspecialize theRequirementUsage
_VerificationCases::VerificationCase::obj::requirementVerifications_ , which subsets
_Requirements::RequirementCheck::subrequirements_. The _requirementVerifications_ feature thus
collects checks, in the context of the objective of the _VerificationCase,_ of the requirements to be verified, which
are then required _constraints_ on the objective of the _VerificationCase_ (since _subrequirement_ subsets
_constraints_ ).
**verification casesubject** subj : SV **specializesredefines** VerificationCases::VerificationCase::subj;VerificationCases::VerificationCase {
**objective** // VerificationCases::VerificationCase::obj::subj is bound toobj **redefines** VerificationCases::VerificationCase::obj {
// VerificationCases::VerificationCase::subj. **subject** subj : S **redefines**
VerificationCases::VerificationCase::obj::subj; **verify requirement** vr
VerificationCases::VerificationCase::obj::requirementVerifications; **subsets**
} **return** verdict **redefines** VerificationCases::VerificationCase::verdict;
}
Theresultof aVerificationCaseDefinitionis a _verdict_ that indicates whether a performance of a
_VerificationCase_ was _pass,fail,inconclusive,_ or _error._ Commonly, the _verdict_ will only be _pass_ if
the objective of the _VerificationCase_ was satisfied, meaning all the necessary requirements were verified.
However, this may not always be the desired condition for passing, so the criteria for passing must be modeled
explicitly.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 431**


**8.4.19.2Verification Case Usages**
AVerificationCaseUsageis a kind ofCaseUsage. As such, all the general semantic constraints for a
CaseUsage(see8.4.17.2) apply to aVerificationCaseUsage, as well as the following additional specialization
constraints:

- checkVerificationCaseUsageSpecializationconstraint requires that a
    VerificationCaseUsagespecialize the baseVerificationCaseUsage
    _VerificationCases::verificationCases_ (see9.2.16.2.3), which is defined by the
    VerificationCaseDefinition _VerificationCases::VerificationCase_ (see9.2.16.2.2) and
    subsets theCaseUsage _Cases::cases_ (see9.2.14.2.2).
- checkVerificationCaseUsageSubAnalysisCaseSpecializationrequires that a
    VerificationCaseUsagethat is composite and has anowningTypethat is a
    VerificationCaseDefinitionorVerificationCaseUsagespecialize the
    VerificationCaseUsage _VerificationCases::VerificationCase::subVerificationCases_
    (see9.2.16.2.2), which subsets _VerificationCases::verificationCases_ and theCaseUsage
    _Cases::Case::subcases_ (see9.2.14.2.1).
As for aVerificationCaseDefinition(see8.4.19.1), the
checkRequirementUsageObjectiveRedefinitionconstraint and the binding of
_VerificationCases::VerificationCase::obj::subj_ imply that theobjectiveRequirementfor a
VerificationCaseUsagemust have asubjectParameterthat is consistent with thesubjectParameterof
theVerificationCaseUsage. Also similarly to aVerificationCaseDefinition, the
objectiveRequirementof aVerificationCaseUsagemay ownRequirementUsagesvia
RequirementVerificationMemberships, to which the
checkRequirementUsageRequirementVerificationSpecializationconstraint applies (see8.4.16.2).
**verificationsubject** subj : Sv **specializesredefines** VerificationCases::VerificationCase {VerificationCases::VerificationCase::subj;
**objective** // VerificationCases::VerificationCase::obj::subj is bound toobj **redefines** VerificationCases::VerificationCase::obj {
// VerificationCases::VerificationCase::subj. **subject** subj : S **redefines**
VerificationCases::VerificationCase::obj::subj; **verify requirement** vr
VerificationCases::VerificationCase::obj::requirementVerifications; **subsets**
} **verification** v1 **subsets**
VerificationCases::VerificationCase::subVerificationCases; **return** verdict **redefines** VerificationCases::VerificationCase::verdict;
}
As discussed for aVerificationCaseDefinition(see8.4.19.1), the result of aVerificationCaseUsageis a
_verdict_ on whether a _VerificationCase_ passes.

**8.4.20Use Cases Semantics**
_Abstract syntax reference:8.3.24_
**8.4.20.1Use Case Definitions**
AUseCaseDefinitionis a kind ofCaseDefinition. As such, all the general semantic constraints for a
CaseDefinition(see8.3.21.2) apply to aUseCaseDefinition. In addition, the
checkUseCaseDefinitionSpecializationconstraint requires that aUseCaseDefinitionspecialize the base

**432 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


UseCaseDefinition _UseCases::UseCase_ (see9.2.17.2.1), which subclassifies theCaseDefinition
_Cases::Case_ (see9.2.14.2.1).
**use case defsubject** subjUC **specializesredefines** Cases::Case::subj;UseCases::UseCase {
**objectiveactor** a **subsets** obj **redefines** Cases::Case::actors;Cases::Case::obj;
} **return** result **redefines** Cases::Case::result;
**8.4.20.2Use Case Usages**
AUseCaseUsageis a kind ofCaseUsage. As such, all the general semantic constraints for aCaseUsage(see
8.4.17.2) apply to aUseCaseUsage, as well as the following additional specialization constraints:

- checkUseCaseUsageSpecializationconstraint requires that aUseCaseUsagespecialize the base
    UseCaseUsage _UseCases::useCases_ (see9.2.17.2.2), which is defined by theUseCaseDefinition
    _UseCases::UseCase_ (see9.2.17.2.1) and subsets theCaseUsage _Cases::cases_ (see9.2.14.2.2).
- checkUseCaseUsageSubAnalysisCaseSpecializationrequires that aUseCaseUsagethat is
    composite and has anowningTypethat is aUseCaseDefinitionorUseCaseUsagespecialize the
    UseCaseUsage _UseCases::UseCase::subUseCases_ (see9.2.17.2.1), which subsets
    _UseCases::useCases_ and theCaseUsage _Cases::Case::subcases_ (see9.2.14.2.1).
**use casesubject** uc **specializes** subj **redefines** UseCases::useCases {UseCases::Case::subj;
**objectiveactor** a **subsets** obj **redefines** Cases::Case::actors;UseCases::Case::obj;
**use casereturn** resultuc1 **subsetsredefines** UseCases::UseCase::subUseCases;UseCases::UseCase::result;
}
**8.4.20.3Include Use Case Usages**
AnIncludeUseCaseUsageis a kind ofUseCaseUsageand a kind ofPerformActionUsage. As such, all
general semantic constraints on aUseCaseUsage(see8.4.20.2) and aPerformActionUsage(see8.4.12.10) also
apply to aIncludeUseCaseUsage. In particular,validateEventOccurrenceUsageIsReferencerequires an
IncludeUseCaseUsageto be referential. In addition, if anIncludeUseCaseUsagehas anowningTypethat is a
UseCaseDefinitionorUseCaseUsage, then thecheckUseCaseUsageSpecializationconstraint requires
that it specialize theUseCaseUsage _UseCases::UseCase::includedUseCases_ (see9.2.17.2.1), which subsets
_UseCases::useCases_ (see9.2.17.2.2) and the kernel Feature
_Performances::Performance::enclosedPerformances_ (see [KerML, 9.2.6]).
For example, the following model:
**use caseuse case** uc1;uc2 {
} **include use case** incl **references** uc1;
is, with impliedSpecializationsincluded, semantically equivalent to
**use caseuse case** uc1uc2 **subsetssubsets** UseCases::useCases;UseCases::useCases {
**refsubsetsuse case** UseCases::UseCase::includedUseCases;incl **references** uc1
}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 433**


Thus, the values of _uc2.incl_ will be the subset of the _UseCases_ represented by _uc1_ that are performed within
_uc2._
If theIncludeUseCaseUsagehas aReferenceSubsetting, then this will suffice to satisfy the
checkUseCaseUsageSpecializationconstraint, if the referencedUseCaseUsagedoes. However, if it does not
have aReferenceSubsetting(or other relevant explicitownedSpecialization), it requires an implied
Subsettingof _UseCases::useCases._
**use case definclude use case** UIU **specializes** iu1 **references** UseCases::UseCases {uc1
**include use casesubsets** UseCases::UseCase::includedUseCases;iu2 **subsets** UseCases::useCases
} **subsets** UseCases::UseCase::includedUseCases;
AnExhibitStateUsagethat is anownedFeatureof anActionDefinitionorActionUsageother than a
UseCaseDefinitionorUseCaseUsagehas the same semantics as aPerformActionUsagein that context (see
7.16.6, with aUseCaseUsageas itsperformedAction. If it is anownedFeatureof an
OccurrenceDefinitionorOccurrenceUsagethat is _not_ anActionDefinitionorActionUsage, it has the
same semantics as anEventOccurrenceUsagein that context (see8.4.5.3). Otherwise, it has the same semantics
as a referentialUseCaseUsage(see8.4.13.2).

**8.4.21Views and Viewpoints Semantics**
_Abstract syntax reference:8.3.25_
**8.4.21.1View Definitions**
AViewDefinitionis a kind ofPartDefinition. As such, all the general semantic constraints for an
PartDefinition(see8.4.7.1) also apply to aViewDefinition. In addition, the
checkViewDefinitionSpecializationconstraint requires that aViewDefinitionspecialize the base
ViewDefinition _Views::View_ (see9.2.18.2.10), which subclassifies _Parts::Part_ (see9.2.4.2.1)_._
**8.4.21.2View Usages**
AViewUsageis a kind ofPartUsage. As such, all the general semantic constraints for anPartUsage
(see8.4.7.2) also apply to aViewUsage, as well as the following additional specialization constraints:

- checkViewUsageSpecializationrequires that aViewUsagespecialize the baseViewUsage
    _Views::views_ (see9.2.18.2.14).
- checkViewUsageSubviewSpecializationrequires that aViewUsagethat is composite and has an
    owningTypethat is aViewDefinitionorViewUsagespecialize theViewUsage
    _Views::View::subviews_ (see9.2.18.2.10), which subsets _Views::views_.
**viewrefdefview** V **specializes** v1 **subsets** Views::View {Views::views;
} **view** v2 **subsets** Views::View::subviews;
**8.4.21.3Viewpoint Definitions**
AViewpointDefinitionis a kind ofRequirementDefinition. As such, all the general semantic constraints
for aRequirementDefinition(see8.4.16.1) also apply to aViewpointDefinition. In addition, the
checkViewpointDefinitionSpecializationconstraint requires that aViewpointDefinitionspecialize

**434 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


the baseViewpointDefinition _Views::ViewpointCheck_ (see9.2.18.2.11), which specializes the
RequirementDefinition _Requirements::RequirementCheck_ (see9.2.13.2.8).
**viewpoint defviewpoint def** VpVp1 **specializesspecializes** Viewpoints::ViewpointCheck;Vp;

**8.4.21.4Viewpoint Usages**
AViewpointUsageis a kind ofRequirementUsage. As such, all the general semantic constraints for a
RequirementUsage(see8.4.16.2) also apply to aViewpointUsage, as well as the following additional
specialization constraints:

- checkViewpointUsageSpecializationrequires that aViewpointUsagespecialize the base
    ViewpointUsage _Views::viewpointChecks_ (see9.2.18.2.12), which subsets
    _Requirements::requirementChecks_ (see9.2.13.2.9).
**viewpoint** vp : Vp **subsets** Views::viewpointChecks;
- checkViewpointUsageViewpointSatisfactionSpecializationrequires that a composite
    ViewpointUsagewhoseowningTypeis aViewDefinitionorViewUsagespecialize the
    ViewpointUsage _Views::View::viewpointSatisfactions_ (see9.2.18.2.10), which subsets
    _Views::viewpointChecks_. Since the _Views::View_ model asserts the satisfaction of the
    _viewpointSatisfactions_ , this means that any compositeViewpointUsagethat is an
    ownedFeatureof aViewDefinitionorViewpointUsageis implicitly asserted to be satisfied by the
    specified _View._
**view def** // The following ViewpointUsage is implicitly asserted to beVw **subsets** Views::View {
// satisfied by the Views defined by Vw. **viewpoint** vp1 : Vp1 **subsets** Views::View::viewpointSatisfactions;
}
**8.4.21.5Rendering Definitions**
ARenderingDefinitionis a kind ofPartDefinition. As such, all the general semantic constraints for a
PartDefinition(see8.4.7.1) also apply to aViewDefinition. In addition, the
checkRenderingDefinitionSpecializationconstraint requires that aRenderingDefinitionspecialize
the baseRenderingDefinition _Views::Rendering_ (see9.2.18.2.6), which subclassifies _Parts::Part_ (see
9.2.4.2.1)_._
**8.4.21.6Rendering Usages**
ARenderingUsageis a kind ofPartUsage. As such, all the general semantic constraints for anPartUsage
(see8.4.7.2) also apply to aRenderingUsage, as well as the following additional specialization constraints:
- checkRenderingUsageSpecializationrequires that aRenderingUsagespecialize the base
RenderingUsage _Views::rendering_ (see9.2.18.2.7).
- checkRenderingUsageSubrenderingSpecializationrequires that aRenderingUsagethat is
composite and has anowningTypethat is aRenderingDefinitionorRenderingUsagespecialize the
RenderingUsage _Views::Rendering::subrenderings_ (see9.2.18.2.6), which subsets
_Renderings::renderings_.
**renderingrefrenderingdef** Rnd **specializes** rnd1 **subsets** Renderings::Rendering {Renderings::renderings;

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 435**


```
} view rnd2 subsets Renderings::Rendering::subrenderings;
```
- checkRenderingUsageRedefinitionrequires that aRenderingUsagethat is owned by a
    ViewDefinitionorViewUsagevia aViewRenderingMembershipredefines theviewRenderingof
    eachViewDefinitionorViewUsagethat is specialized by the owningViewDefinitionor
    ViewUsage. This means that theviewRenderingof aViewDefinitionorViewUsagewill always
    directly or indirectly redefined theRenderingUsage _Views::View::viewRendering_ (see
    9.2.18.2.10).
**renderingrendering** r1;r2;
**view defrender** VRr1 **specializesredefines** Views::View {Views::View::viewRendering;
} **view def** vr : VR {
} **render** r2 **redefines** VR::r1;

**8.4.22Metadata Semantics**
_Abstract syntax reference:8.3.26_
**8.4.22.1Metadata Definitions**
AMetadataDefinitionis a kind ofItemDefinitionand a kind of KerMLMetaclass. As such, the general
semantic constraints for anItemDefinition(see8.4.6.1) and aMetaclass(see [KerML, 8.4.4.13]) also apply to
aMetadataDefinition. In addition, thecheckMetadataDefinitionSpecializationconstraint requires that
aMetadataDefinitionspecialize the baseMetadataDefinition _Metadata::MetadataItem_ (see
9.2.20.2.1), which subclassifies _Items::Item_ (see9.2.3.2.1) and the kernelMetaclass
_Metaobjects::Metaobject_ (see [KerML, 9.2.16]).
The instances of aMetadataDefinitionare _MetadataItems_ that are part of the structure of a model itself,
rather than being an instance in the system represented by the model. The _SysML_ library model is a reflective model
of the MOF abstract syntax for SysML, containing one SysMLMetadataDefinitioncorresponding to each MOF
metaclass in the abstract syntax model (see9.2.21for more details on the relationship between the _SysML_ model and
the abstract syntax).
**8.4.22.2Metadata Usages**
AMetadataUsageis a kind ofItemUsageand a kind of KerMLMetadataFeature. As such, the general
semantic constraints for anItemUsage(see8.4.6.2) and aMetadataFeature(see [KerML, 8.4.4.13]) also apply
to aMetadataUsage. In addition, thecheckMetadataUsageSpecializationconstraint requires that a
MetadataUsagespecialize the baseMetadataUsage _Metadata::metadataItems_ (see9.2.20.2.2), which is
defined by _Metadata::MetadataItem_ (see9.2.20.2.1) and subsets _Items::items_ (see9.2.3.2.2) and the kernel
Feature _Metaobjects::metaobjects_ (see [KerML, 9.2.16]).
See [KerML, 8.4.4.13.2] for further description of the model-level semantics ofMetadataUsagesas
MetadataFeaturesthat can be used to annotateElementsof a model. See also [KerML, 8.4.4.13.3] for a
discussion of _semantic metadata_ that is also usable in SysML.

**436 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## 9 Model Libraries.............................................................................................................................................................................

**9.1Model Libraries Overview**
The SysML model libraries are an integral part of the language. The Systems Model Library (see9.2) is used any
time a Definition or Usage element is instantiated in a user model, providing a bridge to the semantic models in the
Kernel Model Library [KerML, Clause 8]. For example, any ItemDefinition or ItemUsage must directly or indirectly
specialize the base ItemDefinition _Item_ from the _Items_ library model, where _Item_ specializes the Kernel Class
_Object,_ giving Items the semantics of structural Objects.
SysML also includes a set of domain libraries, which provide models of fundamental concepts from domains of
particular importance in systems engineering. These models are normative and available for use in all SysML user
models. The following domain libraries are included.

- The _Metadata Domain Library_ contains models of attribute definitions for a useful set of standard
    metadata annotations (see9.3; see also7.4on Annotations).
- The _Analysis Domain Library_ contains models of concepts useful in carrying out analyses of systems. In
    particular, it includes frameworks for state space representation of systems and for performing trade-off
    studies (see9.4)_._
- The _Cause and Effect Domain Library_ contains a language extension for modeling cause and effect
    relationships (see9.5).
- The _Requirement DerivationDomain Library_ contains a language extension for modeling requirement
    derivation relationships (see9.6).
- The _Geometry Domain Library_ contains a model for physical items with spacial extent, including an
    extensive set of basic geometric shapes that can be used to construct such items (see9.7).
- The _Quantities and Units Domain Library_ contains a comprehensive set of models for scalar, vector and
    tensor quantities, including quantity value and unit definitions covering the ISO/IEC 80000 and ISO
    8601-1 standards (see9.8).
The normative machine-readable representation for each of these model libraries is a project interchange file,
formatted consistent with the standard for model interchange given in [KerML, 10.3], as specified for SysML in
Clause 2 under _Model Interchange Conformance_. The documentation on these models provided in here inClause 9
is either derived from the model files themselves or gives additional overview information on the use of the models,
and is therefore also considered normative.
Each library model is packaged as a model interchange file in the project interchange file for its corresponding
model library (see [KerML, 10.2]). Regardless of whether such a library model is interchanged in textual notation,
XMI or JSON format, theelementIdfor anyElementin the library model that has a non-nullqualifiedName
shall be a name-based (version 5) UUID (see [UUID, 14.2]), constructed as specified in [KerML, 9.1], expect using
the prefixhttps://www.omg.org/SysML/when constructing the URL for a standard library package. The
elementIdsconstructed in this way shall be normative across all forms of interchange of the library models and
shall remain stable for future versions of the library models, though future revisions of this specification may
deprecate certain existingElementsand their names, or introduce newElementswith new names and hence
UUIDs that are distinct (with a high probability). However, theelementIdsfor libraryElementsfor which the
qualifiedNameis null are _not_ determined by this specification, and representations of the models with different
elementIdsfor theseElements(such as may happen when parsing the textual representation of a library model)
are still considered conformant to the specification.

**9.2Systems Model Library**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 437**


**9.2.1Systems Model Library Overview**
The Systems Model Library includes models for the base types of all kinds ofDefinitionandUsageelements in
SysML. Each of the following subclauses describes a library model package corresponding to the elements in the
similarly named abstract syntax package (see8.3). For example, the _Attributes_ library model package (see9.2.2)
includes the _Attribute_ and _attributes_ types that are the base types for allAttributeDefinitionsand
AttributeUsages(respectively) as specified in theAttributesabstract syntax package (see8.3.7).
It also includes a package of _StandardViewDefinitions_ (see9.2.19) and a reflective _SysML_ model of the
SysML abstract syntax (see9.2.21).

**9.2.2Attributes
9.2.2.1Attributes Overview**
This package defines the base types for attributes and related structural elements in the SysML language.
**9.2.2.2Elements
9.2.2.2.1 AttributeValue
Element**
AttributeDefinition
**Description**
AttributeValue is the most general type of data values that represent qualities or characteristics of a system or part of
a system. AttributeValue is the base type of all AttributeDefinitions.
**General Types**
DataValue
**Features**
None.
**Constraints**
None.
**9.2.2.2.2 attributeValues
Element**
AttributeUsage
**Description**
attributeValuesis the base feature for all AttributeUsages.
**General Types**
AttributeValue
dataValues

**438 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
None.
**Constraints**
None.

**9.2.3Items
9.2.3.1Items Overview**
This package defines the base types for items and related structural elements in the SysML language.
**9.2.3.2Elements
9.2.3.2.1 Item
Element**
ItemDefinition
**Description**
Item is the most general class of objects that are part of, exist in or flow through a system. Item is the base type of all
ItemDefinitions.
**General Types**
Object
**Features**
boundingShapes : Item [0..*] {subsets envelopingShapes}
Enveloping shapes that are StructuredSpaceObjects with everyfaceor everyedgeintersecting this Item.
checkedConstraints : ConstraintCheck [0..*] {subsets ownedPerformances}
Constraints that have been checked by this Item.
envelopingShapes : Item [0..*]
Shapes that are theshapeof an Item that includes this Item in space and time.
isSolid : Boolean
An Item is solid if it has novoids.
shape : Item {redefines spaceBoundary}
Spatial boundary of this Item.
subitems : Item [0..*] {subsets suboccurrences}
The Items that are composite subitems of this Item.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 439**


subparts : Part [0..*] {subsets subitems}
Thesubitemsof this item that areparts.
voids : Item [0..*] {redefines innerSpaceOccurrences}
Voids are theinnerSpaceOccurrencesof this Item.
**Constraints**
None.
**9.2.3.2.2 items
Element**
ItemUsage
**Description**
_items_ is the base feature of all ItemUsages.
**General Types**
objects
Item
**Features**
None.
**Constraints**
None.
**9.2.3.2.3 Touches
Element**
ConnectionDefinition
**Description**
Touching Occurrences are JustOutsideOf each other and happen at the same time (HappensWhile).
**General Types**
HappensWhile
JustOutsideOf
**Features**
touchedItem : Item {redefines separateSpace, thatOccurrence}
touchedItemToo : Item {redefines thisOccurrence, separateSpaceToo}

**440 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


touches : Item [0..*] {subsets justOutsideOfOccurrences, timeCoincidentOccurrences}
touchesToo : Item [0..*] {subsets timeCoincidentOccurrences, justOutsideOfOccurrences}
**Constraints**
None.

**9.2.4Parts
9.2.4.1Parts Overview**
This package defines the base types for parts and related structural elements in the SysML language.
**9.2.4.2Elements
9.2.4.2.1 Part
Element**
PartDefinition
**Description**
Part is the most general class of objects that represent all or a part of a system. Part is the base type of all
PartDefinitions.
**General Types**
Item
**Features**
exhibitedStates : StateAction [0..*] {subsets performedActions}
StateActions that are exhibited by this Part.
ownedActions : Action [0..*] {subsets ownedPerformances}
Actions that are owned by this Part. Thethisreference of aownedActionis always its owning Part.
ownedPorts : Port [0..*] {subsets timeEnclosedOccurrences}
Ports that are owned by this Part.
ownedStates : StateAction [0..*] {subsets ownedActions}
StateActions that are owned by this Part.
performedActions : Action [0..*] {subsets enactedPerformances}
Actions that are performed by this Part.
**Constraints**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 441**


**9.2.4.2.2 parts
Element**
PartUsage
**Description**
partsis the base feature of all PartUsages.
**General Types**
Part
items
**Features**
None.
**Constraints**
None.

**9.2.5Ports
9.2.5.1Ports Overview**
This package defines the base types for ports and related structural elements in the SysML language.
**9.2.5.2Elements
9.2.5.2.1 Port
Element**
PortDefinition
**Description**
Port is the most general class of objects that represent connection points for interacting with a Part. Port is the base
type of all PortDefinitions.
**General Types**
Object
**Features**
subports : Port [0..*] {subsets timeEnclosedOccurrences}
**Constraints**
None.

**442 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.2.5.2.2 ports
Element**
PortUsage
**Description**
portsis the base feature of all PortUsages.
**General Types**
Port
objects
**Features**
None.
**Constraints**
None.

**9.2.6Connections
9.2.6.1Connections Overview**
This package defines the base types for connections and related structural elements in the SysML language.
**9.2.6.2Elements
9.2.6.2.1 BinaryConnection
Element**
ConnectionDefinition
**Description**
BinaryConnection is the most general class of binary links between two things within some containing structure.
BinaryConnection is the base type of all ConnectionDefinitions with exactly two ends.
**General Types**
Connection
BinaryLinkObject
**Features**
source : Anything [0..*] {redefines toSources, source}
target : Anything [0..*] {redefines toTargets, target}
**Constraints**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 443**


**9.2.6.2.2 binaryConnections
Element**
ConnectionUsage
**Description**
binaryConnectionsis the base feature of all binary ConnectionUsages.
**General Types**
binaryLinkObjects
connections
BinaryConnection
**Features**
[no name] : Anything
[no name] : Anything
**Constraints**
None.
**9.2.6.2.3 Connection
Element**
ConnectionDefinition
**Description**
Connection is the most general class of links between things within some containing structure. Connection is the
base type of all ConnectionDefinitions.
**General Types**
LinkObject
Part
**Features**
None.
**Constraints**
None.
**9.2.6.2.4 connections
Element**
ConcernUsage

**444 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Description**
connectionsis the base feature of all ConnectionUsages.
**General Types**
parts
linkObjects
**Features**
None.
**Constraints**
None.
**9.2.6.2.5 FlowConnection
Element**
FlowConnectionDefinition
**Description**
FlowConnection is a subclass of message connections that are also flow transfers. It is the base type for
FlowConnectionUsages that identify theirsourceoutput andtargetinput.
**General Types**
MessageConnection
FlowTransfer
**Features**
source : Occurrence [0..*] {redefines source}
target : Occurrence [0..*] {redefines target}
**Constraints**
None.
**9.2.6.2.6 flowConnections
Element**
FlowConnectionUsage
**Description**
flowConnectionsis the base feature of all FlowConnectionUsages.
**General Types**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 445**


messageConnections
FlowConnection
flowTransfers
**Features**
source : Occurrence [0..*] {redefines source}
target : Occurrence [0..*] {redefines target}
**Constraints**
None.
**9.2.6.2.7 MessageConnection
Element**
ConnectionDefinition
**Description**
MessageConnection is the class of binary connections that represent a transfer of objects or values between two
occurrences. It is the base type of all FlowConnectionDefinitions.
**General Types**
Transfer
BinaryConnection
Action
**Features**
source : Occurrence [0..*] {redefines toTransferSources, source}
target : Occurrence [0..*] {redefines target, toTransferTargets}
**Constraints**
None.
**9.2.6.2.8 messageConnections
Element**
FlowConnectionUsage
**Description**
messageConnectionsis the base feature of all FlowConnectionUsages.
**General Types**
MessageConnection
transfers

**446 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


binaryConnections
actions
**Features**
[no name] : Occurrence
[no name] : Occurrence
**Constraints**
None.
**9.2.6.2.9 SuccessionFlowConnection
Element**
FlowConnectionDefinition
**Description**
SuccessionFlowConnection is a subclass of flow connections that happen after theirsourceand before their
target. It is the base type for all SuccessionFlowConnectionUsages.
**General Types**
FlowConnection
FlowTransferBefore
**Features**
source : Occurrence [0..*] {redefines source}
target : Occurrence [0..*] {redefines target}
**Constraints**
None.
**9.2.6.2.10 successionFlowConnections
Element**
FlowConnectionUsage
**Description**
successionFlowConnectionsis the base feature of all SuccessionFlowConnectionUsages.
**General Types**
transfersBefore
flowConnections
SuccessionFlowConnection

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 447**


**Features**
source : Occurrence [0..*] {redefines source}
target : Occurrence [0..*] {redefines target}
**Constraints**
None.

**9.2.7Interfaces
9.2.7.1Interfaces Overview**
This package defines the base types for interfaces and related structural elements in the SysML language.
**9.2.7.2Elements
9.2.7.2.1 BinaryInterface
Element**
InterfaceDefinition
**Description**
_BinaryInterface_ is the most general class of links between twoPortUsageswithin some containing structure.
BinaryInterfaceis the baseTypeof allInterfaceDefinitionswith exactly two ends.
**General Types**
BinaryConnection
Interface
**Features**
source : Port [0..*] {redefines source}
target : Port [0..*] {redefines target}
**Constraints**
None.
**9.2.7.2.2 binaryInterfaces
Element**
InterfaceUsage
**Description**
_binaryInterfaces_ is the base feature of all binaryInterfaceUsages.
**General Types**

**448 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


BinaryInterface
interfaces
binaryConnections
**Features**
[no name] : Port
[no name] : Port
**Constraints**
None.
**9.2.7.2.3 Interface
Element**
InterfaceDefinition
**Description**
_Interface_ is the most general class of links betweenPortUsageswithin some containing structure.Interface
is the baseTypeof allInterfaceDefinitions.
**General Types**
Connection
**Features**
None.
**Constraints**
None.
**9.2.7.2.4 interfaces
Element**
InterfaceUsage
**Description**
_interfaces_ is the base feature of allInterfaceUsages.
**General Types**
connections
Interface
**Features**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 449**


**Constraints**
None.

**9.2.8Allocations
9.2.8.1Allocations Overview**
This package defines the base types for allocations and related structural elements in the SysML language.
**9.2.8.2Elements
9.2.8.2.1 Allocation
Element**
AllocationDefinition
**Description**
Allocation is the most general class of allocation, represented as a connection between the source of the allocation
and the target. Allocation is the base type of all AllocationDefinitions.
**General Types**
BinaryConnection
**Features**
source : Anything [0..*] {redefines source}
suballocations : Allocation [0..*]
target : Anything [0..*] {redefines target}
**Constraints**
None.
**9.2.8.2.2 allocations
Element**
AllocationUsage
**Description**
allocationsis the base feature of all ConnectionUsages.
**General Types**
Allocation
binaryConnections
**Features**

**450 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


[no name] : Anything
[no name] : Anything
**Constraints**
None.

**9.2.9Actions
9.2.9.1Actions Overview**
This package defines the base types for actions and related behavioral elements in the SysML language.
**9.2.9.2Elements
9.2.9.2.1 AcceptAction
Element**
ActionDefinition
**Description**
An _AcceptAction_ is a _AcceptMessageAction_ that waits for a _payload_ or _acceptedMessage_ of the specified
kind to be accepted by a state transition nested in it.
**General Types**
AcceptMessageAction
**Features**
None.
**Constraints**
None.
**9.2.9.2.2 acceptActions
Element**
ActionUsage
**Description**
acceptActionsis the base feature for all SendActionUsages.
**General Types**
AcceptAction
actions
**Features**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 451**


None.
**Constraints**
None.
**9.2.9.2.3 AcceptMessageAction
Element**
ActionDefinition
**Description**
An _AcceptMessageAction_ is an _Action_ and _AcceptPerformance_ that identifies an
_incomingTransferToSelf_ of a designated _receiverOccurrence_ , providing its _payload_ as output.
**General Types**
AcceptPerformance
Action
**Features**
acceptedMessage : MessageConnection {redefines acceptedTransfer}
payload : Anything {redefines acceptedItem}
The payload received from the incoming _Transfer_. If an input value is provided for this parameter, then the
_Transfer_ payload must match that value.
**Constraints**
None.
**9.2.9.2.4 Action
Element**
ActionDefinition
**Description**
_Action_ is the most general class of performances of ActionDefinitions in a system or part of a system. _Action_ is
the base class of all ActionDefinitions.
**General Types**
Performance
**Features**
acceptSubactions : AcceptAction [0..*] {subsets subactions}
The _subactions_ of this Action that are _AcceptActions_.

**452 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


assignments : AssignmentAction [0..*] {subsets subactions}
The _subactions_ of this Action that are _AssignmentActions_.
controls : ControlAction [0..*] {subsets subactions}
The _subactions_ of this _Action_ that are _ControlActions_.
decisions : DecisionAction [0..*] {subsets controls}
The _controls_ of this _Action_ that are _DecisionActions_.
decisionTransitions : DecisionTransitionAction [0..*] {subsets transitions}
The _subactions_ of this _Action_ that are _DecisionTransitionActions_.
done : Action {redefines endShot}
The ending _snapshot_ of this _Action_.
forks : ForkAction [0..*] {subsets controls}
The _controls_ of this _Action_ that are _ForkActions_.
forLoops : ForLoopAction [0..*] {subsets loops}
The _loops_ of this _Action_ that are _ForLoopActions_.
ifSubactions : IfThenAction [0..*] {subsets subactions}
The _subactions_ of this Action that are _IfThenActions_ (including _IfThenElseActions_ ).
joins : JoinAction [0..*] {subsets controls}
The _controls_ of this activity that are _JoinActions_.
loops : LoopAction [0..*] {subsets subactions}
The _subactions_ of this _Action_ that are _LoopActions_.
merges : MergeAction [0..*] {subsets controls}
The _controls_ of this _Action_ that are _MergeActions_.
sendSubactions : SendAction [0..*] {subsets subactions}
The _subactions_ of this _Action_ that are _SendActions_.
start : Action {redefines startShot}
The starting _snapshot_ of this _Action_.
subactions : Action [0..*] {subsets enclosedPerformances}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 453**


The _subperformances_ of this _Action_ that are _Actions_. The _this_ reference of a _subaction_ is always the same
as that of its owning Action.
transitions : TransitionAction [0..*] {subsets subactions}
The _subactions_ of this _Action_ that are _TransitionActions_.
whileLoops : WhileLoopAction [0..*] {subsets loops}
The _loops_ of this _Action_ that are _WhileLoopActions_.
**Constraints**
None.
**9.2.9.2.5 actions
Element**
ActionUsage
**Description**
_actions_ is the base feature for all ActionUsages.
**General Types**
Action
performances
**Features**
None.
**Constraints**
None.
**9.2.9.2.6 AssignmentAction
Element**
ActionDefinition
**Description**
An _AssignmentAction_ is an _Action_ used to type an AssignmentActionUsage. It is also a
_FeatureWritePerformance_ that updates the _accessedFeature_ of its target _Occurrence_ with the given
_replacementValues_.
**General Types**
Action
FeatureWritePerformance

**454 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
replacementValues : Anything [0..*] {redefines replacementValues}
The values to be assigned to the _accessedFeature_ of the _target_.
target : Occurrence {redefines onOccurrence}
The target _Occurrence_ whose _accessedFeature_ is being assigned.
**Constraints**
None.
**9.2.9.2.7 assignmentActions
Element**
ActionUsage
**Description**
_assignmentActions_ is the base feature for all AssignmentActionUsages.
**General Types**
AssignmentAction
actions
**Features**
None.
**Constraints**
None.
**9.2.9.2.8 ControlAction
Element**
ActionDefinition
**Description**
A _ControlAction_ is the _Action_ of a ControlNode, which has no inherent behavior.
**General Types**
Action
**Features**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 455**


**Constraints**
None.
**9.2.9.2.9 DecisionAction
Element**
ActionDefinition
**Description**
A _DecisionAction_ is the _ControlAction_ for a DecisionNode. It is a _DecisionPerformance_ that selects one
outgoing _HappensBeforeLink_.
**General Types**
DecisionPerformance
ControlAction
**Features**
None.
**Constraints**
None.
**9.2.9.2.10 DecisionTransitionAction
Element**
ActionDefinition
**Description**
A DecisionTransitionAction is a TransitionAction and NonStateTransitionPerformance that has a singleguard, but
notriggeroreffects. It is the base type of TransitionUsages used as conditional successions in action models.
**General Types**
NonStateTransitionPerformance
TransitionAction
**Features**
accepter : AcceptMessageAction {redefines accepter}
effect : Action {redefines effect}
**Constraints**
None.

**456 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.2.9.2.11 ForkAction
Element**
ActionDefinition
**Description**
A _ForkAction_ is the _ControlAction_ for a ForkNode.
Note: Fork behavior results from requiring that the target multiplicity of all outgoing succession connectors be 1..1.
**General Types**
ControlAction
**Features**
None.
**Constraints**
None.
**9.2.9.2.12 ForLoopAction
Element**
ActionDefinition
**Description**
A _ForLoopAction_ is a _LoopAction_ that iterates over an ordered sequence of values. It is the base type for all
ForLoopActionUsages.
**General Types**
LoopAction
**Features**
body : Action [0..*] {redefines body}
The _Action_ that is performed on each iteration of the loop.
index : Positive
The index of the element of _seq_ assigned to _var_ on the current iteration of the loop.
initialization : AssignmentAction
Initializes _index_ to 1.
seq : Anything [0..*] {ordered, nonunique}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 457**


The sequence of values over which the loop iterates.
var : Anything
The loop variable that is assigned successive elements of _seq_ on each iteration of the loop.
whileLoop : WhileLoopAction
While _index_ is less than or equal to the size of _seq_ , assigns _var_ to the _index_ element of _seq_ , then performs _body_
and increments _index_.
**Constraints**
None.
**9.2.9.2.13 forLoopActions
Element**
ActionUsage
**Description**
_forLoopActions_ is the base feature for all ForLoopActionUsages.
**General Types**
loopActions
ForLoopAction
**Features**
None.
**Constraints**
None.
**9.2.9.2.14 IfThenAction
Element**
ActionDefinition
**Description**
An _IfThenAction_ is a Kernel _IfThenPerformance_ that is also an Action. It is the base type for all
IfActionUsages.
**General Types**
Action
IfThenPerformance
**Features**

**458 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ifTest : BooleanEvaluation {redefines ifTest}
An evaluation of a _Boolean_ -valued Expression whose result determines whether or not the _thenClause_ is
performed.
thenClause : Performance [0..1] {redefines thenClause}
An optional _Performance_ that occurs if and only if the result of the _ifTest_ is true.
**Constraints**
None.
**9.2.9.2.15 ifThenActions
Element**
ActionUsage
**Description**
_ifThenActions_ is the base feature for all IfActionUsages.
**General Types**
IfThenAction
actions
**Features**
None.
**Constraints**
None.
**9.2.9.2.16 IfThenElseAction
Element**
ActionDefinition
**Description**
An _IfThenElseAction_ is a Kernel _IfThenElsePeformance_ that is also an _IfThenAction_. It is the base type
for all IfActionUsages that have anelseAction.
**General Types**
IfThenAction
IfThenElsePerformance
**Features**
elseClause : Performance [0..1] {redefines elseClause}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 459**


An optional _Performance_ that occurs if and only if the result of the _ifTest_ is false.
**Constraints**
None.
**9.2.9.2.17 ifThenElseActions
Element**
ActionUsage
**Description**
ifThenElseactionsis the base feature for all IfActionUsages that have anelseAction.
**General Types**
IfThenElseAction
ifThenActions
**Features**
None.
**Constraints**
None.
**9.2.9.2.18 JoinAction
Element**
ActionDefinition
**Description**
A _JoinAction_ is the _ControlAction_ for a JoinNode.
Note: Join behavior results from requiring that the source multiplicity of all incoming succession connectors be 1..1.
**General Types**
ControlAction
**Features**
None.
**Constraints**
None.

**460 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.2.9.2.19 LoopAction
Element**
ActionDefinition
**Description**
A _LoopAction_ is the base type for all _LoopActionUsages_.
**General Types**
Action
**Features**
body : Action [0..*]
The action that is performed repeatedly in the loop.
**Constraints**
None.
**9.2.9.2.20 loopActions
Element**
ActionUsage
**Description**
_loopActions_ is the base feature for all LoopActionUsages.
**General Types**
actions
LoopAction
**Features**
None.
**Constraints**
None.
**9.2.9.2.21 MergeAction
Element**
ActionDefinition
**Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 461**


A _MergeAction_ is the _ControlAction_ for a MergeNode. It is a _MergePerformance_ that selects exactly one
incoming _HappensBefore_ link.
**General Types**
ControlAction
MergePerformance
**Features**
None.
**Constraints**
None.
**9.2.9.2.22 SendAction
Element**
ActionDefinition
**Description**
A _SendAction_ is an _Action_ and _SendPerformance_ used to type a SendActionUsage. It initiates an
_outgoingTransferFromSelf_ from a designated _sender Occurrence_ with a given _payload_ ,
optionally to a designated _receiverOccurrence_.
**General Types**
SendPerformance
Action
**Features**
payload : Anything {redefines sentItem}
The payload to be sent in the outgoing _Transfer_.
sentMessage : MessageConnection {redefines sentTransfer}
**Constraints**
None.
**9.2.9.2.23 sendActions
Element**
ActionUsage
**Description**
sendActionsis the base feature for all SendActionUsages.

**462 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Types**
actions
SendAction
**Features**
None.
**Constraints**
None.
**9.2.9.2.24 TransitionAction
Element**
ActionDefinition
**Description**
A TransitionAction is a TransitionPerformance with an Action astransitionLinkSource. It is the base type of
all TransitionUsages.
**General Types**
TransitionPerformance
Action
**Features**
acceptedMessage : MessageConnection {redefines trigger}
accepter : AcceptMessageAction [0..1] {subsets subactions, redefines accept}
effect : Action [0..*] {subsets subactions, redefines effect}
receiver : Occurrence {redefines triggerTarget}
transitionLinkSource : Action {redefines transitionLinkSource}
**Constraints**
None.
**9.2.9.2.25 transitionActions
Element**
TransitionUsage
**Description**
transitionActionsis the base feature for all TransitionUsages.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 463**


**General Types**
actions
Action
TransitionAction
**Features**
None.
**Constraints**
None.
**9.2.9.2.26 WhileLoopAction
Element**
ActionDefinition
**Description**
A _WhileLoopAction_ is a Kernel _LoopPerformance_ that is also a _LoopAction_. It is the base type for all
WhileLoopActionUsages.
**General Types**
LoopPerformance
LoopAction
**Features**
body : Action [0..*] {redefines body, body}
The _Action_ that is performed while the _whileTest_ is true and the _untilTest_ is false.
untilTest : BooleanEvaluation [0..*] {redefines untilTest}
Successive evaluations of a _Boolean_ -valued Expression that must be false for the loop to continue. The Expression
is evaluated after the _body_ is performed.
whileTest : BooleanEvaluation [1..*] {redefines whileTest}
Successive evaluations of a _Boolean_ -valued Expression that must be true for the loop to continue. the Expression is
evaluated before the _body_ is performed and is always evaluated at least once.
**Constraints**
None.
**9.2.9.2.27 whileLoopActions
Element**
ActionUsage

**464 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Description**
_whileLoopActions_ is the base feature for all WhileLoopActionUsages.
**General Types**
WhileLoopAction
loopActions
**Features**
None.
**Constraints**
None.

**9.2.10States
9.2.10.1States Overview**
This package defines the base types for states and related behavioral elements in the SysML language.
**9.2.10.2Elements
9.2.10.2.1 StateAction
Element**
StateDefinition
**Description**
A StateAction is a kind of Action that is also a StatePerformance. It is the base type for all StateDefinitions.
**General Types**
StatePerformance
Action
**Features**
doAction : Action {redefines do}
entryAction : Action {redefines entry}
exitAction : Action {redefines exit}
stateTransitions : StateTransitionAction [0..*] {subsets transitions}
subactions : Action [0..*] {subsets middle, redefines subactions}
Thesubperformancesof this StateAction that are Actions, other than the entry and exit Actions. These
subactionsall take place in the "middle" of the StatePerformance, that is, after the entry Action and before the
exit Action.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 465**


substates : StateAction [0..*] {subsets subactions}
Thesubactionsof this StateAction that are StateActions. Thesesubstatesall take place in the "middle" of the
StatePerformance, that is, after the entry Action and before the exit Action.
**Constraints**
None.
**9.2.10.2.2 stateActions
Element**
StateUsage
**Description**
stateActionsis the base feature for all StateUsages.
**General Types**
actions
StateAction
**Features**
None.
**Constraints**
None.
**9.2.10.2.3 StateTransitionAction
Element**
ActionDefinition
**Description**
A StateTransitionAction is a TransitionAction and a StateTransitionPerformance whose transitionLinkSource is a
State. It is the base type of TransitionUsages used transitions in state models.
**General Types**
StateTransitionPerformance
TransitionAction
**Features**
payload : Anything [0..*]
receiver : Occurrence {redefines receiver}
transitionLinkSource : StateAction {redefines transitionLinkSource, transitionLinkSource}

**466 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
None.

**9.2.11Calculations
9.2.11.1Calculations Overview**
This package defines the base types for calculations and related behavioral elements in the SysML language.
**9.2.11.2Elements
9.2.11.2.1 Calculation
Element**
CalculationDefinition
**Description**
Calculation is the most general class of evaluations of CalculationDefinitions in a system or part of a system.
Calculation is the base class of all CalculationDefinitions.
**General Types**
Action
Evaluation
**Features**
subcalculations : Calculation [0..*] {subsets subactions}
Thesubactionsof this FunctionInvocation that are FunctionInvocations.
**Constraints**
None.
**9.2.11.2.2 calculations
Element**
CalculationUsage
**Description**
calculationsis the base Feature for all CalculationUsages.
.
**General Types**
Calculation
actions
evaluations

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 467**


**Features**
None.
**Constraints**
None.

**9.2.12Constraints
9.2.12.1Constraints Overview**
This package defines the base types for constraints and related behavioral elements in the SysML language.
**9.2.12.2Elements
9.2.12.2.1 assertedConstraintChecks
Element**
ConstraintUsage
**Description**
_assertedConstraintChecks_ is the subset of _constraintChecks_ for > _ConstraintChecks_ asserted to be true.
**General Types**
trueEvaluations
constraintChecks
**Features**
None.
**Constraints**
None.
**9.2.12.2.2 ConstraintCheck
Element**
ConstraintDefinition
**Description**
_ConstraintCheck_ is the most general class for constraint checking. _ConstraintCheck_ is the base type of all
_ConstraintDefinitions_.
**General Types**
BooleanEvaluation
**Features**

**468 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


None.
**Constraints**
None.
**9.2.12.2.3 constraintChecks
Element**
ConstraintUsage
**Description**
_constraintChecks_ is the base feature of all _ConstraintUsages_.
**General Types**
booleanEvaluations
ConstraintCheck
**Features**
None.
**Constraints**
None.
**9.2.12.2.4 negatedConstraintChecks
Element**
ConstraintUsage
**Description**
_negatedConstraintChecks_ is the subset of _constraintChecks_ for > _ConstraintChecks_ asserted to be false.
**General Types**
falseEvaluations
constraintChecks
**Features**
None.
**Constraints**
None.

**9.2.13Requirements**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 469**


**9.2.13.1Requirements Overview**
This package defines the base types for requirements and related behavioral elements in the SysML language.
**9.2.13.2Elements
9.2.13.2.1 ConcernCheck
Element**
ConcernDefinition
**Description**
ConcernCheck is the most general class for concern checking. ConcernCheck is the base type of all
ConcernDefinitions.
**General Types**
RequirementCheck
**Features**
None.
**Constraints**
None.
**9.2.13.2.2 concernChecks
Element**
ConcernUsage
**Description**
concernChecksis the base feature of all ConcernUsages.
**General Types**
requirementChecks
ConcernCheck
**Features**
None.
**Constraints**
None.
**9.2.13.2.3 DesignConstraintCheck
Element**

**470 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ConstraintDefinition
**Description**
A DesignConstraint specifies a constraint on the implementation of the system or system part, such as the system
must use a commercial-off-the-shelf component.
**General Types**
RequirementCheck
**Features**
part : Part {redefines subj}
**Constraints**
None.
**9.2.13.2.4 FunctionalRequirementCheck
Element**
ConstraintDefinition
**Description**
A FunctionalRequirementCheck specifies an action that a system, or part of a system, must perform.
**General Types**
RequirementCheck
**Features**
subject : Action {redefines subj}
**Constraints**
None.
**9.2.13.2.5 InterfaceRequirementCheck
Element**
ConstraintDefinition
**Description**
An InterfaceRequirement Check specifies an Interface for connecting systems and system parts, which optionally
may include item flows across the Interface and/or Interface constraints.
**General Types**
RequirementCheck

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 471**


**Features**
subject : BinaryInterface {redefines subj}
**Constraints**
None.
**9.2.13.2.6 PerformanceRequirementCheck
Element**
ConstraintDefinition
**Description**
A PerformanceRequirementCheck quantitavely measures the extent to which a system, or a system part, satisfies a
required capability or condition.
**General Types**
RequirementCheck
**Features**
subject : AttributeValue {redefines subj}
**Constraints**
None.
**9.2.13.2.7 PhysicalRequirementCheck
Element**
ConstraintDefinition
**Description**
A PhysicalRequirementCheck specifies physical characteristics and/or physical constraints of the system, or a
system part.
**General Types**
RequirementCheck
**Features**
subject : Part {redefines subj}
**Constraints**
None.

**472 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.2.13.2.8 RequirementCheck
Element**
RequirementDefinition
**Description**
RequirementCheck is the most general class for requirements checking. RequirementCheck is the base type of all
RequirementDefinitions.
**General Types**
ConstraintCheck
**Features**
actors : Part [0..*]
The Parts that fill the role of actors for this RequirementCheck.
assumptions : ConstraintCheck [0..*] {ordered}
The checks of assumptions that must hold for the required constraints to apply.
concerns : ConcernCheck [0..*] {subsets constraints}
The checks of any concerns being addressed (as required constraints).
constraints : ConstraintCheck [0..*] {ordered}
The checks of required constraints.
stakeholders : Part [0..*]
The Parts that represent stakeholders interested in the requirement being checked.
subj : Anything
The entity that is being check for satisfaction of the required constraints.
**Constraints**
[no name]
allTrue(assumptions) implies allTrue(constraints)
**9.2.13.2.9 requirementChecks
Element**
RequirementUsage
**Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 473**


requirementChecksis the base feature of all RequirementUsages.
**General Types**
RequirementCheck
constraintChecks
**Features**
None.
**Constraints**
None.

**9.2.14Cases
9.2.14.1Cases Overview**
This package defines the base types for cases and related behavioral elements in the SysML language.
**9.2.14.2Elements
9.2.14.2.1 Case
Element**
CaseDefinition
**Description**
Case is the most general class of performances of CaseDefinitions. Case is the base class of all CaseDefinitions.
**General Types**
Calculation
**Features**
actors : Part [0..*]
The Parts that fill the role of actors for this Case.
obj : RequirementCheck
A check of whether the objective RequirementUsage was satisfied for this Case. By default, thesubjfor the
objective is theresultof the Case.
subcases : Case [0..*] {subsets subcalculations}
Other Cases carried out as part of the performance of this Case.
subj : Anything
The subject that was investigated by this Case.

**474 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
None.
**9.2.14.2.2 cases
Element**
CaseUsage
**Description**
casesis the base feature of all CaseUsages.
**General Types**
calculations
Case
**Features**
None.
**Constraints**
None.

**9.2.15Analysis Cases
9.2.15.1Analysis Cases Overview**
This package defines the base types for analysis cases and related behavioral elements in the SysML language.
**9.2.15.2Elements
9.2.15.2.1 AnalysisAction
Element**
ActionDefinition
**Description**
An AnalysisAction is a specialized kind of Action used intended to be used as a step in an AnalysisCase.
**General Types**
Action
**Features**
None.
**Constraints**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 475**


**9.2.15.2.2 AnalysisCase
Element**
AnalysisCaseDefinition
**Description**
AnalysisCase is the most general class of performances of AnalysisCaseDefinitions. AnalysisCase is the base class
of all AnalysisCaseDefinitions.
**General Types**
Case
**Features**
analysisSteps : AnalysisAction [0..*] {subsets subactions}
Thesubactionsof this AnalysisCase that are AnalysisActions.
objective : RequirementCheck {redefines obj}
The objective of this AnalysisCase, whosesubjectis bound to theresultof the AnalysisCase.
result : Anything [0..*] {redefines result, nonunique}
The result of this AnalysisCase, which is bound to theresultof theresultEvaluation.
resultEvaluation : Evaluation [0..1]
The Evaluation of theresultExpressionfrom the definition of this AnalysisCase.
subAnalysisCases : AnalysisCase [0..*] {subsets subcases}
Thesubcasesof this AnalysisCase that are AnalysisCaseUsages.
**Constraints**
None.
**9.2.15.2.3 analysisCases
Element**
AnalysisCaseUsage
**Description**
analysisCasesis the base feature of all AnalysisCaseUsages.
**General Types**
AnalysisCase
cases

**476 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
None.
**Constraints**
None.
**9.2.15.2.4AnalysisAction <ActionDefinition>
Description**
An AnalysisAction is a specialized kind of Action used intended to be used as a step in an AnalysisCase.
**General Types**
Action
**Features**
None.
**Constraints**
None.
**9.2.15.2.5AnalysisCase <AnalysisCaseDefinition>
Description**
AnalysisCase is the most general class of performances of AnalysisCaseDefinitions. AnalysisCase is the base class
of all AnalysisCaseDefinitions.
**General Types**
Case
**Features**
analysisSteps : AnalysisAction [0..*] {subsets subactions}
Thesubactionsof this AnalysisCase that are AnalysisActions.
objective : RequirementCheck {redefines obj}
The objective of this AnalysisCase, whosesubjectis bound to theresultof the AnalysisCase.
result : Anything [0..*] {redefines result, nonunique}
The result of this AnalysisCase, which is bound to theresultof theresultEvaluation.
resultEvaluation : Evaluation [0..1]
The Evaluation of theresultExpressionfrom the definition of this AnalysisCase.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 477**


subAnalysisCases : AnalysisCase [0..*] {subsets subcases}
Thesubcasesof this AnalysisCase that are AnalysisCaseUsages.
**Constraints**
None.
**9.2.15.2.6analysisCases <AnalysisCaseUsage>
Description**
analysisCasesis the base feature of all AnalysisCaseUsages.
**General Types**
AnalysisCase
cases
**Features**
None.
**Constraints**
None.

**9.2.16Verification Cases
9.2.16.1Verification Cases Overview**
This package defines the base types for verification cases and related behavioral elements in the SysML language.
**9.2.16.2Elements
9.2.16.2.1 PassIf
Element**
CalculationDefinition
**Description**
_PassIf_ returns a _pass_ or _failVerdictKind_ depending on whether its argument is true or false.
**General Types**
None.
**Features**
isPassing : Boolean
**in** Whether or not a verification has passed.
verdict : VerdictKind

**478 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**return** _pass_ if _isPassing_ is true and _fail_ otherwise.
**Constraints**
None.
**9.2.16.2.2 VerificationCase
Element**
VerificationCaseDefinition
**Description**
_VerificationCase_ is the most general class of performances of VerificationCaseDefinitions.
_VerificationCase_ is the base class of all VerificationCaseDefinitions.
**General Types**
Case
**Features**
obj : VerificationCheck {redefines obj}
The objective of this _VerificationCase_ , whose _subject_ is bound to the _subject_ of the _VerificationCase_
and whoserequirementVerificationsare bound to therequirementVerificationsof the
_VerificationCase_.
requirementVerifications : RequirementCheck [0..*]
Checks on whether theverifiedRequirementsof the VerificationCaseDefinition have been satisfied.
subj : Anything {redefines subj}
The subject of this VerificationCase, representing the system under test, which is bound to the _subject_ of the
_objective_ of the _VerificationCase_.
subVerificationCases : VerificationCase [0..*] {subsets subcases}
The _subcases_ of this _VerificationCase_ that are VerificationCaseUsages.
verdict : VerdictKind {redefines result}
Theresultof a _VerificationCase_ must be a _VerdictKind_.
**Constraints**
None.
**9.2.16.2.3 verificationCases
Element**
VerificationCaseUsage

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 479**


**Description**
_verificationCases_ is the base feature of all VerificationCaseUsages.
**General Types**
VerificationCase
cases
**Features**
None.
**Constraints**
None.
**9.2.16.2.4 VerificationCheck
Element**
RequirementDefinition
**Description**
_VerificationCheck_ is a specialization of _RequirementCheck_ used for theobjectiveof a
_VerificationCase_ in order to record the evaluations of the _RequirementChecks_ of requirements being verified.
**General Types**
RequirementCheck
**Features**
requirementVerifications : RequirementCheck [0..*] {subsets constraints}
A record of the evaluations of the _RequirementChecks_ of requirements being verified.
**Constraints**
None.
**9.2.16.2.5 VerificationMethod
Element**
AttributeDefinition
**Description**
_VerificationMethod_ can be used as metadata annotating a verification case or action.
**General Types**
None.

**480 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
kind : VerificationMethodKind [1..*]
The methods by which the annotated verification was carried out.
**Constraints**
None.

**9.2.17Use Cases
9.2.17.1Use Cases Overview**
This package defines the base types for use cases and related behavioral elements in the SysML language.
**9.2.17.2Elements
9.2.17.2.1 UseCase
Element**
UseCaseDefinition
**Description**
UseCase is the most general class of performances of UseCaseDefinitions. UseCase is the base class of all
UseCaseDefinitions.
**General Types**
Case
**Features**
includedUseCases : UseCase [0..*] {subsets subUseCases}
Other UseCases included by this UseCase (i.e., as modeled by an IncludeUseCaseUsage).
subUseCases : UseCase [0..*] {subsets subcases}
Other UseCases carried out as part of the performance of this UseCase.
**Constraints**
None.
**9.2.17.2.2 useCases
Element**
UseCaseUsage
**Description**
useCasesis the base feature of all UseCaseUsages.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 481**


**General Types**
UseCase
cases
**Features**
None.
**Constraints**
None.

**9.2.18Views
9.2.18.1Views Overview**
This package defines the base types for views, viewpoints, renderings and related elements in the SysML language.
**9.2.18.2Elements
9.2.18.2.1 asElementTable
Element**
RenderingUsage
**Description**
asElementTablerenders a View as a table, with one row for each exposed Element and columns rendered by
applying thecolumnViewsin order to the Element in each row.
**General Types**
TabularRendering
**Features**
columnView : View [0..*] {ordered}
The Views to be rendered in the column cells, in order, of each rows of the table.
**Constraints**
None.
**9.2.18.2.2 asInterconnectionDiagram
Element**
RenderingUsage
**Description**
asInterconnectionDiagramrenders a View as an interconnection diagram, using the graphical notation defined
in the SysML specification.

**482 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Types**
GraphicalRendering
**Features**
None.
**Constraints**
None.
**9.2.18.2.3 asTextualNotation
Element**
RenderingUsage
**Description**
asTextualNotationrenders a View into textual notation as defined in the KerML and SysML specifications.
**General Types**
TextualRendering
**Features**
None.
**Constraints**
None.
**9.2.18.2.4 asTreeDiagram
Element**
RenderingUsage
**Description**
asTreeDiagramrenders a View as a tree diagram, using the graphical notation defined in the SysML specification.
**General Types**
GraphicalRendering
**Features**
None.
**Constraints**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 483**


**9.2.18.2.5 GraphicalRendering
Element**
RenderingDefinition
**Description**
A GraphicalRendering is a Rendering of a View into a Graphical format.
**General Types**
Rendering
**Features**
None.
**Constraints**
None.
**9.2.18.2.6 Rendering
Element**
RenderingDefinition
**Description**
Rendering is the base type of all RenderingDefinitions.
**General Types**
Part
**Features**
subrenderings : Rendering [0..*]
Other Renderings used to carry out this Rendering.
**Constraints**
None.
**9.2.18.2.7 renderings
Element**
RenderingUsage
**Description**
renderingsis the base feature of all RenderingUsages.

**484 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Types**
Rendering
parts
**Features**
None.
**Constraints**
None.
**9.2.18.2.8 TabularRendering
Element**
RenderingDefinition
**Description**
A TabularRendering is a Rendering of a View into a tabular format.
**General Types**
Rendering
**Features**
None.
**Constraints**
None.
**9.2.18.2.9 TextualRendering
Element**
RenderingDefinition
**Description**
A TextualRendering is a Rendering of a View into a textual format.
**General Types**
Rendering
**Features**
None.
**Constraints**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 485**


None.
**9.2.18.2.10 View
Element**
ViewDefinition
**Description**
View is the base type of all ViewDefinitions.
**General Types**
Part
**Features**
self : View {redefines self}
subviews : View [0..*]
Other Views that are used in the rendering of this View.
viewpointConformance : viewpointConformance
An assertion that allviewpointSatisfactionsare true.
viewpointSatisfactions : ViewpointCheck [0..*]
Checks that the View satisfies all required ViewpointsUsages.
viewRendering : Rendering [0..1]
The Rendering of this View.
**Constraints**
None.
**9.2.18.2.11 ViewpointCheck
Element**
ViewpointDefinition
**Description**
ViewpointCheck is a RequirementCheck for checking if a View meets the concerns ofconcernedStakeholders.
It is the base type of all ViewpointDefinitions.
**General Types**
RequirementCheck

**486 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
subject : View {redefines subj}
The subject of this ViewpointCheck, which must be a View.
**Constraints**
None.
**9.2.18.2.12 viewpointChecks
Element**
ViewpointUsage
**Description**
viewpointChecksis the base feature of all ViewpointUsages.
**General Types**
ViewpointCheck
requirementChecks
**Features**
None.
**Constraints**
None.
**9.2.18.2.13 viewpointConformance
Element**
SatisfyRequirementUsage
**Description
General Types**
RequirementCheck
**Features**
viewpointSatisfactions : ViewpointCheck [0..*] {subsets constraints}
The required ViewpointChecks.
**Constraints**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 487**


**9.2.18.2.14 views
Element**
ViewUsage
**Description**
viewsis the base feature of all ViewUsages.
**General Types**
parts
View
**Features**
None.
**Constraints**
None.

**9.2.19Standard View Definitions
9.2.19.1Standard View Definitions Overview**
This package defines the standard graphical view definitions for the SysML language. Each view definition specifies
the kind of model elements that can be presented in a view usage and the method for rendering the elements. The
standard views are generally rendered as a graph with nodes connected by edges. The nodes can have any number of
compartments that contain selected members of the node. For example, a part definition or part usage may contain
an attributes compartment that contains the attributes of the part. Definition and usage nodes may also contain
connection points corresponding to their ports and parameters. The nodes and edges may be rendered with
specialized syntax in different views.
The _StandardViewDefinitions_ package contains the following normative standard view definitions:

```
Standard View Definition Default Compartment
General View (gv) Default compartment for a package, see8.2.3.5.
Interconnection View (iv) Default compartment for a part, see8.2.3.11.
Action Flow View (afv) Default compartment for an action, see8.2.3.16.
State Transition View (stv) Default compartment for a state, see8.2.3.17.
Sequence View (sv) Default compartment for an occurrence, see8.2.3.9.
```
**488 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Standard View Definition Default Compartment
Case View (cv) Default compartment for a case, see8.2.3.21.
Geometry View (gev)
Grid View (grv)
Browser View (bv)
```
These standard views establish a basic setof views that shall be supported by any conforming tool. Other kinds of
views may also be defined beyond the standard views, using the view modeling capabilities of SysML (see7.25).
Table 33provides an overview of the element content supported by each standard view definition.
**Table 33. Standard View Definitions**
Standard View Definition

```
Graphical Elements
Action (includes control
nodes, loop, send, accept,
...)
```
```
x x x x x
Actor* x x
Allocation x x
Analysis x x
Annotated element*
(includes comment,
documentation, textual
representation, and
metadata, rationale)
```
```
x x x x x x
```
```
Attribute x x
Binding connection x x x
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 489**


```
Standard View Definition
```
```
Graphical Elements
Calculation x x x x x x
Causation x x
Change and time triggers x x x x x x
Concern x x
Conjugate port definition* x x
Connection x x
Constraint x x x x x x
Derive requirement
Directed feature* x x
Enumeration x x
Event occurrence x
Expression x
Feature value
Flow connection x x x x x x
Individual (flag on def/
usage) x x
Interface x x
Item x x
Lifeline* x
Message x x x
Metadata x x
Objective x x x
Occurrence x x x
Package* x
```
**490 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Standard View Definition
```
```
Graphical Elements
Parameter x x x x x
Part x x x
Port x x x
Proxy connection point* x x x x
Quantity value x x x x x x
Requirement x x
Snapshot* x x x x
Stakeholder* x x x
State x x x x
Subject* x x x
Succession* x x x x x
Timeslice* x x x x x
Transition* x x x
Use case x x x
Measurement reference
(i.e., unit) x
Variant (flag) x x x x x x
Variation (flag) x x x x x x
Verification x x
View x x
Viewpoint x x
Other relationships *
Annotation x x x x x x
Dependency x
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 491**


```
Standard View Definition
```
```
Graphical Elements
Expose x
Feature membership x x
Import x
Membership x x
Portion Membership x x
Subclassification x x
Defined by x x
Redefine x x
Refinement x
Subset x x
Verify x
References *
Assert constraint x x
Assume constraint x x
Exhibit state x x x
Include use case x x x
Perform action x x x x x
Ref feature x x x x x x
Require constraint x x
Satisfy requirement x x
```
**Note**. Elements without an asterisk are kinds of definition and usage elements. Elements with an asterisk are not
kinds of a definition nor a usage element.

**492 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.2.19.2Elements
9.2.19.2.1 ActionFlowView
Element**
ViewDefinition
**Description**
View definition to present connections between actions. Valid nodes and edges in an ActionFlowView are:

- Actions with nested actions
- Parameters with direction
- Flow connection usages (e.g., kinds of transfers from output to input)
- Binding connections between parameters (e.g., delegate a parameter from one level of nesting to another)
- Proxy connection points
- Swim lanes
- Conditional succession
- Control nodes (fork, join, decision, merge)
- Control structures, e.g., if-then-else, until-while-loop, for-loop
- Send and accept actions
- Change and time triggers
- Compartments on actions and parameters
Short name: afv
**General Types**
InterconnectionView
**Features**
None.
**Constraints**
None.
**9.2.19.2.2 BrowserView
Element**
ViewDefinition
**Description**
View definition to present the hierarchical membership structure of model elements starting from an exposed root
element. The typical rendering in graphical notation is as an indented list of rows, consisting of dynamically
collapsible-expandable nodes that represent branches and leaves of the tree.
Short name: bv
**General Types**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 493**


None.
**Features**
None.
**Constraints**
None.
**9.2.19.2.3 CaseView
Element**
ViewDefinition
**Description**
View definition to present exposed use cases. Valid nodes and edges in a UseCaseView are:
In one view in principle only one of use cases, analysis cases or verification cases is rendered.

- Valid nodes and edges in any CaseView are: CaseDefinition, CaseUsage, SubjectMembership,
    ObjectiveMembership, ActorMembership, RequirementDefinition, RequirementUsage
- Valid nodes and edges in a use case view are: UseCaseDefinition, UseCaseUsage, IncludeUseCaseUsage,
    ...
- Valid nodes and edges in an analysis view are: AnalysisCaseDefinition, AnalysisCaseUsage, ...
- Valid nodes and edges in a verification view are: VerificationCaseDefinition, VerificationCaseUsage, ...
Short name: cv
**General Types**
None.
**Features**
None.
**Constraints**
None.
**9.2.19.2.4 GeneralView
Element**
ViewDefinition
**Description**
View definition to present any members of exposed model element(s). This is the most general view, enabling
presentation of any model element. The typical rendering in graphical notation is as a graph of nodes and edges.
Specializations of GeneralView can be specified through appropriate selection of filters, e.g.:

**494 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


- package view, filtering on Package, Package containment, package Import
- definition and usage view, filtering on Definition, Usage, Specialization, FeatureTyping (covering defined
    by)
- requirement view, filtering on RequirementDefinition, RequirementUsage, Specialization, FeatureTyping,
    SatisfyRequirementUsage, AllocationDefinition, AllocationUsage, ...
- view and viewpoint view, filtering on ViewDefinition, ViewUsage, ViewpointDefinition,
    ViewpointUsage, RenderingDefinition, RenderingUsage, ConcernDefinition, ConcernUsage,
    StakeholderMembership, ...
- language extension view, filtering on Metaclass, MetadataFeature, MetadataAccessExpression, ...
Note: filters are specified by referencing concepts from theKerML.kermlandSysML.sysmlstandard library
packages.
Short name: gv
**General Types**
None.
**Features**
None.
**Constraints**
None.
**9.2.19.2.5 GeometryView
Element**
ViewDefinition
**Description**
View definition to present a visualization of exposed spatial items in two or three dimensions Valid nodes and edges
in a GeometryView are:
- Spatial item, including shape
- Coordinate frame
- Feature related to spatial item, such as a quantity (e.g. temperature) of which values are to be rendered on
a color scale
The typical rendering in graphical notation would include a number of visualization parameters, such as:
- 2D or 3D view
- viewing direction
- zoom level
- light sources
- object projection mode, e.g., isometric, perspective, orthographic
- object rendering mode, e.g., shaded, wireframe, hidden line
- object pan (placement) and rotate (orientation) settings
- color maps
Short name: gev

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 495**


**General Types**
None.
**Features**
None.
**Constraints**
None.
**9.2.19.2.6 GridView
Element**
ViewDefinition
**Description**
View definition to present exposed model elements and their relationships,arranged in a rectangular grid. GridView
is the generalization of the following more specialized views:

- Tabular view
- Data value tabular view
- Relationship matrix view
Short name: grv
**General Types**
None.
**Features**
None.
**Constraints**
None.
**9.2.19.2.7 InterconnectionView
Element**
ViewDefinition
**Description**
View definition to present exposed features as nodes, nested features as nested nodes, and connections between
features as edges between (nested) nodes. Nested nodes may present boundary features (e.g., ports, parameters).
Short name: iv
**General Types**

**496 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


None.
**Features**
None.
**Constraints**
None.
**9.2.19.2.8 SequenceView
Element**
ViewDefinition
**Description**
View definition to present time ordering of event occurrences on lifelines of exposed features. Valid nodes and
edges in a SequenceView are:

- Features such as parts with their lifelines
- Event occurrences on the lifelines
- Messages sent from one part to another with and without a type of flow
- Succession between event occurrences
- Nested sequence view (e.g., a reference to a view)
- Compartments
The typical rendering in graphical notation depicts the exposed features horizontally along the top, with vertical
lifelines. The time axis is vertical, with time increasing from top to bottom.
Short name: sv
**General Types**
None.
**Features**
None.
**Constraints**
None.
**9.2.19.2.9 StateTransitionView
Element**
ViewDefinition
**Description**
View definition to present states and their transitions. Valid nodes and edges in a StateTransitionView are:

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 497**


- States with nested states
- Entry, do, and exit actions
- Transition usages with triggers, guards, and actions
- Compartments on states
Short name: stv
**General Types**
InterconnectionView
**Features**
None.
**Constraints**
None.

**9.2.20Metadata
9.2.20.1Metadata Overview**
This package defines the base types for metadata definitions and related metadata annotations in the SysML
language.
**9.2.20.2Elements
9.2.20.2.1 MetadataItem
Element**
MetadataDefinition
**Description**
_MetadataItem_ is the most general class of _Items_ that represent _Metaobjects_. _MetadataItem_ is the base type of
all MetadataDefinitions.
**General Types**
Metaobject
Item
**Features**
None.
**Constraints**
None.
**9.2.20.2.2 metadataItems
Element**

**498 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ItemUsage
**Description**
_metadataItems_ is the base feature of all MetadataUsages.
Note: It is not itself a MetadataUsage, because it is not being used as an AnnotatingElement here.
**General Types**
metaobjects
items
MetadataItem
**Features**
None.
**Constraints**
None.

**9.2.21SysML**
This package contains a reflective SysML model of the SysML abstract syntax. It is generated from the normative
MOF abstract syntax model (see8.3) as follows.

1. The _SysML_ model imports all elements from the reflective _KerML_ package (see [KerML, 9.2.17]) and
    directly contains all metaclasses mapped from the SysML abstract syntax, without any subpackaging.
2. A metaclass from the MOF model is mapped into aMetadataDefinitionin the KerML package.
    ◦ The MOF metaclass name is mapped unchanged.
    ◦ Generalizations of the MOF metaclass are mapped toownedSpecializations.
    ◦ All properties from the MOF metaclass are mapped tousagesof the corresponding
       MetadataDefinition(see below). All non-association-end properties are grouped before
       association-end properties.
3. A property from the MOF model is mapped into anAttributeUsageorItemUsage, depending on
    whether the MOF property type is a data type or a class.
       ◦ The following feature properties are set as appropriate:
          ▪ isAbstract = trueif the MOF property is a derived union
          ▪ isReadonly = trueif the MOF property is read-only.
          ▪ isDerived = trueif the MOF property is derived.
          ▪ isReferential = trueif the MOF property is _not_ composite.
       ◦ The MOF property name is mapped unchanged.
       ◦ The MOF property type is mapped to anownedTypingrelationship.
          ▪ If the MOF property type is a primitive type, the relationship is to the corresponding
             type from the _ScalarValues_ package (see [KerML, 9.3.2]).
          ▪ If the MOF property type is a metaclass, the relationship is to the corresponding
             reflectiveMetadataDefinition.
       ◦ The MOF property multiplicity is mapped to an ownedMultiplicityRangewith bounds
          given byLiteralExpressions.
       ◦ Subsetted properties from the MOF property are mapped toownedSubsettingsof the
          corresponding reflectiveFeaturesorUsages.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 499**


```
◦ Redefined properties from the MOF property are mapped toownedRedefinitionsof the
corresponding reflectiveFeaturesorUsages.
◦ If the MOF property isannotatedElement, thenMetaobject::annotatedElementis
added to the list of redefined properties for the mapping.
```
4. An enumeration from the MOF model is mapped into anEnumerationDefinition.
    ◦ The MOF enumeration name is mapped unchanged.
    ◦ Each enumeration literal from the MOF enumeration is mapped into anenumeratedValueof
       theEnumerationDefinition, with the same name as the MOF enumeration literal.
Note that associations are not mapped from the MOF model and, hence, non-navigable association-owned end
properties are not included in the reflective model.

**9.3Metadata Domain Library
9.3.1Metadata Domain Library Overview**
The Metadata Domain Library contains library models of generally useful metadata that can be used to annotate
model elements (see7.4).

**9.3.2Modeling Metadata
9.3.2.1Modeling Metadata Overview**
This package contains definitions of metadata generally useful for annotating models.
**9.3.2.2Elements
9.3.2.2.1 Issue
Element**
MetadataDefinition
**Description**
_Issue_ is used to record some issue concerning the annotated element.
**General Types**
MetadataItem
**Features**
text : String
A textual description of the issue.
**Constraints**
None.
**9.3.2.2.2 Rationale
Element**
MetadataDefinition

**500 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Description**
_Rationale_ is used to explain a choice or other decision made related to the annotated element.
**General Types**
MetadataItem
**Features**
explanation : Anything [0..1]
A reference to aFeaturethat provides a formal explanation of the rationale. (For example, a trade study whose
result explains the choice of a certain alternative).
text : String
A textual description of the rationale (required).
**Constraints**
None.
**9.3.2.2.3 Refinement
Element**
MetadataDefinition
**Description**
_Refinement_ is used to identify aDependencyas modeling a refinement relationship. In such a relationship, the
source elements of the relationship provide a more precise and/or accurate representation than the target elements.
**General Types**
MetadataItem
**Features**
annotatedElement : Dependency {redefines annotatedElement}
**Constraints**
None.
**9.3.2.2.4 StatusInfo
Element**
MetadataDefinition
**Description**
_StatusInfo_ is used to annotate a model element with status information.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 501**


**General Types**
MetadataItem
**Features**
originator : String [0..1]
The originator of the annotated element.
owner : String [0..1]
The current owner of the annotated element.
risk : Risk [0..1]
An assessment of risk for the annotated element.
status : StatusKind
The current status of work on the annotated element (required).
**Constraints**
None.
**9.3.2.2.5 StatusKind
Element**
EnumerationDefinition
**Description**
_StatusKind_ enumerates the possible statuses of work on a model element.
**General Types**
AttributeValue
**Features**
closed
Status is closed.
done
Status is done.
open
Status is open.
tbc

**502 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Status is to be confirmed.
tbd
Status is to be determined.
tbr
Status is to be resolved.
**Constraints**
None.

**9.3.3Risk Metadata
9.3.3.1Risk Metadata Overview**
This package defines metadata for annotating model elements with assessments of risk.
**9.3.3.2Elements
9.3.3.2.1 Level
Element**
AttributeDefinition
**Description**
A _Level_ is a _Real_ number in the interval 0.0 to 1.0, inclusive.
**General Types**
AttributeValue
Real
**Features**
level : Level {redefines self}
**Constraints**
levelRange
level >= 0.0 and level <= 1.0
**9.3.3.2.2 LevelEnum
Element**
EnumerationDefinition
**Description**
_LevelEnum_ provides standard probability Levels for low, medium and high risks.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 503**


**General Types**
Level
**Features**
high
High level, taken to be 75%.
low
Low level, taken to be 25%.
medium
Medium level, taken to be 50%.
**Constraints**
None.
**9.3.3.2.3 Risk
Element**
MetadataDefinition
**Description**
_Risk_ is used to annotate a model element with an assessment of the risk related to it in some typical risk areas.
**General Types**
MetadataItem
**Features**
costRisk : RiskLevel [0..1]
The risk that work on the annotated element will exceed its planned cost.
scheduleRisk : RiskLevel [0..1]
The risk that work on the annotated element will not be completed on schedule.
technicalRisk : RiskLevel [0..1]
The risk of unresolved technical issues regarding the annotated element.
totalRisk : RiskLevel [0..1]
The total risk associated with the annotated element.
**Constraints**

**504 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


None.
**9.3.3.2.4 RiskLevel
Element**
AttributeDefinition
**Description**
_RiskLevel_ gives the probability of a risk occurring and, optionally, the impact if the risk occurs.
**General Types**
AttributeValue
**Features**
impact : Level [0..1]
The impact of the risk if it occurs (with 0.0 being no impact and 1.0 being the most severe impact).
probability : Level
The probability that a risk will occur.
**Constraints**
None.
**9.3.3.2.5 RiskLevelEnum
Element**
EnumerationDefinition
**Description**
_RiskLevelEnum_ enumerates standard _RiskLevels_ for low, medium and high risks (without including impact).
**General Types**
RiskLevel
**Features**
high
Risk level with high probability.
low
Risk level with low probability.
medium

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 505**


Risk level with medium probability.
**Constraints**
None.

**9.3.4Parameters of Interest Metadata
9.3.4.1Parameters of Interest Metadata Overview**
This package contains definitions of metadata to identify key parameters of interest, including measures of
effectiveness (MOE) and other key measures of performance (MOP).
**9.3.4.2Elements
9.3.4.2.1 MeasureOfEffectiveness
Element**
MetadataDefinition
**Description**
_MeasureOfEffectiveness_ (short name _moe_ ) is semantic metadata for identifying an attribute as a measure of
effectiveness.
**General Types**
MetadataItem
SemanticMetadata
**Features**
annotatedElement : Usage {redefines annotatedElement}
baseType : Type {redefines baseType}
Base type is _measuresOfEffectiveness_.
**Constraints**
None.
**9.3.4.2.2 MeasureOfPerformance
Element**
MetadataDefinition
**Description**
_MeasureOfPerformance_ (short name _mop_ ) is semantic metadata for identifying an attribute as a measure of
performance.
**General Types**

**506 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


MetadataItem
SemanticMetadata
**Features**
annotatedElement : Usage {redefines annotatedElement}
baseType : Type {redefines baseType}
Base type is _measuresOfPeformance_.
**Constraints**
None.
**9.3.4.2.3 measuresOfEffectiveness
Element**
AttributeUsage
**Description**
Base feature for attributes that are measures of effectiveness.
**General Types**
attributeValues
**Features**
None.
**Constraints**
None.
**9.3.4.2.4 measuresOfPerformance
Element**
AttributeUsage
**Description**
Base feature for attributes that are measures of performance.
**General Types**
attributeValues
**Features**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 507**


**Constraints**
None.

**9.3.5Image Metadata
9.3.5.1Image Metadata Overview**
This package provides attributive data and metadata to allow a model element to be annotated with an image to be
used in its graphical rendering or as a marker to adorn graphical or textual renderings.
**9.3.5.2Elements
9.3.5.2.1 Icon
Element**
MetadataDefinition
**Description**
_Icon_ metadata can be used to annotate a model element with an image to be used to show render the element on a
diagram and/or a small image to be used as an adornment on a graphical or textual rendering. Alternatively, another
metadata definition can be annotated with an _Icon_ to indicate that any model element annotated by the containing
metadata can be rendered according to the _Icon_.
**General Types**
MetadataItem
**Features**
fullImage : Image [0..1]
A full-sized image that can be used to render the annotated element on a graphical view, potentially as an alternative
to its standard rendering.
smallImage : Image [0..1]
A smaller image that can be used as an adornment on the graphical rendering of the annotated element or as a
marker in a textual rendering.
**Constraints**
None.
**9.3.5.2.2 Image
Element**
AttributeDefinition
**Description**
_Image_ provides the data necessary for the physical definition of a graphical image.

**508 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Types**
AttributeValue
**Features**
content : String [0..1]
Binary data for the image according to the given MIME type, encoded as given by the encoding.
encoding : String [0..1]
Describes how characters in the content are to be decoded into binary data. At least "base64", "hex", "identify", and
"JSONescape" shall be supported.
location : String [0..1]
A URI for the location of a resource containing the image content, as an alternative for embedding it in the content
attribute.
type : String [0..1]
The MIME type according to which the content should be interpreted.
**Constraints**
None.

**9.4Analysis Domain Library
9.4.1Analysis Domain Library Overview**
The Analysis Domain Library provides library models supporting the modeling of analysis cases (see7.22) and
related analysis tasks.

**9.4.2Analysis Tooling
9.4.2.1Analysis Tooling Overview**
This package contains definitions for metadata annotations related to analysis tool integration.
**9.4.2.2Elements
9.4.2.2.1 ToolExecution
Element**
MetadataDefinition
**Description**
_ToolExecution_ metadata identifies an external analysis tool to be used to implement the annotated action.
**General Types**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 509**


MetadataItem
**Features**
toolName : String
uri : String
**Constraints**
None.
**9.4.2.2.2 ToolVariable
Element**
MetadataDefinition
**Description**
_ToolVariable_ metadata is used in the context of an action that has been annotated with _ToolExecution_
metadata. It is used to annotate a parameter or other feature of the action with the name of the variable in the tool
that is to correspond to the annotated feature.
**General Types**
MetadataItem
**Features**
name : String
**Constraints**
None.

**9.4.3Sampled Functions
9.4.3.1Sampled Functions Overview**
This package provides a library model of discretely sampled mathematical functions.
A _SampledFunction_ can be used for many engineering purposes. For example, it can represent a time series
observation, where the domain consists of time instants expressed on a given timescale and the range consists of
observed quantity values. It can also capture a physical property of a substance that depends on temperature or
pressure or both.
A _SampledFunction_ with numerical domain and range types can be used as input to an interpolation algorithm in
order to obtain range values for domain values that fall in-between the discretely sampled domain values.
**9.4.3.2Elements
9.4.3.2.1 Domain
Element**

**510 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


CalculationDefinition
**Description**
_Domain_ returns the sequence of the _domainValues_ of all samples in a _SampledFunction_.
**General Types**
Calculation
**Features**
fn : SampledFunction
input
result : Anything [0..*]
output
**Constraints**
None.
**9.4.3.2.2 Interpolate
Element**
CalculationDefinition
**Description**
An _Interpolate_ calculation returns an interpolated range value from a given _SampledFunction_ for a given
domain _value_. If the input domain _value_ is outside the bounds of the _domainValues_ of the _SampleFunction_ ,
null is returned.
**General Types**
Calculation
**Features**
fn : SampledFunction
input
result : Anything [0..1]
output
value : Anything
input
**Constraints**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 511**


None.
**9.4.3.2.3 interpolateLinear
Element**
CalculationUsage
**Description**
_interpolateLinear_ is an _Interpolate_ calculation assuming a linear functional form between _SamplePairs_.
**General Types**
Interpolate
calculations
**Features**
fn : SampledFunction
input
result : Anything [0..1] {redefines result}
output
value : Anything {redefines value}
input
**Constraints**
None.
**9.4.3.2.4 Range
Element**
CalculationDefinition
**Description**
_Range_ returns the sequence of the _rangeValues_ of all samples in a _SampledFunction_.
**General Types**
Calculation
**Features**
fn : SampledFunction
input

**512 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


result : Anything [0..*]
output
**Constraints**
None.
**9.4.3.2.5 Sample
Element**
CalculationDefinition
**Description**
_Sample_ returns a _SampledFunction_ that samples a given calculation over a sequence of _domainValues_.
**General Types**
Calculation
**Features**
calculation : CalculationUsage [0..*]
input
domainValues : Anything [0..*]
input
sampling : SampledFunction
output
**Constraints**
None.
**9.4.3.2.6 SampledFunction
Element**
AttributeDefinition
**Description**
_SampledFunction_ is a variable-size, ordered collection of _SamplePair_ elements that represents a generic,
discretely sampled, uni-variate or multi-variate mathematical function. The function must be montonic, either
strictly increasing or strictly decreasing.
It maps discrete domain values to discrete range values. The domain of the function is represented by the sequence
of _domainValues_ of each _SamplePair_ in _samples_ , and the range of the function is represented by the sequence
of _rangeValues_ of each _SamplePair_ in _samples_.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 513**


**General Types**
OrderedMap
**Features**
samples : SamplePair [0..*] {redefines elements, ordered}
**Constraints**
[no name]
Note: Assumes the functions'<'and'>'are defined for the domain type.
(1..size(samples)-1)->forAll { in i;(samples.domainValue[i] < samples.domainValue[i+1]) } or // Strictly increasing
(1..size(samples)-1)->forAll { in i;(samples.domainValue[i] > samples.domainValue[i+1]) } // Strictly decreasing

**9.4.3.2.7 SamplePair
Element**
AttributeDefinition
**Description**
_SamplePair_ is a key-value pair of a _domainValue_ and a _rangeValue_ , used as a sample element in
_SampledFunction_.
**General Types**
KeyValuePair
**Features**
domainValue : Anything {redefines key}
rangeValue : Anything {redefines val}
**Constraints**
None.

**9.4.4State Space Representation
9.4.4.1State Space Representation Overview**
State Space Representation (SSR) is a foundational dynamical systems representation, commonly used in control
systems. In this representation, a system is described by a set of _state variables_ whose evolution by a _state equation_
(not that this is a different conception of "state" than used in the behavioral state modeling constructs described in
7.17). The system outputs are then given by an _output equation._ This representation provides a description of the
quantitative stateful behavior of the target system in an explicit manner so that external solvers can compute the
behavior by properly integrating input and state variables.

**514 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Mathematically, let **x** be a vector of state variables and **x'** be its time derivative, **u** be a vector of inputs, and **y** be a
vector of outputs. Then the state equation has the form
**x'** = _f_ ( **x** , **u** ) ,
for some system-specific function _f_ , and the output equation has the form
**y** = _g_ ( **x** , **u** ) ,
for some system-specific function _g_.
The _StateSpaceRepresentation_ library model is a model of this representation in terms of SysML actions and
calculations. These can be used in combination with end-user action models to describe system functional behaviors.
**9.4.4.2Elements**
Fig. 54shows the action definitions in the State Space Representation library.This library defines
StateSpaceDynamicsas the base abstract action definition, which provides the basic structure of input, output,
and state space.This definition hasgetNextStateandgetOuputcalculations as well to calculate the next state
and the current output, which corresponds to the math functions of _f_ () and _g_ (), respectively.
ContinuousStateSpaceDynamicsgives the continuous extension ofStateSpaceDynamicsby redefininig
getNextStateand addinggetDerivativethat calculates the derivative of the state space, corresponding to **x'**.
Likewise,DiscreteStateSpaceDinamicsgives the discrete extension by addinggetDifferencethat
calculates ∆ **x** , that is the difference between the current state and the next state, andgetNextStateadds it to
stateSpace.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 515**


**Figure 54. State Space Representation action and calculation definitions**
zeroCrossingEventsdefined inContinuousStateSpaceDynamicsgive event occurrences when the
derivative cross the zero.Some solvers, especially variable-step ones, need to identify such points for precise
integration and thus implementations ofContinuousStateSpaceDynamicsmay notify zero-crossings with these
event occurrences.

**9.4.5Trade Studies
9.4.5.1Trade Studies Overview**
This package provides a simple framework for defining trade-off study analysis cases.
**9.4.5.2Elements
9.4.5.2.1 EvaluationFunction
Element**
CalculationDefinition
**Description**

**516 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


An _EvaluationFunction_ is a calculation that evaluates a _TradeStudy_ alternative, producing a _ScalarValue_
that can be compared with the evaluation of other alternatives.
**General Types**
Calculation
**Features**
alternative : Anything
The alternative to be evaluated
result : ScalarValue {redefines result}
A _ScalarValue_ representing the evaluation of the given alternative.
**Constraints**
None.
**9.4.5.2.2 MaximizeObjective
Element**
RequirementDefinition
**Description**
A _MaximizeObjective_ is a _TradeStudyObjective_ that requires that the _selectedAlternative_ have the
maximum _EvaluationFunction_ value of all the given alternatives.
**General Types**
TradeStudyObjective
**Features**
best : ScalarValue {redefines best}
For a _MaximizeObjective_ , the best value is the maximum one.
**Constraints**
None.
**9.4.5.2.3 MinimizeObjective
Element**
RequirementDefinition
**Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 517**


A _MinimizeObjective_ is a _TradeStudyObjective_ that requires that theselectedAlternativehave the
minimum _EvaluationFunction_ value of all the given alternatives.
**General Types**
TradeStudyObjective
**Features**
best : ScalarValue {redefines best}
For a _MinimizeObjective_ , the best value is the minimum one.
**Constraints**
None.
**9.4.5.2.4 TradeStudy
Element**
AnalysisCaseDefinition
**Description**
A _TradeStudy_ is an analysis case whose subject is a set of alternatives (at least one) and whose result is a selection
of one of those alternatives. The alternatives are evaluated based on a given _ObjectiveFunction_ and the selection
is made such that it satisfies the objective of the _TradeStudy_ (which must be a _TradeStudyObjective_ ).
**General Types**
AnalysisCase
**Features**
evaluationFunction : EvaluationFunction [0..*]
The _EvaluationFunction_ to be used to evaluate the alternatives.
In a _TradeStudy_ usage, redefine this feature to provide the desired calculation (or bind it to a calculation usage that
does so).
selectedAlternative : Anything {redefines result}
The alternative selected by this _TradeStudy_ , which is the one that meets the requirement of the
_tradeStudyObjective_.
studyAlternatives : Anything [1..*] {redefines subj}
The set of alternatives being considered in this _TradeStudy_.
In a _TradeStudy_ usage, bind this feature to the actual collection of alternatives to be considered.
tradeStudyObjective : TradeStudyObjective {redefines objective}

**518 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The objective of this TradeStudy.
Redefine this feature to give it a definition that is a concrete specialization of TradeStudyObjective. That can either
be one of the specializations provided in this package, or a more specific user-defined one.
**Constraints**
None.
**9.4.5.2.5 TradeStudyObjective
Element**
RequirementDefinition
**Description**
A _TradeStudyObjective_ is the base definition for the objective of a _TradeStudy_. The requirement is to choose
from a given set of alternatives the _selectedAlternative_ for that has the best evaluation according to a given
_EvaluationFunction_. What value is considered "best" is not defined in the abstract base definition but must be
computed in any concrete specialization.
**General Types**
RequirementCheck
**Features**
alternatives : Anything [1..*]
The alternatives being considered in the _TradeStudy_ for which this _TradeStudyObjective_ is the objective.
best : ScalarValue
Out of the evaluation results of all the given alternatives, the one that is considered "best", in the sense that it is the
value the _selectedAlternative_ should have. This value must be computed in any concrete specialization of
_TradeStudyObjective/em>._
fn : EvaluationFunction
The EvaluationFunction to be used in evaluating the given alternatives.
selectedAlternative : Anything {redefines subj}
The alternative that should be selected, as evaluated using the given _EvaluationFunction_.
**Constraints**
[no name]
fn(selectedAlternative) == best

**9.5Cause and Effect Domain Library
9.5.1Cause and Effect Domain Library Overview**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 519**


**9.5.2Causation Connections
9.5.2.1Causation Connections Overview**
This package provides a library model modeling causes, effects, and causation connections between them.
**9.5.2.2Elements
9.5.2.2.1 Causation
Element**
ConnectionDefinition
**Description**
A _Causation_ is a binary _Multicausation_ in which a single cause occurrence causes a single effect occurrence.
(However, a single cause can separately have multiple effects, and a single effect can have separate _Causation_
connections with multiple causes.)
**General Types**
Multicausation
**Features**
theCause : Occurrence [0..*] {redefines causes}
The single causing occurrence.
theEffect : Occurrence [0..*] {redefines effects}
The single effect occurrence resulting from the cause.
**Constraints**
None.
**9.5.2.2.2 causations
Element**
ConnectionUsage
**Description**
_causations_ is the base feature for _Causation_ ConnectionUsages.
**General Types**
Causation
multicausations
**Features**
[no name] : Occurrence

**520 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


[no name] : Occurrence
**Constraints**
None.
**9.5.2.2.3 causes
Element**
OccurrenceUsage
**Description**
_Occurrences_ that are causes.
**General Types**
occurrences
**Features**
None.
**Constraints**
None.
**9.5.2.2.4 effects
Element**
OccurrenceUsage
**Description**
_Occurrences_ that are effects.
**General Types**
occurrences
**Features**
None.
**Constraints**
None.
**9.5.2.2.5 Multicausation
Element**
ConnectionDefinition

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 521**


**Description**
A _Multicausation_ connection models the situation in which one set of occurrences causes another. All causes
must at least exist before all effects.
To create a _Multicausation_ connection, specialize this connection definition adding specific end features of the
relavent types. Ends representing causes should subset _causes_ , while ends representing effects should subset
_effects_. There must be at least one cause and at least one effect.
**General Types**
Connection
**Features**
causes : Occurrence [1..*] {subsets participant}
The causing occurrences.
Redefines _CausationConnections::causes_ in the context of _Multicausation_.
effects : Occurrence [1..*] {subsets participant}
The effect occurrences caused by the causing occurrences.
Redefines _CausationConnections::effects_ in the context of _Multicausation_.
**Constraints**
disjointCauseEffect
_causes_ must be disjoint from _effects_.
isEmpty(intersection(causes, effects))
**9.5.2.2.6 multicausations
Element**
ConnectionUsage
**Description**
_multicausations_ is the base feature for _Multicausation_ ConnectionUsages.
**General Types**
connections
Multicausation
**Features**
None.
**Constraints**

**522 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


None.

**9.5.3Cause and Effect
9.5.3.1Cause and Effect Overview**
This package provides language-extension metadata for cause-effect modeling.
**9.5.3.2Elements
9.5.3.2.1 CausationMetadata
Element**
MetadataDefinition
**Description**
_CausationMetadata_ allows for the specification of additional metadata about a cause-effect
ConnectionDefinitionorConnectionUsage..
**General Types**
MetadataItem
**Features**
annotatedElement1 : ConnectionDefinition {subsets annotatedElement}
annotatedElement2 : ConnectionUsage {subsets annotatedElement}
isNecessary : Boolean
Whether all the causes are necessary for all the effects to occur. If this is false (the default), then some or all of the
effects may still have occurred even if some of the causes did not.
isSufficient : Boolean
Whether the causes were sufficient for all the effects to occur. If this is false (the default), then it may be the case
that some other occurrences were also necessary for some or all of the effects to have occurred.
probability : Real [0..1]
The probability that the causes will actually result in effects occurring.
**Constraints**
None.
**9.5.3.2.2 CausationSemanticMetadata
Element**
MetadataDefinition
**Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 523**


_CausationMetadata_ (short name _causation_ ) is _SemanticMetadata_ for a _Causation_ connection.
**General Types**
CausationMetadata
SemanticMetadata
**Features**
baseType : Type {redefines baseType}
Base type is _CausationConnections::causations_.
**Constraints**
None.
**9.5.3.2.3 CauseMetadata
Element**
MetadataDefinition
**Description**
_CauseMetadata_ (short name _cause_ ) identifies aUsageas being a cause occurrence. It is intended to be used to tag
the cause ends of a _Multicausation_.
**General Types**
MetadataItem
SemanticMetadata
**Features**
annotatedElement : Usage {redefines annotatedElement}
baseType : Type {redefines baseType}
Base type is _CausationConnections::causes_.
**Constraints**
None.
**9.5.3.2.4 EffectMetadata
Element**
MetadataDefinition
**Description**
_EffectMetadata_ (short name _effect_ ) identifies aUsageas being a effect occurrence. It is intended to be used to
tag the effect ends of a _Multicausation_.

**524 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Types**
MetadataItem
SemanticMetadata
**Features**
annotatedElement : Usage {redefines annotatedElement}
baseType : Type {redefines baseType}
Base type is _CausationConnections::effects_.
**Constraints**
None.
**9.5.3.2.5 MulticausationSemanticMetadata
Element**
MetadataDefinition
**Description**
_MulticausationMetadata_ (short name _multicausation_ ) is _SemanticMetadata_ for a _Multicausation_
connection.
**General Types**
CausationMetadata
SemanticMetadata
**Features**
baseType : Type {redefines baseType}
Base type is _CausationConnections::multicausations_.
**Constraints**
None.

**9.6Requirement Derivation Domain Library
9.6.1Requirement Derivation Domain LIbrary Overview
9.6.2Derivation Connections
9.6.2.1Derivation Connections Overview**
This package provides a library model for derivation connections between requirements.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 525**


**9.6.2.2Elements
9.6.2.2.1 Derivation
Element**
ConnectionDefinition
**Description**
A _Derivation_ connection asserts that one or more _derivedRequirements_ are derived from a single
_originalRequirement_. This means that any subject that satisfies the _originalRequirement_ should, in itself or
though other things related to it, satisfy each of the _derivedRequirements_.
AConnectionUsagetyped by _Derivation_ must haveRequirementUsagesfor all its ends. The single end for
the original requirement should subset _originalRequirement_ , while the rest of the ends should subset
_derivedRequirements_.
**General Types**
Connection
**Features**
derivedRequirements : RequirementCheck [1..*] {subsets participant}
The one or more requirements that are derived from the original requirement.
Redefines _DerivationConnections::derivedRequirements_ in the context of _Derivation_.
originalRequirement : RequirementCheck {subsets participant}
The single original requirement.
Redefines _DerivationConnections::originalRequirement_ in the context of _Derivation_.
participant : RequirementCheck [2..*] {redefines participant}
All the _participants_ in a _Derivation_ must be requirements.
**Constraints**
originalImpliesDerived
Whenever the _originalRequirement_ is satisfied, all of the _derivedRequirements_ must also be satisfied.
originalRequirement.result implies allTrue(derivedRequirements.result)
originalNotDerived
The original requirement must not be a derived requirement.
derivedRequirements->excludes(originalRequirement)

**526 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.6.2.2.2 derivations
Element**
ConnectionUsage
**Description**
_derivations_ is the base feature for _Derivation_ ConnectionUsages.
**General Types**
connections
Derivation
**Features**
None.
**Constraints**
None.
**9.6.2.2.3 derivedRequirements
Element**
RequirementUsage
**Description**
_derivedRequirements_ are the derived requirements in _Derivation_ connections.
**General Types**
occurrences
**Features**
None.
**Constraints**
None.
**9.6.2.2.4 originalRequirements
Element**
RequirementUsage
**Description**
_originalRequirements_ are the original requirements in _Derivation_ connections.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 527**


**General Types**
occurrences
**Features**
None.
**Constraints**
None.

**9.6.3Requirement Derivation
9.6.3.1Requirement Derivation Overview**
This package provides language-extension metadata for modeling requirement derivation.
**9.6.3.2Elements
9.6.3.2.1 DerivationMetadata
Element**
MetadataDefinition
**Description**
_DerivationMetadata_ (short name _derivation_ ) is _SemanticMetadata_ for a _Derivation_ connection.
**General Types**
MetadataItem
SemanticMetadata
**Features**
annotatedElement1 : ConnectionDefinition {subsets annotatedElement}
annotatedElement2 : ConnectionUsage {subsets annotatedElement}
baseType : Type
Base type is _DerivationConnections::derivations_.
**Constraints**
None.
**9.6.3.2.2 DerivedRequirementMetadata
Element**
MetadataDefinition
**Description**

**528 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


_DerivedlRequirementMetadata_ (short name _derive_ ) identifies aUsageas a derived requirement. It is
intended to be used to tag the derived requirement ends of a _Derivation_.
**General Types**
MetadataItem
SemanticMetadata
**Features**
annotatedElement : Usage
baseType : Type
Base type is _DerivationConnections::derivedRequirements_.
**Constraints**
None.
**9.6.3.2.3 OriginalRequirementMetadata
Element**
MetadataDefinition
**Description**
_OriginalRequirementMetadata_ (short name _original_ ) identifies aUsageas an original requirement. It is
intended to be used to tag the original requirement end of a _Derivation_.
**General Types**
MetadataItem
SemanticMetadata
**Features**
annotatedElement : Usage
baseType : Type
Base type is _DerivationConnections::originalRequirements_.
**Constraints**
None.

**9.7Geometry Domain Library
9.7.1Geometry Domain Library Overview
9.7.2Spatial Items**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 529**


**9.7.2.1Spatial Items Overview**
This package models physical items that have a spatial extent and act as a spatial frame of reference for obtaining
position and displacement vectors of points within them.
**9.7.2.2Elements
9.7.2.2.1 CurrentDisplacementOf
Element**
CalculationDefinition
**Description**
The _CurrentDisplacementOf_ two _Points_ relative to a _SpatialItem_ and a _Clock_ is the _DisplacementOf_ the
_Points_ relative to the _SpacialItem_ , at the _currentTime_ of the _Clock_.
**General Types**
CurrentDisplacementOf
**Features**
clock : Clock {redefines clock}
displacementVector : VectorQuantityValue {redefines displacementVector}
frame : SpatialItem {redefines frame}
point1 : Point {redefines point1}
point2 : Point {redefines point2}
**Constraints**
None.
**9.7.2.2.2 CurrentPositionOf
Element**
CalculationDefinition
**Description**
The _CurrentPositionOf_ a _Point_ relative to a _SpatialItem_ and a _Clock_ is the _PositionOf_ the _Point_
relative to the _SpatialItem_ at the _currentTime_ of the _Clock_.
**General Types**
CurrentPositionOf
**Features**

**530 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


clock : Clock {redefines clock}
point : Point {redefines point}
positionVector : VectorQuantityValue {redefines positionVector}
spatialItem : SpatialItem {redefines frame}
**Constraints**
None.
**9.7.2.2.3 DisplacementOf
Element**
CalculationDefinition
**Description**
The _DisplacementOf_ two _Points_ relative to a _SpatialItem_ , at a specific _TimeInstantValue_ relative to a
given _Clock_ , is the _displacementVector_ computed as the difference between the _PositionOf_ the first _Point_
and _PositionOf_ the second _Point_ , relative to that _SpatialItem_ , at that _timeInstant_.
**General Types**
DisplacementOf
**Features**
clock : Clock {redefines clock}
displacementVector : VectorQuantityValue {redefines displacementVector}
frame : SpatialItem {redefines frame}
point1 : Point {redefines point1}
point2 : Point {redefines point2}
time : TimeInstantValue {redefines time}
**Constraints**
zeroDisplacementConstraint
If either _point1_ or _point2_ occurs within the other, then the _displacementVector_ is the zero vector.
(point1.spaceTimeEnclosedOccurrences->includes(point2) orpoint2.spaceTimeEnclosedOccurrences->includes(point1)) implies
isZeroVector(displacementVector)
**9.7.2.2.4 PositionOf
Element**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 531**


CalculationDefinition
**Description**
The _PositionOf_ a _Point_ relative to a _SpatialItem_ , at a specific _TimeInstantValue_ relative to a given
_Clock_ , is a _positionVector_ that is a _VectorQuantityValue_ in the _coordinateFrame_ of the _SpatialItem_.
The default _Clock_ is the _localClock_ of the _SpatialItem_.
**General Types**
PositionOf
**Features**
clock : Clock {redefines clock}
point : Point {redefines point}
positionVector : VectorQuantityValue {redefines positionVector}
spatialItem : SpatialItem {redefines frame}
time : TimeInstantValue {redefines time}
**Constraints**
positionTimePrecondition
The given _point_ must exist at the given _time_.
TimeOf(point.startShot) <= time andtime <= TimeOf(point.endShot)

spacePositionConstraint
The result _positionVector_ is equal to the _PositionOf_ the _PointspaceShot_ of the frame that encloses the
given _point_ , at the given _time_.
(frame.spaceShots as Point)->forAll{in p : Point;p.spaceTimeEnclosedOccurrences->includes(point) implies

} positionVector == PositionOf(p, time, frame)
**9.7.2.2.5 SpatialItem
Element**
ItemDefinition
**Description**
A _SpatialItem_ is an _Item_ with a three-dimensional spatial extent that also acts as a _SpatialFrame_ of reference.
**General Types**
SpatialFrame

**532 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Item
**Features**
componentItems : SpatialItem [0..*] {subsets subitems}
A _SpatialItem_ with _componentItems_ is entirely made up of those items (the _SpatialItem_ occurs only as a
collection of its _componentItems_ ). By default they have the same _localClock_ and equivalent
_coordinateFrame_ as the _SpatialItem_ they make up. A _SpatialItem_ without componentItems occurs on its
own, separately from its _subitems_.
coordinateFrame : VectorMeasurementReference
The three-dimensional _VectorMeasurementReference_ to be used as the measurement reference for position and
displacement vector values relative to this _SpatialItem_.
localClock : Clock {redefines localClock}
A local _Clock_ to be used as the corresponding time reference within this _SpatialItem_. By default this is the
singleton _Time::universalClock_.
originPoint : Point
The _Point_ at the origin of the _coordinateFrame_ of this _SpatialItem_.
**Constraints**
originPointConstraint
The _CurrentPositionOf_ the _originPoint_ must always be a zero vector.
isZeroVector(CurrentPositionOf(originPoint, SpatialItem::self))

**9.7.3Shape Items
9.7.3.1Shape Items Overview**
This package defines basic geometric _Items_ , most of which can be used as _shapes_ of other _Items_ (see7.10). Their
_innerSpaceDimensions_ are either 1 ( _Curves_ ) or 2 ( _Surfaces_ ), which is the number of variables needed to identify
any space point occupied by an Item, without regard to higher dimensional spaces in which it might be embedded
(see _Occurrences_ and _Objects_ in Kernel Modeling Language). All are _StructuredSpaceObjects_ ( _Paths_ and _Shells_ for
_Curves_ and _Surfaces_ , respectively), except for _Lines_. This enables them to divide their _spaceSlices_ into _faces_ ,
_edges_ , and _vertices_ , identifying _Surfaces_ , _Curve_ , and _Points_ , respectively. _Paths_ have no _faces_ , but _Shells_ do.
All the _Paths_ and _Shells_ are closed ( _isClosed_ =true, they have no _shape_ ), except for _Discs_ , enabling them to be
_shapes_ of other _Items_.
**9.7.3.2Elements
9.7.3.2.1 Circle
Element**
ItemDefinition
**Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 533**


A Circle is an Ellipse with semiaxes equal to itsradius.
**General Types**
Ellipse
**Features**
radius : LengthValue
semiMajorAxis {redefines semiMajorAxis}
**Constraints**
None.
**9.7.3.2.2 CircularCone
Element**
ItemDefinition
**Description**
A CircularCone is a Cone with a circular base.
**General Types**
Cone
**Features**
base : CircularDisc {redefines base}
radius : LengthValue
semiMajorAxis {redefines semiMajorAxis}
**Constraints**
None.
**9.7.3.2.3 CircularCylinder
Element**
ItemDefinition
**Description**
A CircularCylinder is a Cylinder with two circular sides.
**General Types**
Cylinder

**534 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
af : CircularDisc {redefines af}
base : CircularDisc {redefines base}
radius : LengthValue
semiMajorAxis {redefines semiMajorAxis}
**Constraints**
None.
**9.7.3.2.4 CircularDisc
Element
Description**
A CircularDisc is a Disc bound by a Circle.
**General Types**
Disc
**Features**
edges : Circle {redefines edges}
radius : LengthValue
shape : Circle {redefines shape}
**Constraints**
None.
**9.7.3.2.5 Cone
Element**
ItemDefinition
**Description**
A Cone has one elliptical sides joined to a point by a curved side.
**General Types**
ConeOrCylinder
**Features**
af {redefines af}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 535**


apex {subsets vertices}
edges {redefines edges}
faces {redefines faces}
**Constraints**
None.
**9.7.3.2.6 ConeOrCylinder
Element**
ItemDefinition
**Description**
A ConeOrCylinder is a Cone or a Cylinder with a given elliptical base, height, width (perpendicular distance from
the base to the center of the top side or vertex), and offsets of this perpendicular at the base from the center of the
base.
**General Types**
Shell
**Features**
ae [0..2] {subsets edges}
af : Disc [0..1] {subsets faces}
base : Disc {subsets faces}
be {subsets edges}
cf {subsets faces}
edges [2..4] {redefines edges}
faces : Surface [2..3] {redefines faces}
height : LengthValue
semiMajorAxis : LengthValue
semiMinorAxis : LengthValue
vertices [0..1] {redefines vertices}
xoffset : LengthValue
yoffset : LengthValue
**Constraints**

**536 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


None.
**9.7.3.2.7 ConicSection
Element**
ItemDefinition
**Description**
A ConicSection is a closed PlanarCurve, possibly disconnected, see Hyperbola.
**General Types**
PlanarCurve
Path
**Features**
edges [1..2] {redefines edges}
isClosed {redefines isClosed}
vertices {redefines vertices}
**Constraints**
None.
**9.7.3.2.8 ConicSurface
Element**
ItemDefinition
**Description**
A ConicSurface is a Surface that has ConicSection cross-sections.
**General Types**
Shell
**Features**
edges {redefines edges}
faces [1..2] {redefines faces}
genus {redefines genus}
vertices {redefines vertices}
**Constraints**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 537**


None.
**9.7.3.2.9 Cuboid
Element**
ItemDefinition
**Description**
A Cuboid is a Polyhedron with six sides, all quadrilateral.
**General Types**
CuboidOrTriangularPrism
**Features**
edges {redefines edges}
faces {redefines faces}
ff : Quadrilateral {redefines ff}
rf : Quadrilateral {redefines rf}
**Constraints**
None.
**9.7.3.2.10 CuboidOrTriangularPrism
Element**
ItemDefinition
**Description**
A CuboidOrTriangularPrism is a Polyhedron that is either a Cuboid or TriangularPrism.
**General Types**
Polyhedron
**Features**
bf : Quadrilateral {subsets faces}
bfe {subsets edges}
bflv {subsets vertices}
bfrv {subsets vertices}
bre {subsets edges}

**538 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


brlv {subsets vertices}
brrv {subsets vertices}
bsle {subsets edges}
bsre {subsets edges}
edges [0..*] {redefines edges}
faces [5..6] {redefines faces}
ff : Polygon {subsets faces}
rf : Polygon {subsets faces}
slf : Quadrilateral {subsets faces}
srf : Quadrilateral [0..1] {subsets faces}
tf : Quadrilateral {subsets faces}
tfe {subsets edges}
tflv {subsets vertices}
tfrv [0..3] {subsets vertices}
tre {subsets edges}
trlv {subsets vertices}
trrv [0..3] {subsets vertices}
tsle {subsets edges}
tsre [0..2] {subsets edges}
ufle {subsets edges}
ufre [0..2] {subsets edges}
urle {subsets edges}
urre [0..2] {subsets edges}
vertices {redefines vertices}
**Constraints**
None.
**9.7.3.2.11 Cylinder
Element**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 539**


ItemDefinition
**Description**
A Cylinder has two elliptical sides joined by a curved side.
**General Types**
ConeOrCylinder
**Features**
ae {redefines ae}
af {redefines af}
edges {redefines edges}
faces {redefines faces}
vertices {redefines vertices}
**Constraints**
None.
**9.7.3.2.12 Disc
Element**
ItemDefinition
**Description**
A Disc is a Shell bound by an Ellipse.
**General Types**
PlanarSurface
Shell
**Features**
edges : Ellipse {redefines edges}
faces : PlanarSurface {redefines faces}
semiMajorAxis : LengthValue
semiMinorAxis : LengthValue
shape : Ellipse {redefines shape}
vertices {redefines vertices}

**540 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
None.
**9.7.3.2.13 EccentricCone
Element**
ItemDefinition
**Description**
An EccentricCone is a Cone with least one positive offset.
**General Types**
Cone
**Features**
None.
**Constraints**
None.
**9.7.3.2.14 EccentricCylinder
Element**
ItemDefinition
**Description**
An EccentricCylinder is a Cylinder with least one positive offset.
**General Types**
Cylinder
**Features**
None.
**Constraints**
None.
**9.7.3.2.15 Ellipse
Element**
ItemDefinition
**Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 541**


An Ellipse is a ConicSection in the shape of an ellipse of given semiaxes.
**General Types**
ConicSection
**Features**
edges {redefines edges}
semiMajorAxis : LengthValue
semiMinorAxis : LengthValue
**Constraints**
None.
**9.7.3.2.16 Ellipsoid
Element**
ItemDefinition
**Description**
An Ellipsoid is a ConicSurface with only elliptical cross-sections.
**General Types**
ConicSurface
**Features**
faces {redefines faces}
semiAxis1 : LengthValue
semiAxis2 : LengthValue
semiAxis3 : LengthValue
**Constraints**
None.
**9.7.3.2.17 Hyperbola
Element**
ItemDefinition
**Description**
A Hyperbola is a planar Path in the shape of a hyperbola with given axes.

**542 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Types**
ConicSection
**Features**
conjugateAxis : LengthValue
tranverseAxis : LengthValue
**Constraints**
None.
**9.7.3.2.18 Hyperboloid
Element**
ItemDefinition
**Description**
A Hyperboloid is a ConicSurface with only hyperbolic cross-sections.
**General Types**
ConicSurface
**Features**
conjugateAxis : LengthValue
transverseAxis : LengthValue
**Constraints**
None.
**9.7.3.2.19 Line
Element**
ItemDefinition
**Description**
A Line is a PlanarCurve that is straight.
**General Types**
PlanarCurve
**Features**
outerSpaceDimension {redefines outerSpaceDimension}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 543**


**Constraints**
None.
**9.7.3.2.20 Parabola
Element**
ItemDefinition
**Description**
A Parabola is a planar Path in the shape of a parabola of a given focal length.
**General Types**
ConicSection
**Features**
edges {redefines edges}
focalDistance : LengthValue
**Constraints**
None.
**9.7.3.2.21 Paraboloid
Element**
ItemDefinition
**Description**
A Paraboloid is a ConicSurface with only parabolic cross-sections.
**General Types**
ConicSurface
**Features**
faces {redefines faces}
focalDistance : LengthValue
**Constraints**
None.
**9.7.3.2.22 Path
Element**

**544 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


ItemDefinition
**Description**
Path is the most general structured Curve.
**General Types**
StructuredSpaceObject
Item
Curve
**Features**
edges [1..*] {redefines edges}
faces {redefines faces}
vertices {redefines vertices}
**Constraints**
None.
**9.7.3.2.23 PlanarCurve
Element**
ItemDefinition
**Description**
A PlanarCurve is a Curve with a givenlengthembeddable in a plane.
**General Types**
Item
Curve
**Features**
length : LengthValue
outerSpaceDimension {redefines outerSpaceDimension}
**Constraints**
None.
**9.7.3.2.24 PlanarSurface
Element**
ItemDefinition

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 545**


**Description**
A PlanarSurface is a Surface with givenareathat is flat.
**General Types**
Surface
Item
**Features**
area : LengthValue
outerSpaceDimension {redefines outerSpaceDimension}
**Constraints**
None.
**9.7.3.2.25 Polygon
Element**
ItemDefinition
**Description**
A Polygon is a closed planar Path with straight edges.
**General Types**
PlanarCurve
Path
**Features**
edges : Line {redefines edges}
isClosed {redefines isClosed}
**Constraints**
None.
**9.7.3.2.26 Polyhedron
Element**
ItemDefinition
**Description**
A Polyhedron is a closed Shell with polygonal sides.
**General Types**

**546 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Shell
**Features**
edges {redefines edges}
faces : Polygon [2..*] {redefines faces}
genus {redefines genus}
isClosed
outerSpaceDimension {redefines outerSpaceDimension}
vertices [0..*] {redefines vertices}
**Constraints**
None.
**9.7.3.2.27 Pyramid
Element**
ItemDefinition
**Description**
p>A Pyramid is a Polyhedron with the sides of a polygon (base) forming the bases of triangles that join at an apex
point. Itsheightis the perpindicular distance from the base to the apex, and its offsets are between this
perpindicular at the base and the center of the base.
**General Types**
Polyhedron
**Features**
apex [0..*] {redefines vertices}
base {subsets faces}
edges [0..*] {redefines edges}
faces [0..*]
height : LengthValue
wall : Triangle [0..*] {subsets faces}
wallNumber : Positive
xoffset : LengthValue
yoffset : LengthValue

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 547**


**Constraints**
None.
**9.7.3.2.28 Quadrilateral
Element**
ItemDefinition
**Description**
A Quadrilateral is a four-sided Polygon.
**General Types**
Polygon
**Features**
e1
e2
e3
edges {redefines edges}
v12 {subsets vertices, ordered}
v23 {subsets vertices, ordered}
v34 {subsets vertices, ordered}
v41 {subsets vertices, ordered}
vertices {redefines vertices}
**Constraints**
None.
**9.7.3.2.29 Rectangle
Element**
ItemDefinition
**Description**
A Rectangle is a Quadrilateral four right angles and givenlengthandwidth.
**General Types**
Quadrilateral

**548 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
length : LengthValue
width : LengthValue
**Constraints**
None.
**9.7.3.2.30 RectangularCuboid
Element**
ItemDefinition
**Description**
A RectangularCuboid is a Cuboid with all Rectangular sides.
**General Types**
Cuboid
**Features**
bf : Rectangle {redefines bf}
ff : Rectangle {redefines ff}
height : LengthValue
length : LengthValue
rf : Rectangle {redefines rf}
slf : Rectangle {redefines slf}
srf : Rectangle {redefines srf}
tf : Rectangle {redefines tf}
width : LengthValue
**Constraints**
None.
**9.7.3.2.31 RectangularPyramid
Element**
ItemDefinition
**Description**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 549**


A RectangularPyramid is Pyramid with a rectangular base.
**General Types**
Pyramid
**Features**
base : Rectangle {redefines base}
baseLength : LengthValue
baseWidth : LengthValue
**Constraints**
None.
**9.7.3.2.32 RectangularToroid
Element**
ItemDefinition
**Description**
A RectangularToroid is a revolution of a Rectangle.
**General Types**
Toriod
**Features**
rectangleLength : LengthValue
rectangleWidth : LengthValue
revolvedCurve : Rectangle {redefines revolvedCurve}
**Constraints**
None.
**9.7.3.2.33 RightCircularCone
Element**
ItemDefinition
**Description**
A RightCircularCone is a CircularCone with zero offsets.
**General Types**

**550 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


CircularCone
**Features**
xoffset {redefines xoffset}
yoffset {redefines yoffset}
**Constraints**
None.
**9.7.3.2.34 RightCircularCylinder
Element**
ItemDefinition
**Description**
A RightCircularCylinder is a CircularCylinder with zero offsets.
**General Types**
CircularCylinder
**Features**
xoffset {redefines xoffset}
yoffset {redefines yoffset}
**Constraints**
None.
**9.7.3.2.35 RightTriangle
Element**
ItemDefinition
**Description**
A RightTriangle is a Triangle with edges opposite thehypotenuseat right angles.
**General Types**
Triangle
**Features**
hypotenuse {redefines e3}
xoffset {redefines xoffset}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 551**


**Constraints**
None.
**9.7.3.2.36 RightTriangularPrism
Element**
ItemDefinition
**Description**
A RightTriangularPrism a TriangularPrism with two right triangluar sides, with givenlength,width, andheight.
**General Types**
TriangularPrism
**Features**
bf : Rectangle {redefines bf}
ff : RightTriangle {redefines ff}
height : LengthValue
length : LengthValue
rf : RightTriangle {redefines rf}
slf : Rectangle {redefines slf}
tf : Rectangle {redefines tf}
width : LengthValue
**Constraints**
None.
**9.7.3.2.37 Shell
Element**
ItemDefinition
**Description**
Shell is the most general structured Surface.
**General Types**
StructuredSpaceObject
Surface
Item

**552 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
None.
**Constraints**
None.
**9.7.3.2.38 Sphere
Element**
ItemDefinition
**Description**
A Sphere is an Ellipsoid with all the same semiaxes.
**General Types**
Ellipsoid
**Features**
radius : LengthValue
semiAxis1 {redefines semiAxis1}
semiAxis2
**Constraints**
None.
**9.7.3.2.39 Tetrahedron
Element**
ItemDefinition
**Description**
A Tetrahedron is Pyramid with a triangular base.
**General Types**
Pyramid
**Features**
base : Triangle {redefines base}
baseLength : LengthValue
baseWidth : LengthValue

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 553**


**Constraints**
None.
**9.7.3.2.40 Toriod
Element**
ItemDefinition
**Description**
A Toroid is a surface generated from revolving a planar closed curve about an line coplanar with the curve. It is
single sided with one hole.
**General Types**
Shell
**Features**
edges {redefines edges}
faces {redefines faces}
genus {redefines genus}
revolutionRadius : LengthValue
revolvedCurve : PlanarCurve
vertices {redefines vertices}
**Constraints**
None.
**9.7.3.2.41 Torus
Element**
ItemDefinition
**Description**
A Torus is a revolution of a Circle.
**General Types**
Toriod
**Features**
majorRadius {redefines revolutionRadius}

**554 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


minorRadius : LengthValue
revolvedCurve : Circle {redefines revolvedCurve}
**Constraints**
None.
**9.7.3.2.42 Triangle
Element**
ItemDefinition
**Description**
A Triangle is three-sided Polygon with givenlength(base), width (perpindicular distance from base to apex), and
offset of this perpindicular at the base from the center of the base.
**General Types**
Polygon
**Features**
apex {subsets vertices, ordered}
base {subsets edges}
e2 {subsets edges}
e3 {subsets edges}
edges {redefines edges}
length : LengthValue
v12 {subsets vertices, ordered}
v31 {subsets vertices, ordered}
vertices {redefines vertices}
width : LengthValue
xoffset : LengthValue
**Constraints**
None.
**9.7.3.2.43 TriangularPrism
Element**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 555**


ItemDefinition
**Description**
A TriangularPrism is a Polyhedron with five sides, two triangular and the others quadrilateral.
**General Types**
CuboidOrTriangularPrism
**Features**
edges {redefines edges}
faces {redefines faces}
ff : Triangle {redefines ff}
rf : Triangle {redefines rf}
**Constraints**
None.

**9.8Quantities and Units Domain Library
9.8.1Quantities and Units Domain Library Overview**
For any system model, a solid foundation for the representation of physical quantities, their units, scales, and
quantity dimensions, as well as coordinate frames is essential. Quantity attributes are needed to specify many
characteristics of a system of interest and its elements. The foundation should be a shareable resource that can be
reused in models within and across projects as well as organizations in order to facilitate collaboration and model
interoperability.
The Quantities and Units Domain Library defines reusable and extensible model elements for physical quantities,
including vector and tensor quantities, quantity dimensions, measurement units, measurement scales, coordinate
frames, coordinate transformations and vector spaces. The library also provides enables the specification of coherent
systems of quantities and systems of units, as well as the operators and functions needed to support quantity
arithmetic in expressions.
The most widely accepted, scrutinized, and globally used specification of quantities and units is captured and
maintained in:

- the International System of Quantities (ISQ)
- the International System of Units (SI)
The ISQ and SI are formally standardized through the ISO/IEC 80000 series of standards. The top level concepts
and semantics defined in this domain library are derived from and mapped to the concepts and semantics specified
in [ISO 80000-1] and [VIM], as directly as possible, but staying at a generic level. This enables the representation of
the ISQ and the SI, but also of any other system of quantities or system of units.
The data model specifies a precise representation of the relationships between quantities, units, scales, quantity
dimensions, coordinate frames, coordinate transformations and vectors spaces. As a result, both robust automated

**556 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


conversion between quantity values expressed in compatible measurement units or scales is enabled, as well as static
type and quantity dimension analysis of expressions and constraints.
This library further contains lower level packages that specify the actual quantities, units and scales as standardized
in parts 3 to 13 of the ISO/IEC 80000 series as SysML AttributeDefinitions and AttributeUsages, that represent the
complete ISQ and SI. These packages provide a broad common basis, that can be extended and tailored for use by
particular communities of practice and industry sectors.
Apart from SI, the system of US Customary Units is still in wide industrial use, in particular in North America. The
library therefore also contains a package of US Customary Units, as specified in [NIST SP-811], and including their
relationships with ISQ quantities as well as the conversion factors to corresponding SI units.

**9.8.2Quantities
9.8.2.1Quantities Overview
Taxonomy**
The Quantities package defines the root elements to represent quantities and their values.
TensorQuantityValue (an AttributeDefinition ) andtensorQuantities(an AttributeUsage) are defined to
represent quantities at the most general level, and can represent any nthorder tensor quantity. Then,
VectorQuantityValue andvectorQuantitiesare defined as order 1 specializations of the tensor quantity
concepts, and finally, ScalarQuantityValue andscalarQuantitiesas order 0 specializations of the vector
quantity concepts.
**Quantity Values**
A quantity value is defined as a tuple of:

- a sequence of one or more mathematical numbers (as AttributeUsagenum),
- a measurement reference (as AttributeUsagemRef).
For a ScalarQuantityValue the sequence of numbers collapses to one single number, and the measurement reference
is typically a measurement unit or scale. For a VectorQuantityValue there must be as many numbers as needed to
define the magnitude and direction of the vector quantity, and a measurement reference that typically specifies a
coordinate frame, e.g., a sequence of 3 numbers for the vector components in a standard ortho-normal Cartesian 3D
vector space with the same measurement unit on each of the axes. For a TensorQuantityValue the measurement
reference must establish a reference frame compliant with the full dimensionality of the tensor quantity involved.
**Note.** The specification of a quantity value as a tuple of its numerical value and a measurement reference has the big
advantage that the type of a quantity value becomes independent from the choice of measurement reference. For
example: apowerexpressed as 1.5 watt has the same type (AttributeDefinition _PowerValue_ ) as apowerexpressed
as 1500 milliwatt. This is an improvement over SysML v1, where the choice of measurement unit or scale was
embedded in the value property type.
**Free versus Bound Quantities and Vector Spaces**
A TensorQuantityValue can be defined with respect to a free vector space product or a bound vector space product.
Similarly, a VectorQuantityValue can be defined with respect to a free or a bound vector space, and a
ScalarQuantityValue with respect to a free or bound number line, which can be regarded as a one-dimensional
vector space. In a free vector space, vectors can be added and vectors can be multiplied by a scalar number, where
both operations yield a new free vector. Free vectors have only magnitude and direction. A bound vector space
includes a particular choice of origin, and vectors in such a space can not be added nor multiplied by scalars.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 557**


AttributeUsageisBoundis used to capture this:falsespecifies a free vector space (product), andtruespecifies a
bound vector space (product).
Examples that (informally) illustrate the distinction between free and bound vector quantities are given by pairs of
quantities of the same quantity dimension:

1. Displacement vector (free) and the position vector (bound), both of quantity dimension length.
    Two displacement vectors can be added and yield a resulting displacement vector. A displacement vector
    can also be multiplied with a scalar factor, which changes only its magnitude. Two position vectors can
    not be added, nor can a position vector be multiplied by a scalar number. A position vector is always
    bound to the origin of its bound vector space. One can however subtract one position vector from another,
    and the result is a displacement vector. It is the displacement to get from the position defined by the first
    vector to that defined by the second vector.
2. Duration (free scalar) and time instant (bound scalar), both of quantity dimension time.
    Durations can be added and multiplied, time instants cannot. Time instant values can only be specified
    with respect to a measurement reference that is a time scale with some particular choice of zero. Such a
    time scale is the same as a (time) coordinate axis in a one-dimensional bound vector space.
**9.8.2.2Elements
9.8.2.2.1 3dVectorQuantityValue
Element
Description**
Most general representation of real 3-vector quantities.
Alias: _ThreeDVectorQuantityValu_
**General Types**
VectorQuantityValue
**Features**
num : Real {redefines num}
**Constraints**
None.
**9.8.2.2.2 QuantityDimension
Element**
AttributeDefinition
**Description**
A _QuantityDimension_ is the product of powers of the set of base quantities defined for a particular system of
quantities, units and scales.
**General Types**

**558 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


None.
**Features**
quantityPowerFactors : QuantityPowerFactor [0..*] {ordered}
**Constraints**
None.
**9.8.2.2.3 QuantityPowerFactor
Element**
AttributeDefinition
**Description**
A _QuantityPowerFactor_ is a representation of a quantity power factor, being the combination of a quantity and
an exponent.
A sequence of _QuantityPowerFactors_ for the _baseQuantities_ of a _SystemOfQuantities_ define the
_QuantityDimension_ of a scalar quantity.
**General Types**
None.
**Features**
exponent : Real
quantity : ScalarQuantityValue
**Constraints**
None.
**9.8.2.2.4 scalarQuantities
Element**
AttributeUsage
**Description**
AttributeUsagescalarQuantities : ScalarQuantityValue[*] nonuniqueis the subset of
vectorQuantitiesthat defines a top-level general self-standing attribute that can be used to consistently specify
scalar quantities of Occurrences.
Any particular scalar quantity attribute is specified by subsettingscalarQuantities. In other words, the co-
domain of a scalar quantity attribute is a suitable specialization of ScalarQuantityValue.
**General Types**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 559**


vectorQuantities
ScalarQuantityValue
**Features**
None.
**Constraints**
None.
**9.8.2.2.5 ScalarQuantityValue
Element**
AttributeDefinition
**Description**
A _ScalarQuantityValue_ is an abstractAttributeDefinitionthat specializes _VectorQuantityValue_. It
represents a scalar quantity value as a tuple of aNumber _num_ and aScalarMeasurementReferencemRef. By
definition it has _order_ zero. The _ScalarMeasurementReference_ is typically a _MeasurementUnit_ or a
MeasurementScale _MeasurementUnitMeasurementScale_.
**General Types**
VectorQuantityValue
NumericalValue
**Features**
mRef : ScalarMeasurementReference {redefines mRef}
Specification of the ScalarMeasurementReference for the value of the scalar quantity.
**Constraints**
oneElement
dimensions[1] == 1
**9.8.2.2.6 SystemOfQuantities
Element**
AttributeDefinition
**Description**
A _SystemOfQuantities_ represents the essentials of [VIM] concept "system of quantities" (https://jcgm.bipm.org/
vim/en/1.3.html), defined as a "set of quantities together with a set of noncontradictory equations relating those
quantities". In order to establish such a set of noncontradictory equations a set of _baseQuantities_ is selected.
Subsequently the system of quantities is completed by adding derived quantities which are products of powers of the
base quantities.

**560 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**General Types**
None.
**Features**
baseQuantities : ScalarQuantityValue [0..*] {ordered}
**Constraints**
None.
**9.8.2.2.7 tensorQuantities
Element**
AttributeUsage
**Description**
AttributeUsagetensorQuantities : TensorQuantityValue[*] nonuniquedefines a top-level general self-
standing attribute that can be used to consistently specify quantities of Occurrences.
Any particular tensor quantity attribute is specified by subsettingtensorQuantities. In other words, the co-
domain of a tensor quantity attribute is a suitable specialization of TensorQuantityValue.
**General Types**
TensorQuantityValue
dataValues
**Features**
None.
**Constraints**
None.
**9.8.2.2.8 TensorQuantityValue
Element**
AttributeDefinition
**Description**
A TensorQuantityValue is an abstract AttributeDefinition and a specialization of _Collections::Array_ that represents
a tensor quantity value as a sequence of Numbers and a TensorMeasurementReference.
The dimensionality of the tensor quantity is specified indimensions, from which theorderof the tensor is
derived. In engineering the name 'tensor' is typically used if its order is 2 or greater, but mathematically a tensor can
have order 0 or 1.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 561**


A TensorQuantityValue must have the samedimensionsandorderas the TensorMeasurementReference that it
references via AttributeUsagemRef.
It is possible to specify the contravariant and covariant order of a tensor quantity through the AttributeUsages
contravariantOrderandcovariantOrder, the sum of which must be equal toorder. In applications where it
is not important to distinguish between contravariant and covariant tensors (or vectors), the convention is to use
contravariant by default and therefore setcontravariantOrderequal toorder, andcovariantOrderequal to
zero.
**General Types**
Array
**Features**
contravariantOrder : Positive
The number of contravariant indices of the tensor quantity.
covariantOrder : Positive
The number of covariant indices of the tensor quantity.
dimensions : Positive [0..*] {redefines dimensions, ordered, nonunique}
A sequence of positive integer numbers that define the dimensionality of the tensor quantity.
Examples: for a second order 3D tensordimensions = (3, 3);for fourth order 2D tensordimensions = (2,
2, 2, 2);
Thedimensionsmust be the same as thedimensionsof the associatedmRef.
isBound : Boolean
Assertion whether this tensor quantity is defined in a free (isBound == false) or bound (isBound == true)
vector space product.
mRef : TensorMeasurementReference
Specification of the TensorMeasurementReference for the value of the tensor quantity.
num : Number [1..*] {redefines elements, ordered, nonunique}
Sequence of numbers that specify the numerical value of the tensor quantity.
order : Natural {redefines rank}
Order of the tensor quantity. The order is derived to be equal to theorderof the associated
TensorMeasurementRefencemRef.
**Constraints**
boundMatch
(isBound == mRef.isBound) or (not isBound and mRef.isBound)

**562 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


orderSum
contravariantOrder + covariantOrder == order
**9.8.2.2.9 vectorQuantities
Element**
AttributeUsage
**Description**
AttributeUsagevectorQuantities : VectorQuantityValue[*] nonuniqueis the subset of
tensorQuantitiesthat defines a top-level general self-standing attribute that can be used to consistently specify
vector quantities of Occurrences.
Any particular vector quantity attribute is specified by subsettingvectorQuantities. In other words, the co-
domain of a vector quantity attribute is a suitable specialization of VectorQuantityValue.
**General Types**
VectorQuantityValue
tensorQuantities
**Features**
None.
**Constraints**
None.
**9.8.2.2.10 VectorQuantityValue
Element**
AttributeDefinition
**Description**
A VectorQuantityValue is an AttributeDefinition that represents the value of a vector quantity by a tuple of
Numbers and a VectorMeasurementReference. It is a specialization of TensorQuantityValue and hasorderone.
A VectorQuantityValue can be free (isBound == false) or bound (isBound == true). A value of a free vector
quantity is expressed using a free VectorMeasurementReference, in which there is no particular choice of zero or
origin. A value of a bound vector quantity is expressed using a bound VectorMeasurementReference that includes a
specified choice of origin. In both cases the VectorMeasurementReference typically defines a coordinate system.
**General Types**
TensorQuantityValue
NumericalVectorValue
**Features**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 563**


mRef : VectorMeasurementReference {redefines mRef}
Specification of the VectorMeasurementReference for the value of the vector quantity.
**Constraints**
[no name]
order == 1
**9.8.3Measurement References
9.8.3.1Measurement References Overview**
This package defines the general AttributeDefinitions and AttributeUsages to construct measurement references.
This includes:

- measurement units,
- ordinal, logarithmic and cyclic measurement scales,
- unit conversions,
- coordinate frames and coordinate transformations,
- measurement unit prefixes to denote multiples (such as _mega_ ) and sub-multiples (such as _nano_ ).
It also defines concepts to represent quantity dimensions, which form the basis for dimensional analysis of quantity
expressions.
**9.8.3.2Elements
9.8.3.2.1 3dCoordinateFrame
Element**
AttributeDefinition
**Description
General Types**
CoordinateFrame
**Features**
dimensions : Positive {redefines dimensions}
**Constraints**
None.
**9.8.3.2.2 AffineTransformationMatrix3d
Element**
AttributeDefinition
**Description**

**564 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


AffineTransformationMatrix3d is a three dimensional CoordinateTransformation specified via an affine 4x4
transformation matrix The interpretation of the matrix is as follows: - the upper left 3x3 matrix represents the
rotation matrix - the uper right 3x1 column vector represents the translation vector - the bottom row must be the row
vector (0, 0, 0, 1). I.e. the matrix has the following form: ( R, R, R, T, R, R, R, T, R, R, R, T, 0, 0, 0, 1 ) where the
cells marked R form the rotation matrix and the cells marked T form the translation vector. Note: See
https://en.wikipedia.org/wiki/Transformation_matrix, under affine transformations for a general explanation.
**General Types**
CoordinateTransformation
Array
**Features**
dimensions : Positive [0..*] {redefines dimensions, ordered, nonunique}
The _dimensions_ of an _AffineTransformationMatric3d_ are _(4,4)_.
elements : Real {redefines elements, ordered, nonunique}
**Constraints**
validSourceDimensions
source.dimensions == 3
**9.8.3.2.3 ConversionByConvention
Element**
AttributeDefinition
**Description**
ConversionByConvention is a UnitConversion that is defined according to some convention.
An example is the conversion relationship between "foot" (the owning MeasurementUnit) and "metre" (the
referenceUnitMeasurementUnit), withconversionFactor3048/10000, since 1 foot = 0.3048 metre, as
defined in [NIST SP-811].
**General Types**
UnitConversion
**Features**
None.
**Constraints**
None.
**9.8.3.2.4 ConversionByPrefix
Element**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 565**


AttributeDefinition
**Description**
ConversionByPrefix is a UnitConversion that is defined through reference to a named [ISO/IEC 80000-1]
UnitPrefix, which represents a conversion factor that is a decimal or binary multiple or sub-multiple.
Example 1: "kilometre" (symbol"km") with the 'kilo' UnitPrefix denoting conversion factor 1000 and
referenceUnit"metre".
Example 2: "nanofarad" (symbol"nF") with the 'nano' UnitPrefix denoting conversion factor1E-9and
referenceUnit"farad".
Example 3: "mebibyte" (symbol"MiB" or alias "MiByte") with the 'mebi' UnitPrefix denoting conversion factor
1024^2(a binary multiple) andreferenceUnit"byte".
See also SIPrefixes.
**General Types**
UnitConversion
**Features**
conversionFactor : Real {redefines conversionFactor}
AttributeconversionFactoris the Number value of the ratio between the quantity expressed in the owning
MeasurementUnit over the quantity expressed in thereferenceUnit.
prefix : UnitPrefix
Attributeprefixis a UnitPrefix that represents one of the named unit prefixes defined in [ISO/IEC 80000-1] as a
decimal or binary multiple or sub-multiple.
**Constraints**
None.
**9.8.3.2.5 CoordinateFrame
Element**
AttributeDefinition
**Description**
A CoordinateFrame is a VectorMeasurementReference with the specific purpose to quantify (i.e., coordinatize) a
vector space, and optionally locate and orient it with respect to another CoordinateFrame.
The optional attributetransformationenables specification of the location and orientation of this
CoordinateFrame as with respect to another (reference) coordinate frame. If thetargetof thetransformationis
this CoordinateFrame, thetransformationspecifies a CoordinateFrame that is nested inside the CoordinateFrame
that is thesourceof thetransformation. The primary use of this is to specify a chain of nested coordinate

**566 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


frames follows the composite structure of a physical architecture. Typically thesourceCoordinateFrame of the
transformationis the frame is the frame of the next higher containing Item or Part in a composite structure.
**General Types**
VectorMeasurementReference
**Features**
transformation : CoordinateTransformation [0..1]
**Constraints**
None.
**9.8.3.2.6 CoordinateFramePlacement
Element**
AttributeDefinition
**Description**
CoordinateFramePlacement is a CoordinateTransformation by placement of the target frame in the source frame.
Attributeoriginspecifies the location of the origin of the target frame through a vector in the source frame.
AttributebasisDirectionsspecifies the orientation of thetargetframe by specifying the directions of the
respective basis vectors of thetargetframe via direction vectors in thesourceframe. An empty sequence of
basisDirectionssignifies no change of orientation of thetargetframe with respect to thesourceframe.
**General Types**
CoordinateTransformation
**Features**
basisDirections : VectorQuantityValue [0..*] {ordered, nonunique}
origin : VectorQuantityValue
**Constraints**
validBasisDirectionsDimensions
basisDirections->forAll { in basisDirection : VectorQuantityValue;basisDirection.dimensions->equals(source.dimensions)

validBasisDirectionsSize
size(basisDirections) == 0 or size(basisDirections) == source.dimensions#(1)
validOriginDimensions
origin.dimensions == source.dimensions

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 567**


**9.8.3.2.7 CoordinateTransformation
Element**
AttributeDefinition
**Description**
A CoordinateTransformation is an AttributeDefinition that defines the transformation relationship between two
coordinate systems, that are represented by VectorMeasurementReferences, typically CoordinateFrames.
**General Types**
None.
**Features**
source : VectorMeasurementReference
target : VectorMeasurementReference
**Constraints**
[no name]
forall(bd: basisDirections | bd.mRef == source)
[no name]
size(basisDirections) == source.dimensions[1]
[no name]
origin.mRef == source
validSourceTargetDimensions
source.dimensions == target.dimensions
**9.8.3.2.8 countQuantities
Element**
AttributeUsage
**Description
General Types**
dimensionOneQuantities
CountValue
**Features**
None.

**568 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
None.
**9.8.3.2.9 CountValue
Element**
AttributeDefinition
**Description**
_CountValue_ is an explicit definition of a generic "count" quantity as a _DimensionOneValue_.
**General Types**
DimensionOneValue
**Features**
None.
**Constraints**
None.
**9.8.3.2.10 CyclicRatioScale
Element**
AttributeDefinition
**Description**
CyclicRatioScale is a MeasurementScale that represents a ratio scale with a periodic cycle.
Example 1: "cyclic degree" (to express planar angular measures) withmodulus = 360andunit'degree'.
Example 2: "hour of day" withmodulus = 24andunit'hour'.
**General Types**
MeasurementScale
**Features**
modulus : Number
Attributemodulusis a Number that defines the modulus, i.e. periodic cycle, of this CyclicRatioScale.
**Constraints**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 569**


**9.8.3.2.11 DefinitionalQuantityValue
Element**
AttributeDefinition
**Description**
Representation of a particular quantity value that is used in the definition of a _MeasurementReference_. Typically
such a particular value is defined by convention. It can be used to define a selected reference value, such as the
meaning of zero on a measurement scale or the origin of a top-level coordinate system.
**General Types**
None.
**Features**
definition : String
num : Number [1..*]
**Constraints**
None.
**9.8.3.2.12 DerivedUnit
Element**
AttributeDefinition
**Description**
DerivedUnit is a MeasurementUnit that represents a measurement unit that depends on one or more powers of other
measurement units.
**General Types**
MeasurementUnit
**Features**
None.
**Constraints**
None.
**9.8.3.2.13 dimensionOneQuantities
Element**
AttributeUsage

**570 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Description
General Types**
DimensionOneValue
scalarQuantities
**Features**
None.
**Constraints**
None.
**9.8.3.2.14 DimensionOneUnit
Element**
AttributeDefinition
**Description**
_DimensionOneUnit_ is an explicit definition of "unit of dimension one", also known as "dimensionless unit".
**General Types**
DerivedUnit
**Features**
unitPowerFactors : UnitPowerFactor
**Constraints**
None.
**9.8.3.2.15 DimensionOneValue
Element**
AttributeDefinition
**Description**
A _DimensionOneValue_ is a _ScalarQuantityValuewith aDimensionOneUnit._
**General Types**
ScalarQuantityValue
**Features**
mRef : DimensionOneUnit {redefines mRef}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 571**


**Constraints**
None.
**9.8.3.2.16 IntervalScale
Element**
AttributeDefinition
**Description**
IntervalScale is a MeasurementScale that represents a linear interval measurement scale, i.e. a scale on which only
intervals between two values are meaningful and not their ratios.
**Implementation note** : In order to enable quantity value conversion between an IntervalScale and another
measurement scale, the offset (sometimes also called zero shift) between the source and target scales must be
known. This offset can be indirectly defined through a ScaleValueMapping, seescaleValueMappingof
MeasurementScale. This will be aligned with, and possibly replaced by, a 1D coordinate transformation, so that
scalar and vector transformations are handled in the same way.
**General Types**
MeasurementScale
**Features**
isBound : Boolean {redefines isBound}
For an IntervalScaleisBoundis alwaystrue, since the scale must include a definition of what zero means.
**Constraints**
None.
**9.8.3.2.17 LogarithmicScale
Element**
AttributeDefinition
**Description**
LogarithmicScale is a MeasurementScale that represents a logarithmic measurement scale that is defined as follows.
The numeric value v of a ratio quantity expressed on a logarithmic scale equivalent with a value x of the same
quantity expressed on a ratio scale (i.e. only using a MeasurementUnit) is computed as follows:

_v_ = _f_ ⋅log _b_ ( _x_ / _xref_ ) _a_

where: _f_ is a multiplication factor,log _b_ is the log function for the given logarithm base _b_ , _x_ is the actual quantity, _xref_
is a reference quantity, _a_ is an exponent.
**General Types**

**572 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


MeasurementScale
**Features**
exponent : Number
Attributeexponentis the exponent _a_ in the logarithmic value expression.
factor : Number
Attributefactoris the multiplication factor _f_ in the logarithmic value expression.
logarithmBase : Number
AttributelogarithmicBaseis a Number that specifies the logarithmic base.
ThelogarithmicBaseis typically 10, 2 ore(for the natural logarithm).
referenceQuantity : ScalarQuantityValue [0..1]
AttributereferenceQuantityis the reference quantity value (denominator) _xref_ in the logarithmic value
expression.
**Constraints**
None.
**9.8.3.2.18 MeasurementScale
Element**
AttributeDefinition
**Description**
MeasurementScale is a MeasurementReference that represents a measurement scale.
Note: the majority of scalar quantities can be expressed by just using a MeasurementUnit directly as its
MeasurementReference. This implies expression of a ScalarQuantityValue on a ratio scale. However, for full
coverage of all quantity value expressions, additional explicit measurement scales with additional semantics are
needed, such as ordinal scale, interval scale, ratio scale with additional limit values, cyclic ratio scale and
logarithmic scale.
**General Types**
ScalarMeasurementReference
**Features**
quantityValueMapping : QuantityValueMapping [0..1]
AttributescaleValueMappingrepresents an optional ScaleValueMapping that specifies the relationship between
this MeasurementScale and another MeasurementReference in terms of equivalent QuantityValues.
unit : MeasurementUnit

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 573**


Attributeunitspecifies the MeasurementUnit that defines an interval of one on this MeasurementScale.
**Constraints**
None.
**9.8.3.2.19 MeasurementUnit
Element**
AttributeDefinition
**Description**
A MeasurementUnit is a ScalarMeasurementReference that represents a measurement unit. As defined in [VIM] a
measurement unit is a "real scalar quantity, defined and adopted by convention, with which any other quantity of the
same kind can be compared to express the ratio of the two quantities as a number".
Direct use of a MeasurementUnit as themRefattribute of a ScalarQuantityValue, establishes expressing the
ScalarQuantityValue on a ratio scale.
**General Types**
ScalarMeasurementReference
**Features**
isBound : Boolean {redefines isBound}
_isBound_ is always _false_ for a _MeasurementUnit_.
unitConversion : UnitConversion [0..1]
AttributeUsageunitConversionoptionally specifies a UnitConversion that specifies a linear conversion
relationship with respect to another MeasurementUnit. This can be used to support automated quantity value
conversion.
unitPowerFactors : UnitPowerFactor [1..*] {ordered}
AttributeUsageunitPowerFactorsspecifies a product of powers of base units, that define the quantity dimension
of this measurement unit.
**Constraints**
None.
**9.8.3.2.20 NullTransformation
Element**
AttributeDefinition
**Description**

**574 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


NullTransformation is an AffineTransformationMatrix3d that places the target CoordinateFrame at the same
position and orientation as the source CoordinateFrame. The interpretation of the matrix is as follows: - the rotation
matrix is diagonal, with 1 as values. - the translation vector is all zeros. I.e. the matrix has the following form: ( 1, 0,
0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 )
**General Types**
AffineTransformationMatrix3d
**Features**
None.
**Constraints**
None.
**9.8.3.2.21 nullTransformation
Element**
AttributeUsage
**Description
General Types**
NullTransformation
**Features**
None.
**Constraints**
None.
**9.8.3.2.22 one
Element**
AttributeUsage
**Description
General Types**
DimensionOneUnit
**Features**
None.
**Constraints**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 575**


None.
**9.8.3.2.23 OrdinalScale
Element**
AttributeDefinition
**Description**
An OrdinalScale is a MeasurementScale that represents an ordinal measurement scale, i.e. a scale on which only the
ordering of quantity values is meaningful, not the intervals between any pair of values and neither their ratio.
**Note** : In order to keep the library simple the associatedunitof an OrdinalScale shall be set to the unit of dimension
one, although a unit is meaningless for an OrdinalScale.
**Implementation note** : The unit attribute of MeasurementScale should be made optional, and its multiplicity be
redefined in the specialization of MeasurementScale.
**General Types**
MeasurementScale
**Features**
None.
**Constraints**
None.
**9.8.3.2.24 QuantityValueMapping
Element**
AttributeDefinition
**Description**
ScaleValueDefinition is an AttributeDefinition that represents the mapping of equivalent quantity values expressed
on two different measurement scales.
Example: The mapping between the equivalent thermodynamic temperature quantity values of 273.16 K on the
"kelvin" MeasurementUnit ratio scale and 0.01 degree Celsius on the "degree Celsius" IntervalScale would specify a
referenceScaleValuebeing the ScaleValueDefinition wherenumis 273.16 anddescriptionis "absolute
thermodynamic temperature of the triple point of water" of the "kelvin" ratio scale, as well as a
mappedScaleValuebeing the ScaleValueDefinition wherenumis 0.01 anddescriptionis "absolute
thermodynamic temperature of the triple point of water" of the "degree Celsius" IntervalScale. From this
ScaleValueMapping the offset (or zero shift) of 271.15 K between the two scales can be derived.
**General Types**
None.
**Features**

**576 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


mappedQuantityValue : DefinitionalQuantityValue
referenceQuantityValue : DefinitionalQuantityValue
**Constraints**
None.
**9.8.3.2.25 Rotation
Element**
AttributeDefinition
**Description**
Representation of a rotation about an axis over an angle AttributeaxisDirectionspecifies the direction of the
rotation axis. Attributeanglespecifies the angle of rotation, where a positive value implies right-handed rotation.
AttributeisIntrinsicasserts whether the intermediate coordinate frame moves with the
rotation or not, i.e. whether an instrinsic or extrinsic rotation is specified. See
https://en.wikipedia.org/wiki/Davenport_chained_rotations for details.
**General Types**
TranslationOrRotation
**Features**
angle : AngularMeasureValue
axisDirection : VectorQuantityValue
isIntrinsic : Boolean
Default is _true_.
**Constraints**
None.
**9.8.3.2.26 ScalarMeasurementReference
Element**
AttributeDefinition
**Description**
A ScalarMeasurementReference is a specialization of VectorMeasurementReference. It represents a single
measurement reference for a ScalarQuantityValue or for a component of a tensor or vector quantity. Itsorderis
zero. ScalarMeasurementReference is also a generalization of MeasurementUnit and MeasurementScale, which in
turn can be regarded as a the basis vector of for respectively a free or bound scalar quantity. It establishes how to
interpret thenumnumerical value of a ScalarQuantityValue or a component of a tensor or vector quantity value, and
establishes its actual quantity dimension.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 577**


**General Types**
VectorMeasurementReference
**Features**
dimensions : Positive [0..1] {redefines dimensions, ordered, nonunique}
isOrthogonal : Boolean {redefines isOrthogonal}
A _ScalarMeasurementReference_ always has _isOrthogonal = true_.
mRefs : ScalarMeasurementReference [1..*] {redefines mRefs, ordered}
negativeValueConnotation : String [0..1]
AttributenegativeValueConnotationoptionally specifies the connotation of negative quantity values for this
MeasurementReference.
An example is "east" for positive values on the MeasurementReference (CyclicRatioScale) for "longitude" and
"west" for negative values.
positiveValueConnotation : String [0..1]
AttributepositiveValueConnotationoptionally specifies the connotation of positive quantity values for this
MeasurementReference.
An example is "east" for positive values on the MeasurementReference (CyclicRatioScale) for "longitude" and
"west" for negative values.
quantityDimension : QuantityDimension
**Constraints**
None.
**9.8.3.2.27 SimpleUnit
Element**
AttributeDefinition
**Description**
SimpleUnit is a MeasurementUnit that does not depend on any other measurement unit.
Note: As a consequence theunitPowerFactorof a SimpleUnit references itself with anexponentof one.
**General Types**
MeasurementUnit
**Features**
unitPowerFactors : UnitPowerFactor {redefines unitPowerFactors}

**578 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
exponentIsOne
this.unitPowerFactor1.exponent == 1
ExponentIsOne
self.unitPowerFactor.exponent = 1
**9.8.3.2.28 SystemOfUnits
Element**
AttributeDefinition
**Description**
A _SystemOfUnits_ represents the essentials of [VIM] concept "system of units" (https://jcgm.bipm.org/vim/en/
1.13.html), defined as a "set of base units and derived units, together with their multiples and submultiples, defined
in accordance with given rules, for a given system of quantities". The _baseUnits_ are a particular selection of
measurement units for each of the base quantities of a _SystemOfQuantities_ , that form the basis on top of which
all other (derived) units are defined.
**General Types**
None.
**Features**
baseUnits : SimpleUnit [1..*] {ordered}
longName : String
systemOfQuantities : SystemOfQuantities
**Constraints**
None.
**9.8.3.2.29 TensorMeasurementReference
Element**
AttributeDefinition
**Description**
A TensorMeasurementReference is an abstract AttributeDefinition and a specialization of _Collections::Array_ , that
represents the [VIM] concept _measurement reference_ , but generalized for tensor, vector and scalar quantities.
[VIM] defines measurement reference as a measurement unit, a measurement procedure, a reference material, or a
combination of such. In this generalized definition, the measurement references for all components in all dimensions
of the QuantityValue are specified through themRefsattribute, which are all ScalarMeasurementReferences.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 579**


As an example a Cartesian 3-dimensional 3x3 moment of inertia tensor would have the following attributes:
attribute def Cartesian3dMomentOfInertiaMeasurementReference :> TensorMeasurementReference {attribute :>> dimensions = (3, 3);
attribute :>> isBound = false;attribute :>> mRefs: MomentOfInertiaUnit[9];
}
TheshortNameof a TensorMeasurementReference is the unique symbol by which the measurement reference is
known. Thenameof a TensorMeasurementReference is spelled-out human readable name of the measurement
reference.
**General Types**
Array
**Features**
definitionalQuantityValues : DefinitionalQuantityValue [0..*]
isBound : Boolean
Default is _false_.
mRefs : ScalarMeasurementReference [1..*] {redefines elements, ordered, nonunique}
order : Natural {redefines rank}
**Constraints**
None.
**9.8.3.2.30 Translation
Element**
AttributeDefinition
**Description**
Representation of a translation with respect to a coordinate frame AttributetranslationVectorspecifies the
displacement vector that constitutes the translation.
**General Types**
TranslationOrRotation
**Features**
translationVector : VectorQuantityValue
**Constraints**
None.

**580 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.8.3.2.31 TranslationOrRotation
Element**
AttributeDefinition
**Description**
TranslationOrRotation is an abstract union of Translation and Rotation.
**General Types**
None.
**Features**
None.
**Constraints**
None.
**9.8.3.2.32 TranslationRotationSequence
Element**
AttributeDefinition
**Description**
Coordinate frame transformation specified by a sequence of translations and/or rotations Note: This is a coordinate
transformation that is convenient for interpretation by humans. In particular a sequence of rotations about the
principal axes of a coordinate frame is much more easy understandable than a rotation about an arbitrary axis. Any
sequence can be reduced to a single combination of a translation and a rotation about a particular axis, but in general
the original sequence cannot be retrieved as there are infinitely many sequences representing the reduced
transformation.
**General Types**
CoordinateTransformation
List
**Features**
elements : TranslationOrRotation [1..*] {redefines elements, ordered, nonunique}
**Constraints**
None.
**9.8.3.2.33 UnitConversion
Element**
AttributeDefinition

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 581**


**Description**
A UnitConversion is an AttributeDefinition that represents a linear conversion relationship between one
measurement unit and another measurement unit, that acts as a reference.
**General Types**
None.
**Features**
conversionFactor : Real
AttributeconversionFactoris the Number value of the ratio between the quantity expressed in the owning
MeasurementUnit over the quantity expressed in thereferenceUnit.
isExact : Boolean
Default is _true_.
referenceUnit : MeasurementUnit
AttributereferenceUnitestablishes the reference MeasurementUnit with respect to which this UnitConversion is
defined.
**Constraints**
None.
**9.8.3.2.34 UnitPowerFactor
Element**
AttributeDefinition
**Description**
A UnitPowerFactor is an AttributeDefinition that represents a power factor of a MeasurementUnit and an exponent.
Note: A collection of UnitPowerFactors defines a unit power product.
**General Types**
None.
**Features**
exponent : Real
Attributeexponentis a Number that specifies the exponent of this UnitPowerFactor.
unit : MeasurementUnit
Attributeunitis the MeasurementUnit of this UnitPowerFactor.

**582 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
None.
**9.8.3.2.35 UnitPrefix
Element**
AttributeDefinition
**Description**
UnitPrefix is an AttributeDefinition that represents a named multiple or sub-multiple measurement unit prefix as
defined in ISO/IEC 80000-1.
**General Types**
None.
**Features**
conversionFactor : Real
AttributeconversionFactoris an Integer that specifies the value of multiple or sub-multiple of this UnitPrefix.
longName : String
symbol : String
Attributesymbolrepresents the short symbolic name of this UnitPrefix.
Examples are: "k" for "kilo", "m" for "milli", "MeBi" for "mega binary".
**Constraints**
None.
**9.8.3.2.36 VectorMeasurementReference
Element**
AttributeDefinition
**Description**
A VectorMeasurementReference is a specialization of TensorMeasurementReference for vector quantities that are
typed by a VectorQuantityValue. Itsorderis typically one, but can be zero in case of a specialization to
ScalarMeasurementReference. It implicitly defines a vector space of dimension N equal todimensions[1]. The N
basis unit vectors that span the vector space are defined by themRefswhich each are a
ScalarMeasurementReference, typically a MeasurementUnit or an IntervalScale.
It is possible to specify purely symbolic vector spaces, without committing to particular measurement units or scales
by setting the measurement references for all dimensions to unit one and quantity of dimension one, thereby
basically reverting to the representation of a purely mathematical vector space.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 583**


A VectorMeasurementReference can be used to represent a coordinate frame for a vector space. See the
CoordinateFrame specialization.
The attributeisOrthogonalindicates whether the inner products of the basis vectors of the vector space specified
by VectorMeasurementReference are orthogonal or not.
**General Types**
TensorMeasurementReference
**Features**
dimensions : Positive [0..1] {redefines dimensions}
isOrthogonal : Boolean
**Constraints**
placementCheck
size(placement) == 0 | placement.target == self
**9.8.3.2.37 VectorQuantityValue[1]
Element
Description
General Types**
None.
**Features**
None.
**Constraints**
None.

**9.8.4ISQ
9.8.4.1ISQ Overview**
The ISQ package specifies a complete set of predefined quantity types for the International System of Quantities
(ISQ). The ISQ itself is specified as aSystemOfQuantities. The quantity types are specified as specializations of
TensorQuantityValue, VectorQuantityValue, ScalarQuantityValue, that capture all quantities defined in ISO/IEC
80000 parts 3 to 13. It also defines all TensorMeasurementReference, VectorMeasurementReference and
ScalarMeasurementReference specializations needed to define concrete MeasurementReference AttributeDefinitions
needed to specify the actual measurement units and scales, coordinate frames and vector space products in other
library packages.
TheISQpackage comprises the following sub-packages via import:

- ISQBasefor ISO/IEC 80000 base quantities and general concepts

**584 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


- ISQSpaceTimefor [ISO 80000-3] "Space and Time"
- ISQMechanicsfor [ISO 80000-4] "Mechanics"
- ISQThermodynamicsfor [ISO 80000-5] "Thermodynamics"
- ISQElectromagnetismfor [IEC 80000-6] "Electromagnetism"
- ISQLightfor [ISO 80000-7] "Light"
- ISQAcousticsfor [ISO 80000-8] "Acoustics"
- ISQChemistryMolecularfor [ISO 80000-9] "Physical chemistry and molecular physics"
- ISQAtomicNuclearfor [ISO 80000-10] "Atomic and nuclear physics"
- ISQCharacteristicNumbersfor [ISO 80000-11] "Characteristic numbers"
- ISQCondensedMatterfor [ISO 80000-12] "Condensed matter physics"
- ISQInformationfor [IEC 80000-13] "Information science and technology"
Since packageISQimports all other sub-packages, the statement **import** ISQ::*;suffices to make the whole ISQ
available in a user model.
**9.8.4.2Elements
9.8.4.2.1 amountOfSubstance
Element**
AttributeUsage
**Description
General Types**
AmountOfSubstanceValue
scalarQuantities
**Features**
None.
**Constraints**
None.
**9.8.4.2.2 AmountOfSubstanceUnit
Element**
AttributeDefinition
**Description
General Types**
SimpleUnit
**Features**
None.
**Constraints**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 585**


None.
**9.8.4.2.3 AmountOfSubstanceValue
Element**
AttributeDefinition
**Description
General Types**
ScalarQuantityValue
**Features**
mRef : AmountOfSubstanceUnit {redefines mRef}
num : Real {redefines num}
**Constraints**
None.
**9.8.4.2.4 AngularMeasureValue
Element
Description
General Types**
None.
**Features**
None.
**Constraints**
None.
**9.8.4.2.5 Cartesian3dSpatialCoordinateSystem
Element**
AttributeDefinition
**Description
General Types**
VectorMeasurementReference
**Features**

**586 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


dimensions : Positive {redefines dimensions}
isBound : Boolean
isOrthogonal : Boolean {redefines isOrthogonal}
mRefs : LengthValue {redefines mRefs}
**Constraints**
None.
**9.8.4.2.6 duration
Element**
AttributeUsage
**Description
General Types**
scalarQuantities
DurationValue
**Features**
None.
**Constraints**
None.
**9.8.4.2.7 DurationUnit
Element**
AttributeDefinition
**Description
General Types**
SimpleUnit
**Features**
None.
**Constraints**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 587**


**9.8.4.2.8 DurationValue
Element**
AttributeDefinition
**Description
General Types**
ScalarQuantityValue
**Features**
mRef : DurationUnit {redefines mRef}
num : Real {redefines num}
**Constraints**
None.
**9.8.4.2.9 electricCurrent
Element**
AttributeUsage
**Description
General Types**
scalarQuantities
ElectricCurrentValue
**Features**
None.
**Constraints**
None.
**9.8.4.2.10 ElectricCurrentUnit
Element**
AttributeDefinition
**Description
General Types**
SimpleUnit

**588 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Features**
None.
**Constraints**
None.
**9.8.4.2.11 ElectricCurrentValue
Element**
AttributeDefinition
**Description
General Types**
ScalarQuantityValue
**Features**
mRef : ElectricCurrentUnit {redefines mRef}
num : Real {redefines num}
**Constraints**
None.
**9.8.4.2.12 length
Element**
AttributeUsage
**Description
General Types**
LengthValue
scalarQuantities
**Features**
None.
**Constraints**
None.
**9.8.4.2.13 LengthUnit
Element**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 589**


AttributeDefinition
**Description
General Types**
SimpleUnit
**Features**
None.
**Constraints**
None.
**9.8.4.2.14 LengthValue
Element**
AttributeDefinition
**Description
General Types**
ScalarQuantityValue
**Features**
mRef : LengthUnit {redefines mRef}
num : Real {redefines num}
**Constraints**
None.
**9.8.4.2.15 luminousIntensity
Element**
AttributeUsage
**Description
General Types**
scalarQuantities
LuminousIntensityValue
**Features**
None.

**590 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Constraints**
None.
**9.8.4.2.16 LuminousIntensityUnit
Element**
AttributeDefinition
**Description
General Types**
SimpleUnit
**Features**
None.
**Constraints**
None.
**9.8.4.2.17 LuminousIntensityValue
Element**
AttributeDefinition
**Description
General Types**
ScalarQuantityValue
**Features**
mRef : LuminousIntensityUnit {redefines mRef}
num : Real {redefines num}
**Constraints**
None.
**9.8.4.2.18 mass
Element**
AttributeUsage
**Description
General Types**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 591**


scalarQuantities
MassValue
**Features**
None.
**Constraints**
None.
**9.8.4.2.19 MassUnit
Element**
AttributeDefinition
**Description
General Types**
SimpleUnit
**Features**
None.
**Constraints**
None.
**9.8.4.2.20 MassValue
Element**
AttributeDefinition
**Description
General Types**
ScalarQuantityValue
**Features**
mRef : MassUnit {redefines mRef}
num : Real {redefines num}
**Constraints**
None.

**592 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.8.4.2.21 Position3dVector
Element**
AttributeDefinition
**Description
General Types**
ThreeVectorValue
**Features**
None.
**Constraints**
None.
**9.8.4.2.22 thermodynamicTemperature
Element**
AttributeUsage
**Description
General Types**
scalarQuantities
ThermodynamicTemperatureValue
**Features**
None.
**Constraints**
None.
**9.8.4.2.23 ThermodynamicTemperatureUnit
Element**
AttributeDefinition
**Description
General Types**
SimpleUnit
**Features**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 593**


None.
**Constraints**
None.
**9.8.4.2.24 ThermodynamicTemperatureValue
Element**
AttributeDefinition
**Description
General Types**
ScalarQuantityValue
**Features**
mRef : ThermodynamicTemperatureUnit {redefines mRef}
num : Real {redefines num}
**Constraints**
None.

**9.8.5SI Prefixes
9.8.5.1SI Prefixes Overview**
This package specifies the SI unit prefixes as defined in [ISO 80000-1], so that they can be used in automated
quantity value conversion.
ISO/IEC 80000-1 unit prefixes for decimal multiples and sub-multiples. See also https://en.wikipedia.org/wiki/
Unit_prefix.

```
Name Symbol Value
yocto y 10 -24
zepto z 10 -21
atto a 10 -18
femto f 10 -15
pico p 10 -12
nano n 10 -9
micro μ 10 -6
milli m 10 -3
```
**594 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Name Symbol Value
centi c 10 -2
deci d 10 -1
deca da 101
hecto h 102
kilo k 103
mega M 106
giga G 109
tera T 1012
peta P 1015
exa E 1018
zetta Z 1021
yotta Y 1024
```
ISO/IEC 80000-1 prefixes for binary multiples, i.e. multiples of 1024 (= 2^10 ). See also https://en.wikipedia.org/wiki/
Binary_prefix.

```
Name Symbol Value
kibi Ki 1024
mebi Mi 10242
gibi Gi 10243
tebi Ti 10244
pebi Pi 10245
exbi Ei 10246
zebi Zi 10247
yobi Yi 10248
```
**9.8.5.2Elements
9.8.6SI
9.8.6.1SI Overview**
This package specifies the measurement units as defined in ISO/IEC 80000 parts 3 to 13, the International System of
(Measurement) Units -- Système International d'Unités (SI).
The statement **import** SI::*;suffices to make all SI units available in a user model.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 595**


**9.8.6.2Elements
9.8.7US Customary Units
9.8.7.1US Customary Units Overview**
This package specifies all US Customary measurement units, with conversion factors to compatible SI units, as
defined in Appendix B "Conversion Factors" of [NIST SP-811].
The statement **import** USCustomaryUnits::*;suffices to make all US Customary measurement units available
in a user model.
**9.8.7.2Elements
9.8.8Time
9.8.8.1Time Overview**
This package specifies concepts to support time-related quantities and metrology, beyond the quantities duration and
time as defined in [ISO 80000-3].
Representations of the Gregorian calendar date and time of day as specified by the [ISO 8601-1] standard are
included. Also the Coordinated Universal Time (UTC) time scale is captured.
**9.8.8.2Elements
9.8.8.2.1 Clock
Element**
PartDefinition
**Description**
A _Clock_ provides a _currentTime_ as a TimeInstantValue that advances montonically over its lifetime.
**General Types**
Clock
**Features**
currentTime : TimeInstantValue {redefines currentTime}
**Constraints**
None.
**9.8.8.2.2 Date
Element**
AttributeDefinition
**Description**

**596 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


Generic representation of a time instant as a calendar date.
**General Types**
TimeInstantValue
**Features**
None.
**Constraints**
None.
**9.8.8.2.3 DateTime
Element**
AttributeDefinition
**Description**
Generic representation of a time instant as a calendar date and time of day.
**General Types**
TimeInstantValue
**Features**
None.
**Constraints**
None.
**9.8.8.2.4 DurationOf
Element**
CalculationDefinition
**Description**
_DurationOf_ returns the duration of a given _Occurrence_ relative to a given _Clock_ , which is equal to the _TimeOf_
the end snapshot of the _Occurrence_ minus the _TimeOf_ its start snapshot.
**General Types**
DurationOf
**Features**
clock : Clock {redefines clock}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 597**


Default is inherited _Occurrence::localClock_.
duration : DurationValue {redefines duration}
o : Occurrence {redefines o}
**Constraints**
None.
**9.8.8.2.5 Iso8601DateTime
Element**
AttributeDefinition
**Description**
Representation of an ISO 8601-1 date and time in extended string format.
**General Types**
UtcTimeInstantValue
**Features**
num : Real {redefines num}
val : Iso8601DateTimeEncoding
**Constraints**
None.
**9.8.8.2.6 Iso8601DateTimeEncoding
Element**
AttributeDefinition
**Description**
Extended string encoding of an ISO 8601-1 date and time.
**General Types**
String
**Features**
None.
**Constraints**
None.

**598 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**9.8.8.2.7 Iso8601DateTimeStructure
Element**
AttributeDefinition
**Description**
Representation of an ISO 8601 date and time with explicit date and time component attributes.
**General Types**
UtcTimeInstantValue
**Features**
day : Natural
hour : Natural
hourOffset : Integer
microsecond : Natural
minute : Natural
minuteOffset : Integer
month : Natural
num : Real {redefines num}
second : Natural
year : Integer
**Constraints**
None.
**9.8.8.2.8 timeInstant
Element**
AttributeUsage
**Description
General Types**
scalarQuantities
TimeInstantValue
**Features**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 599**


None.
**Constraints**
None.
**9.8.8.2.9 TimeInstantValue
Element**
AttributeDefinition
**Description**
Representation of a time instant quantity. Also known as instant (of time) or point in time.
**General Types**
ScalarQuantityValue
**Features**
mRef : TimeScale {redefines mRef}
num : Real {redefines num}
**Constraints**
None.
**9.8.8.2.10 TimeOf
Element**
CalculationDefinition
**Description**
_TimeOf_ returns a _TimeInstantValue_ for a given _Occurrence_ relative to a given _Clock_. This
_TimeInstantValue_ is the time of the start of the _Occurrence_ , which is considered to be synchronized with the
snapshot of the _Clock_ with a _currentTime_ equal to the returned _timeInstant_.
**General Types**
Evaluation
TimeOf
**Features**
clock : Clock {redefines clock}
Default is inherited _Occurrence::localClock_.
o : Occurrence {redefines o}

**600 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


timeInstant : TimeInstantValue {redefines timeInstant}
**Constraints**
startTimeConstraint
The _TimeOf_ an _Occurrence_ is equal to the time of its start snapshot.
timeContinuityConstraint
If one _Occurrence_ happens immediately before another, then the _TimeOf_ the end snapshot of the first Occurrence
equals the _TimeOf_ the second _Occurrence_.
timeOrderingConstraint
If one _Occurrence_ happens before another, then the _TimeOf_ the end snapshot of the first _Occurrence_ is no
greater than the _TimeOf_ the second _Occurrence_.
**9.8.8.2.11 TimeOfDay
Element**
AttributeDefinition
**Description**
Generic representation of a time instant as a time of day.
**General Types**
TimeInstantValue
**Features**
None.
**Constraints**
None.
**9.8.8.2.12 TimeScale
Element**
AttributeDefinition
**Description**
Generic time scale to express a time instant, including a textual definition of the meaning of zero time instant value.
Attribute _definitionalEpoch_ captures the specification of the time instant with value zero, also known as the
(reference) epoch.
**General Types**
IntervalScale

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 601**


**Features**
definitionalEpoch : DefinitionalQuantityValue
definitionalQuantityValues : DefinitionalQuantityValue {redefines definitionalQuantityValues}
unit : DurationUnit
**Constraints**
None.
**9.8.8.2.13 universalClock
Element**
PartUsage
**Description**
_universalClock_ is a single _Clock_ that can be used as a default universal time reference.
**General Types**
Clock
objects
Clock
universalClock
**Features**
None.
**Constraints**
None.
**9.8.8.2.14 UTC
Element**
AttributeDefinition
**Description**
Representation of the Coordinated Universal Time (UTC) time scale.
UTC is the primary time standard by which the world regulates clocks and time. It is within about 1 second of mean
solar time at 0° longitude and is not adjusted for daylight saving time. UTC is obtained from International Atomic
Time (TAI) by the insertion of leap seconds according to the advice of the International Earth Rotation and
Reference Systems Service (IERS) to ensure approximate agreement with the time derived from the rotation of the
Earth.
**General Types**

**602 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


TimeScale
**Features**
definitionalEpoch : DefinitionalQuantityValue {redefines definitionalEpoch}
unit : DurationUnit {redefines unit}
**Constraints**
None.
**9.8.8.2.15 utcTimeInstant
Element**
AttributeUsage
**Description
General Types**
timeInstant
UtcTimeInstantValue
**Features**
None.
**Constraints**
None.
**9.8.8.2.16 UtcTimeInstantValue
Element**
AttributeDefinition
**Description**
Representation of a time instant expressed on the Coordinated Universal Time (UTC) time scale.
**General Types**
DateTime
**Features**
mRef : UTC {redefines mRef}
**Constraints**
None.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 603**


**9.8.9Quantity Calculations
9.8.9.1Quantity Calculations Overview**
_QuantityCalculations_ is a package of calculation definitions for construction of and computation on
_ScalarQuantityValues_.
**Basics**
In order to enable the use of quantities in expressions this library package specifies the mathematical operators and
functions to support quantity arithmetic, and some convenience functions.
Any scalar quantity has a quantity dimension (see9.8.2.2.2) that specifies the product of powers of base quantities
of the applicable system of quantities. Rules for valid quantity dimensions of the variables in quantity expressions
are given below, after definition of the possible quantity expression operations. Such rules specify a necessary but
not a sufficient condition for valid quantity expressions. For example,EnergyValueandTorqueValuehave the
same quantity dimension (L^2 ·M·T-2in ISQ), but it is not valid to add anenergyquantity to atorquequantity.
Also eachScalarMeasurementReferencehas a quantity dimension, that can be used to check the validity of
using constructed quantity values in quantity expressions.
To enable enforcement of model-evaluable type checking on quantity expressions, all direct specializations of
(abstract)ScalarQuantityValue,VectorQuantityValueandTensorQuantityValuemust be disjoint.
AttributeDefinitions for quantity types at this first level of specialization are referred to as a _top level quantity types_.
Furthermore all lower level specializations of quantity AttributeDefinitions and AttributeUsages must be disjoint at
each sibling level. For example, akineticEnergyquantity cannot also be apotentialEnergyquantity. Both
however, are subsettings of genericenergy(defined byEnergyValue), that is a _top level quantity type_ , so they
may be added, subtracted, equated or compared.
**ScalarQuantityValue Construction**
Construction of a literal or variableScalarQuantityValueis done through the[operator, matched by a closing
]. The signature of the corresponding CalculationDefinition is:
**calc defin** num: Number[1];'[' **specializes** BaseFunctions::'[' {
**inreturn** mRef: ScalarMeasurementReference[1];quantity : ScalarQuantityValue[1];
}
Examples are:
**attributeattribute** mass : MassValue[1] = 24.5 [kg];x : Real[1] := 58.0;
**attributeattribute** speed : SpeedValue[1] := 3*x [m/s];:>> ISQ::width **default** 250.0 [mm];

The providedScalarMeasurementReferencemust have a quantity dimension that is the same as the quantity
dimension of the scalar quantity attribute being bound, assigned, defaulted or compared.
**ScalarQuantityValue Operations**
The following table enumerates the scalar quantity operations. In order to enable concise formulations the following
symbols for quantity AttributeUsages are defined:

- xis defined byScalarValues::Real, i.e.xis a real number

**604 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


- bis defined byScalarValues::Boolean, i.e.bis a boolean
- mris defined byScalarMeasurementReference, i.e.mris a scalar measurement reference, typically a
    measurement unit
- s1,s2,s3are defined byScalarQuantityValue, i.e. they are free or bound scalar quantities
- fs1,fs2,fs3are defined byScalarQuantityValue {:>> isBound = false}, i.e. they are free
    scalar quantities
- bs1,bs2,bs3are defined byScalarQuantityValue {:>> isBound = true}, i.e. they are bound
    scalar quantities
**Note.** For completeness also invalid operations are listed, for which the result is empty, and an implementation
should raise a warning or error.
**Note.** A mathematical number or a quantity defined byDimensionOneValuehas by definition quantity dimension
1, i.e. all exponents in the product of powers of the base quantities are zero.

```
Operator or
function expression Result Description
fs1+fs2 fs3 Addition of two free scalar quantities returns a free scalar quantity.
fs1+bs2 bs3 Addition of a free and a bound scalar quantity returns a bound scalar quantity.
fs1+fs2 bs3 Addition of a bound and a free scalar quantity returns a bound scalar quantity.
bs1+bs2 ERROR. Two bound scalar quantities cannot be added.
fs1-fs2 fs3 Subtraction of a free scalar quantity from a free scalar quantity returns a freescalar quantity.
fs1-bs2 bs3 Subtraction of a bound scalar quantity from a free scalar quantity returns abound scalar quantity.
bs1-fs2 bs3 Subtraction of a free scalar quantity from a bound scalar quantity returns abound scalar quantity.
bs1-bs2 fs3 Subtraction of a bound scalar quantity from a bound scalar quantity returns afree scalar quantity.
fs1*x or x*fs1 fs3 Multiplication of a free scalar quantity with a real returns a free scalar quantity.
bs1*x or x*bs1 ERROR. A bound scalar quantity cannot be an operand in a multiplication.
fs1*fs2 fs3 Multiplication of two free scalar quantities returns a free scalar quantity.
fs1*bs2 or
bs1*fs2 or
bs1*fs2
```
```
ERROR. A bound scalar quantity cannot be an operand in a multiplication.
fs1/fs2 fs3 Division of two free scalar quantities returns a free scalar quantity.
fs1/bs2 or bs1/
fs2 or bs1/fs2 ERROR. A bound scalar quantity cannot be an operand in a division.
fs1^x fs3 Exponentiation of a free scalar quantity returns a free scalar quantity.
bs1^x ERROR. A bound scalar quantity cannot be an operand in an exponentiation.
isZero(s1) b Function that asserts whether given scalar quantity is zero or not by returning aboolean.
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 605**


```
Operator or
function expression Result Description
isUnit(s1) b Function that asserts whether given scalar quantity is 1 or not by returning aboolean.
abs(s1) s3 Return scalar quantity of same type with absolute numerical value.
max(s1, s2) s3 Return maximum value scalar quantity of same type andvalue operand. See note 1. mRefof maximum
min(s1, s2) s3 Return minimum value scalar quantity of same type andvalue operand. See note 1. mRefof minimum
sqrt(s1) s3 Return square root value of given scalar quantity. Its quantity dimensionexponents are halved.
floor(s1) s3 Return floor value scalar quantity of same type andmRefas operand.
round(s1) s3 Return scalar quantity of same type androunded to nearest integer. mRefas operand, with numerical value
sum(s1[0..*]) s3 Return scalar quantity of same type andequal to cumulative sum of the elements in the operand.mRefas operand, with numerical value
product(s1[0..*]) s3 Return scalar quantity of same type andequal to cumulative product of the elements in the operand.mRefas operand, with numerical value
ConvertQuantity(s1,
mr) s3
```
```
Return scalar quantity of same type but with numerical value converted to
given target scalar measurement reference.
s1 == s2 b Return true if scalar quantity operands have equal (effective) value, else false.See Note 1.
s1 != s2 b Return true if scalar quantity operands do not have equal (effective) value, elsefalse. See Note 1.
s1 < s2 b Return true if (effective) value of first scalar quantity operand is less than valueof second operand, else false. See Note 1.
s1 <= s2 b Return true if (effective) value of first scalar quantity operand is less than orequal to value of second operand, else false. See Note 1.
s1 > s2 b Return true if (effective) value of first scalar quantity operand is greater thanvalue of second operand, else false. See Note 1.
s1 >= s2 b Return true if (effective) value of first scalar quantity operand is greater than ofequal to value of second operand, else false. See Note 1.
```
**Note 1.** Operands of min, max functions, and relational operators must have the same _top level quantity type_ and be
both either free or bound, but may have differentmRef.
The rules for valid quantity dimensions for the above operations are:

1. The operands and result of addition (+) and subtraction (-) operations must all have the same quantity
    dimension, and be of the same _top level quantity type_.
2. The operands of multiplication (*) operations may differ. The result must have a quantity dimension, in
    which the exponent for each base quantity is the sum of the exponents of the corresponding base quantity
    of each of the operands.

**606 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


3. The operands of division (/) operations may differ. The result must have a quantity dimension, in which
    the exponent for each base quantity is the difference of the exponent of the corresponding base quantity of
    the first operand minus the exponent of the second operand.
4. The first operand of the exponentiation operator (^) may have any quantity dimension. The result must
    have a quantity dimension, in which the exponent for each base quantity is the sum of the exponent of the
    corresponding base quantity of the first operand plus the value of the second operand (the exponent of the
    exponentiation operation).
**9.8.9.2Elements
9.8.10Vector Calculations
9.8.10.1Vector Calculations Overview**
_VectorCalculations_ is a package of calculation definitions for construction of and computation on
_VectorQuantityValues_.
**Basics**
In order to enable the use of quantities in expressions this library package specifies the mathematical operators and
functions to support vector quantity arithmetic, and some convenience functions. See9.8.9.1for a general
introduction.
**VectorQuantityValue Construction**
Construction of a literal or variableVectorQuantityValueis done through the[operator, matched by a closing
]. The signature of the corresponding CalculationDefinition is:
**calc defin** num : Number[1..n]; // a sequence of numbers that are the numerical values of the vector components'[' **specializes** BaseFunctions::'[' {
**inreturn** mRef : VectorMeasurementReference[1];quantity : VectorQuantityValue[1];

} **private attribute** n = mRef.flattenedSize;
Typically the measurement reference for a vector quantity is aCoordinateFrame, which is a specialization of
VectorMeasurementReference.
Examples are:
**attributedoc** /* The datum is the top level coordinate frame of the system-of-interest */datum : ISQ::CartesianSpatial3dCoordinateFrame {

} :>> mRefs = (mm, mm, mm); // the units on all 3 Cartesian axes are milllimetre
**attribute** posVec :>> cartesianPosition3dVector = (200.0, 350.0, 80.0) [datum];
The quantity dimensions of the components of aVectorQuantityValueare specified through themRefs(defined
byScalarMeasurementReference[1..*]) of themRef : VectorMeasurementReference[1]
AttributeUsage of the vector quantity. This allows to enforce the rules of scalar quantity arithmetic to the
components of vector quantities, when they are bound, assigned, defaulted, compared or the result of a vector
quantity expression evaluation.
**VectorQuantityValue Operations**
The following table enumerates the vector quantity operations. In order to enable concise formulations the following
symbols for quantity AttributeUsages are defined:

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 607**


- xis defined byScalarValues::Real, i.e.xis a real number
- bis defined byScalarValues::Boolean, i.e.bis a boolean
- fsis defined byScalarQuantityValue {:>> isBound = false}, i.e. it is a free scalar quantity
- bsis defined byScalarQuantityValue {:>> isBound = true}, i.e. it is a bound scalar quantity
- v1,v2,v3are defined byVectorQuantityValue, i.e. they are free or bound vector quantities
- fv1,fv2,fv3are defined byVectorQuantityValue {:>> isBound = false}, i.e. they are free
    vector quantities
- bv1,bv2,bv3are defined byVectorQuantityValue {:>> isBound = true}, i.e. they are bound
    vector quantities
- ctis defined byCoordinateTransformation, i.e. it is a coordinate transformation
**Note.** For completeness also invalid operations are listed, for which the result is empty, and an implementation
should raise a warning or error.

```
Operator or
function expression Result Description
fv1+fv2 fv3 Addition of two free vector quantities returns a free vector quantity.
fv1+bv2 bv3 Addition of a free and a bound vector quantity returns a bound vector quantity.
fv1+fv2 bv3 Addition of a bound and a free vector quantity returns a bound vector quantity.
bv1+bv2 ERROR. Two bound vector quantities cannot be added.
fv1-fv2 fv3 Subtraction of a free vector quantity from a free vector quantity returns a freevector quantity.
fv1-bv2 bv3 Subtraction of a bound vector quantity from a free vector quantity returns abound vector quantity.
bv1-fv2 bv3 Subtraction of a free vector quantity from a bound vector quantity returns abound vector quantity.
bv1-bv2 fv3 Subtraction of a bound vector quantity from a bound vector quantity returns afree vector quantity.
fv1*x or x*fv1 fv3 Multiplication of a free vector quantity and a real returns a free vector quantity.
bv1*x or x*bv1 ERROR. A bound vector quantity cannot be an operand in a multiplication.
fv1/x fv3 Division of a free vector quantity by a real returns a free vector quantity.
bv1/x ERROR. A bound vector quantity cannot be an operand in a division.
fs*fv1 or fv1*fs fv3 Multiplication of a free scalar quantity and a free vector quantity returns a freevector quantity.
fs*bv1 or bv1*fs ERROR. A bound vector quantity cannot be an operand in a multiplication.
fv1/fs fv3 Division of a free vector quantity by a free scalar quantity returns a free vectorquantity.
bv1/bs ERROR. A bound vector quantity or a bound scalar quantity cannot be anoperand in a division.
inner(v1, v2) x Inner product (aka dot product) of two vector quantities returns a real number.
outer(v1, v2) v3 Outer product (aka cross product) of two vector quantities returns a free vectorquantity if both operands are free vectors, else a bound vector quantity.
```
**608 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Operator or
function expression Result Description
norm(v1) fs Norm of a vector quantity returns a free scalar quantity representing themagnitude of the vector.
angle(v1, v2) fs Angle of two vector quantities returns a scalar quantity representing the angle(in radian) between the two vectors.
isZeroVectorQuantity(v1)b Function that asserts whether given vector quantity is a zero vector or not byreturning a boolean.
isUnitVectorQuantity(v1)b Function that asserts whether given vector quantity is a unit vector or not byreturning a boolean.
transform(ct,
v1) v3
```
```
Transform a vector quantity according to a coordinate transformation, which
returns a vector quantity transformed into the target coordinate frame of the
given coordinate transformation.
```
The rules for valid quantity dimensions for the above operations are:

1. The vector quantities for all operands and results must have compatiblemRef :
    VectorMeasurementReference[1]. Here compatible means that themRefof each vector quantity
    must have the same dimensions, and theirmRef.mRefsmust have the same quantity dimension for each
    vector component.
2. The operands and result of addition (+) and subtraction (-) operations must all have the samemRef :
    VectorMeasurementReference[1], and be of the same _top level quantity type_.
3. The operands of a multiplication (*) operation can be any free vector quantity and free scalar quantity.
    The result of a must have anmRef, in which for each vector component the exponent for each base
    quantity is the sum of the exponent of the corresponding base quantity of the component of the vector
    operand plus the exponent of the scalar operand.
4. The operands of adivision (/) operation can be any free vector quantity and free scalar quantity. The
    result of a must have anmRef, in which for each vector component the exponent for each base quantity is
    the difference of the exponent of the corresponding base quantity of the component of the vector operand
    minus the exponent of the scalar operand.
5. The operands of the inner product must all have the samemRef, i.e. coordinate frame, and therefore
    component-wise the same quantity dimensions.
6. The operands and the result of the outer product must all have the samemRef, i.e. coordinate frame, and
    therefore component-wise the same quantity dimensions.
7. The operand of thenorm,isZeroVectorQuantity,isUnitVectorQuantitycan be any vector
    quantity. The result of thenormfunction is a free scalar quantity that has anmRef compatible with the
    magnitude of the vector quantity operand.
8. For thetransformfunction, themRefof the vector quantity operand must be thesourcecoordinate
    frame of the coordinate transformation operand. The result vector quantity must have anmRefthat is equal
    to thetargetcoordinate frame of the coordinate transformation operand. This specifies all involved
    quantity dimensions.
**9.8.10.2Elements
9.8.11Tensor Calculations
9.8.11.1Tensor Calculations Overview**
_TensorCalculations_ is a package of calculation definitions for construction of and computation on
_TensorQuantityValues_.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 609**


**Basics**
In order to enable the use of quantities in expressions this library package specifies the mathematical operators and
functions to support tensor quantity arithmetic, and some convenience functions. See9.8.9.1for a general
introduction.
**TensorQuantityValue Construction**
Construction of a literal or variableTensorQuantityValueis done through the[operator, matched by a closing
]. The signature of the corresponding CalculationDefinition is:
**calc defin** num : Number[1..n] ordered; // a sequence of numbers that are the numerical values of the tensor components'[' **specializes** BaseFunctions::'[' {
**inreturn** mRef : TensorMeasurementReference[1];quantity : TensorQuantityValue[1];

} **private attribute** n = mRef.flattenedSize;
The quantity dimensions of the components of aTensorQuantityValueare specified through themRefs(defined
byScalarMeasurementReference[1..*]) of themRef : TensorMeasurementReference[1]
AttributeUsage of the tensor quantity. This allows to enforce the rules of scalar quantity arithmetic to the
components of tensor quantities, when they are bound, assigned, defaulted, compared or the result of a tensor
quantity expression evaluation.
**TensorQuantityValue Operations**
The following table enumerates the tensor quantity operations. In order to enable concise formulations the following
symbols for AttributeUsages are defined:

- xis defined byScalarValues::Real, i.e.xis a real number
- bis defined byScalarValues::Boolean, i.e.bis a boolean
- v1,v2,v3are defined byVectorQuantityValue, i.e. they are vector quantities
- T1,T2,T3are defined byTensorQuantityValue, i.e. they are tensor quantities
- ctis defined byCoordinateTransformation, i.e. it is a coordinate transformation
**Operator or
function expression Result Description**
T1+T2 T3 Addition of two tensor quantities returns a tensor quantity, with allcorresponding component values added.

```
T1-T2 T3
```
```
Subtraction of a tensor quantity from another tensor quantity returns a tensor
quantity, with all corresponding component values of the second operand
subtracted from those of the first operand.
T1*x or x*T1 T3 Multiplication of a tensor quantity and a real number returns a tensor quantity,with all component values mutltiplied byx.
T1/x T3 Division of a tensor quantity with a real number returns a tensor quantity, withall component values divided byx.
```
```
T1*v1 or v1*T1 v3 Multiplication of a tensor quantity and a vector quantity returns a vectorquantity. The tensor and vector must have compatible (covariant and
contravariant) dimensions.
```
**610 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
Operator or
function expression Result Description
isZeroTensorQuantity(T1)b Function that asserts whether given tensor quantity is a zero tensor or not byreturning a boolean.
isUnitTensorQuantity(T1)b Function that asserts whether given tensor quantity is a unit tensor or not byreturning a boolean.
transform(ct,
T1) T3
```
Transform a tensor quantity according to a coordinate transformation, which
returns a tensor quantity transformed into the target coordinate frame of the
given coordinate transformation.
**9.8.11.2Elements
9.8.12Measurement Ref Calculations
9.8.12.1Measurement Ref Calculations Overview**
_MeasurementRefCalculations_ is a package of calculation definitions for computation on
_MeasurementReferences,_ in particular _MeasurementUnits_ and _CoordinateFrames_.
Similar to computations with ScalarQuantityValues and VectorQuantityValues in quantity expressions, it is also
possible to create measurement reference expressions to compute with MeasurementUnits and CoordinateFrames.
**MeasurementUnit and CoordinateFrame Operations**
The following table enumerates the measurement unit and coordinate frame operations. In order to enable concise
formulations the following symbols for AttributeUsages are defined:

- xis defined byScalarValues::Real, i.e.xis a real number
- u1,u2,u3are defined byMeasurementUnit, i.e. they are measurement units
- fcf1, fcf2are defined byCoordinateFrame{:>> isBound = false;}, i.e. they are free coordinate
    frames
- bcf1, bcf2are defined byCoordinateFrame{:>> isBound = true;}, i.e. they are bound
    coordinate frames
**Operator or
function expression Result Description**

```
u1*u2 u3
```
```
Multiplication of two measurement units returns a (derived) measurement unit,
with quantity dimension exponents changed such that the exponent of the first
operand is added to that of the second, for each base quantity. Equal terms in
nominator and denominator cancel out.
```
```
u1/u2 u3
```
```
Division of two measurement units returns a (derived) measurement unit, with
quantity dimension exponents changed such that the exponent of the second
operand is subtracted from that of the second, for each base quantity. Equal
terms in nominator and denominator cancel out.
u1^x u3 Exponentiation of a measurement unit returns a (derived) measurement unit.
cf1*u1 cf2
```
```
Return a coordinate frame (withisBounddefault false), that has its quantity
dimension exponents for all componentmRefschanged by adding the
corresponding base quantity exponent of the measurement unit.
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 611**


```
Operator or
function expression Result Description
bf1*u1 cf2
```
```
Return a coordinate frame (withisBound default true), that has its
quantity dimension exponents for all componentmRefschanged by adding the
corresponding base quantity exponent of the measurement unit.
cf1/u1 cf2
```
```
Return a coordinate frame (withisBound default false), that has its
quantity dimension exponents for all componentmRefschanged by subtracting
the corresponding base quantity exponent of the measurement unit.
bf1/u1 cf2
```
```
Return a coordinate frame (withisBound default true), that has its
quantity dimension exponents for all componentmRefschanged by subtracting
the corresponding base quantity exponent of the measurement unit.
```
Examples of measurement unit expressions are:
**attributeattribute** <'m/s'> 'metre per second' : SpeedUnit = m/s;<'N⋅m'> 'newton metre' : EnergyUnit = N*m;

Examples of coordinate frame and measurement unit expressions are:
**attributeattribute** spatialCF: CartesianSpatial3dCoordinateFrame[1] { :>> mRefs = (m, m, m); }velocityCF: CartesianVelocity3dCoordinateFrame[1] = spatialCF/s { :>> isBound = false; } ;
**attribute** accelarationCF: CartesianAcceleration3dCoordinateFrame[1] = velocityCF/s;
**9.8.12.2Elements**

**612 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


## A Annex: Example Model

(Informative)

**A.1Introduction**
The example presented in this Annex is intended to illustrate how SysML can be used to model a system.The
example is a simple vehicle model thathighlights selected language features. Both the graphical and corresponding
textual notation are presented.

**A.2Model Organization**
The _SimpleVehicleModel_ is organized into a hierarchy of packages, where some packages contain nested
packages. The _Definitions_ package contains nested packages for part definitions, attribute definitions, port
definitions, item definitions, action definitions, requirements definitions, and other kinds of definition elements. The
_VehicleConfigurations_ package contains two design configurations that are modeled as usages of the definition
elements from the _Definitions_ package. Each vehicle configuration contains packages thatcontain its parts,
actions, and requirements. This model includes separate packages for
_VehicleAnalysis_ , _VehicleVerification_ , _Individuals_ ,and _View_Viewpoints._ The
_VehicleAnalysis_ package contains analysis cases to analyze the system,and the _VehicleVerification_
package contains verification cases and the verification system to verify the system.The _Views_Viewpoints_
packagespecifiesuser-defined views. Additionalpackages that are not shown include a _MissionContext_ package
that contains use cases for howthe vehicle is used in a particular context, and a _VehicleFamily_ package that
containsamodel with variation points from which specific vehicle configurations can be derived. The packagefor
the International System of Quantities ( _ISQ_ )is imported into this model from the SysML model library so its
content can be used to specify standard quantities and units.Imported packages can beshown with a dashed outline
package symbol as shown in the figure or with an import relationship between the importing package andthe
imported package.

```
VehicleVerification
```
```
VehicleAnalyiss
ActionTree
```
```
Requirements
```
```
PartsTree
```
```
VehicleConfiguration_b
```
```
VehicleConfiguration_a
```
```
VehicleConfigurations Individuals
```
```
View_Viewpoints
```
```
ItemDefinitions
```
```
ActionDefinitions
```
```
PartDefinitions
```
```
RequirementDefinitions
```
```
PortDefinitions InterfaceDefinitions
```
```
AttributeDefinitions
```
```
Definitions
```
```
ISQ
```
```
SimpleVehicleModel_
```
**Figure 55. Model Organization for SimpleVehicleModel**
package SimpleVehicleModel{import ISQ::*;
package Definitions { ... }

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 613**


```
package VehicleConfigurations{package VehicleConfiguration_a{ ... }
package VehicleConfiguration_b{package PartsTree{ ... }
package ActionTree{ ... }package Requirements{ ... }
} }
package VehicleAnalysis{ ... }package VehicleVerification{ ... }
package Individuals{ ... }package Views_Viewpoints{ ... }
```
} ...
The packages of a system model are often organized and managed to enable team members to work collaboratively
on different aspects of the model, where each package contains cohesive content that can be worked on
independently. The _VehicleConfigurations_ package would typically import packages for each major system
element (e.g., subsystem) to aid in collaborative development, although this was not done for this simple example.

**A.3Definitions**
The _Definitions_ package contains a nested _PartDefinitions_ package that contains definitions for the parts
that are used to represent the vehicle configurations. This includes the part definition for a _Vehicle_ , whose features
include attributes, ports, actions, and states.

**614 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Figure 56. Part Definition for Vehicle**
part def Vehicle {attribute mass:>ISQ::mass;
attribute dryMass:>ISQ::mass;attribute cargoMass:>ISQ::mass;
attribute position:>ISQ::length;attribute velocity:>ISQ::speed;
attribute acceleration:>ISQ::acceleration;attribute electricalPower:>ISQ::power;
attribute Tmax:>ISQ::temperature;attribute maintenanceTime: Time::DateTime;
attribute brakePedalDepressed: Boolean;port ignitionCmdPort: IgnitionCmdPort;
port pwrCmdPort: PwrCmdPort;port vehicleToRoadPort: VehicleToRoadPort;
perform action providePower;perform action provideBraking;
perform action controlDirection;perform action performSelfTest;
perform action applyParkingBrake;perform action senseTemperature;

} exhibit state vehicleStates;
The attributes called _mass_ , _dryMass_ , and _cargoMass_ are each a kind of the base _mass_ attribute imported from the
standard SysML _ISQ_ library model (see9.8.4). Values of the attribute quantities contained in this library can then be

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 615**


assigned standard units from the _SI_ (see9.8.6) or _USCustomaryUnits_ (see9.8.7) library models. For example, the
value of the _mass_ of the _Vehicle_ can be assigned the unit of kilogram ( _SI::kg_ ). The _Vehicle_ also contains other
quantity attributes such as its _position_ and _velocity_.
The _Vehicle_ contains three ports called _ignitionCmdPort_ , _pwrCmdPort_ and _vehicleToRoadPort_ , which are
interaction points that provide ignition and fuel commands to the vehicle, and transfer vehicle torque to the road.
The _Vehicle_ performs the action _providePower_ to accelerate the vehicle, and other actions that include
_performSelfTest_ and _applyParkingBrake_. In addition, the _Vehicle_ exhibits its _vehicleStates_.
The _Vehicle_ represents a class of individual vehicles which is defined by its attributes, ports, actions, and states.
Other part definitions can be specified in a similar way to build a reusable library of part definitions.
The part definition for _FuelTank_ contains an attribute called _mass_ andan attribute called _fuelKind_. The attribute
_fuelKind_ is defined by the enumeration _FuelKind_ thatcontainsliteral values for different kinds of fuel such as _gas_
and _diesel_. The _FuelTank_ also contains an item called _fuel._ An itemis often used to represent something that flows
through a system or is stored by a system. The fuel is not considered to be part of the _FuelTank_ , so _fuel_ is
modeled as a referential feature (shown graphically using the white diamond symbol instead of the black diamond).

```
«part def»
FuelTank
fuelKind: FuelKind
fuelMassMax:> ISQBase::mass
mass:> ISQBase::mass
```
```
attributes
```
```
fuelInPort: ~FuelPort ports
fuelOutPort: FuelPort
```
```
«item»
fuel: Fuel
fuelMass
:>>Fuel::fuelMass
```
```
attributes
```
```
«assert constraint»
fuelConstraint
{ fuel.fuelMass<=fuelMassMax }
```
```
operator expressions
```
(^1) *
**Figure 57. Part Definition for FuelTank Referencing Fuel it Stores**
part def FuelTank{attribute mass :> ISQ::mass;
attribute fuelKind:FuelKind;ref item fuel:Fuel{
} attribute redefines fuelMass;
attribute fuelMassMax:>ISQ::mass;assert constraint fuelConstraint {fuel.fuelMass<=fuelMassMax}
port fuelOutPort:FuelPort;port fuelInPort:~FuelPort;
}
**616 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


The _fuel_ contains an attribute called _fuelMass_. The _FuelTank_ contains an attribute called _fuelMassMax_ , which
represents the maximum amount of fuel that a _FuelTank_ can store. A constraint is imposed that the _fuelMass_ must
be less than or equal to the _fuelMassMax_. The constraint is asserted to be true because, if the _fuelMass_ exceeds
the _fuelMassMax_ , the model would be inconsistentand the model validation should generate an error. If assert is
not used with the constraint, the model could evaluate the constraint to be false, and the model validation should not
generate an error.
The _FuelTank_ also contains a _fuelInPort_ and a _fuelOutPort_. The _fuelOutPort_ is defined by _FuelPort
that_ contains a directed feature to representthe fuel flowing out of this port. The _fuelInPort_ is defined by a port
definition that is the conjugate of the _FuelPort_. The conjugate is notated with a tilda (~) in front of the port
definition name_._ The conjugatereverses the direction of eachdirected feature of the port that it conjugates, which in
this case reverses the direction of the fuel to flow in to the port instead of out from the port_._ Note that the directed
features are not shown in the figure but are specified as part of the definition of _FuelPort_.
The part definition for _Axle_ contains the attribute _mass_. _FrontAxle_ is a specialization of _Axle_ that inherits its
_mass_ attribute and contains an additional attribute called _steeringAngle_.

```
«part def»
Axle
mass:> ISQBase::mass
```
```
attributes
```
```
«part def»
FrontAxle
steeringAngle:>
ISQSpaceTime::angularMeasure
```
```
attributes
```
**Figure 58. Axle and its Subclass FrontAxle**
part def Axle{attribute mass:>ISQ::mass;
}part def FrontAxle:>Axle{

} attribute steeringAngle:>ISQ::planeAngle;
The _Definitions_ package also contains several other kinds of definition elements. The port definition _FuelPort_
contains an item called _fuel_ that can flow out ofthe port. The _fuel_ is defined by the item definition _Fuel
that_ contains a _mass_ attribute. The interface definition _FuelInterface_ is used to connect a _fuelOutPort_ to a
_fuelInPort_. The definition also specifies that _Fuel_ flows across this interface.The item definition _FuelCmd_
containsan attribute called _throttleLevel_ that is definedby a _Real_. The action definition _ProvidePower_
contains an input item _fuelCmd_ that is defined by _FuelCmd._ It also contains an output attribute called
_wheelToRoadTorque_ that has multiplicity of 2, and is defined by the attribute definition _TorqueValue_.

```
ProvidePower «action def»
inout fuelCmd: FuelCmdwheelToRoadTorque: TorqueValue parameters
```
```
«item def» FuelCmd
throttleLevel: Real attributes
```
```
«port def» FuelPort
out parameters fuel: Fuel
```
```
«item def» Fuel
fuelMass:> ISQBase::mass attributes
```
```
«interface def» FuelInterface
of : Fuel from fuelOutPort.fuel tofuelInPort.fuel flows
fuelInPort: ~FuelPortfuelOutPort: FuelPort ports
```
```
«enum def»FuelKind
gasdiesel enums
```
**Figure 59. Example Definition Elements**
action def ProvidePower {in item fuelCmd:FuelCmd;

} out wheelToRoadTorque:TorqueValue[2];
item def FuelCmd{attribute throttleLevel:Real;

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 617**


}
port def FuelPort{out item fuel:Fuel;
}
item def Fuel{attribute fuelMass:>ISQ::mass;
}
interface def FuelInterface{end fuelOutPort:FuelPort;
end fuelInPort:~FuelPort;flow of Fuel from fuelOutPort.fuel to fuelInPort.fuel;
}
enum def FuelKind {gas; diesel;}

**A.4Parts**
The _VehicleConfigurations_ package contains two usages of the _Vehicle_ part definition called _vehicle_a_
and _vehicle_b_. The _vehicle_b_ configuration is shown below. The part _vehicle_b_ inherits features from itspart
definition _Vehicle_. It can then redefine or subset its inherited features and add new features. As an example,
_vehicle_b_ redefines the _mass_ attributeit inheritedfrom _Vehicle_ and further constrainsit's mass to be the sum of
its _dryMass_ , _cargoMass_ , and _fuelMass_. It redefines other features including other attributes, ports, actions, and
states in a similar manner. Itsactions are redefined to perform actions that are contained inthe _ActionTree_. For
example, the inherited action from _Vehicle_ to _providePower_ is redefined by _ActionTree::providePower_. As
described inA.6, the _providePower_ contained in _ActionTree_ is decomposed into other actions.

**618 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
vehicle_b: Vehicle «part»
cargoMass :>>Vehicle::cargoMass default 0 [kg]
avgFuelEconomy:>AttributeDefinitions::distancePerVolume
dryMass=sum(partMasses) :>>Vehicle::dryMass
mass=dryMass+cargoMass+fuelTank.fuel.fuelMass :>>Vehicle::mass
partMasses
```
```
attributes
```
```
vehicleStates :>>Vehicle::vehicleStatesexhibit states
fuelTank: FuelTank parts
providePower:> ActionTree::providePower :>>Vehicle::providePower
performSelfTest:>ActionTree::performSelfTest
:>>Vehicle::performSelfTest applyParkingBrake:>
ActionTree::applyParkingBrake :>>Vehicle::applyParkingBrake
senseTemperature:>ActionTree::senseTemperature
:>>Vehicle::senseTemperature
```
```
perform actions
```
```
fuelCmdPort: FuelCmdPort :>>Vehicle::pwrCmdPort
setSpeedPort: ~SetSpeedPortvehicleToRoadPort
:>>Vehicle::vehicleToRoadPort
```
```
ports
```
**Figure 60. Part Usage for vehicle_b**
part vehicle_b:Vehicle{attribute mass redefines mass=

```
attribute dryMass redefines dryMass=sum(partMasses);dryMass+cargoMass+fuelTank.fuel.fuelMass;
attribute redefines cargoMass default 0 [kg];attribute partMasses=(...); // collection of part.mass
attribute fuelEconomy :> distancePerVolume;port fuelCmdPort:FuelCmdPort redefines pwrCmdPort{
port setSpeedPort:~SetSpeedPort;in item fuelCmd redefines pwrCmd;
port vehicleToRoadPort redefines vehicleToRoadPort{port wheelToRoadPort1;WheelToRoadPort;
} port wheelToRoadPort2:WheelOtRoadPort;
perform ActionTree::providePower redefines providePower;perform ActionTree::performSelfTest redefines performSelfTest;
perform ActionTree::applyParkingBrake redefines applyParkingBrake;perform ActionTree::senseTemperature redefines senseTemperature;
exhibit States::vehicleStates redefines vehicleStates;}
part fuelTank:FuelTank{...
}
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 619**


} ...
A _parts tree_ is a representation of the decomposition of a part into its constituent parts. Different part usages with
the same definition, such as _vehicle_a_ and _vehicle_b_ , can have different decompositions. As shown below,
_vehicle_b_ is composed of several parts, including an _engine_ , _starterMotor_ , _transmission_ , _driveshaft_ ,
_frontAxleAssembly_ , _rearAxleAssembly_ , _fuelTank_ , and _vehicleSoftware_. The _frontAxleAssembly_
contains a _frontAxle_ and two _frontWheels_ as designated by the multiplicity[2]. The _rearAxleAssembly_
contains a _rearAxle_ , _differential_ , _rearWheel1_ , and _rearWheel2._ Note that some of the definition elements
are elided from the figure but are visible in the textual notation. As always, views of the model only show selected
aspects of the model.

**Figure 61. Parts Tree for vehicle_b**
part vehicle_b:Vehicle {...
part starterMotor:StarterMotor;part fuelTank:FuelTank;
part engine:Engine;part transmission:Transmission;
part driveshaft:Driveshaft;part rearAxleAssembly{
part differential:Differential;part rearAxle:Axle;
part rearWheel1:Wheel;part rearWheel2:Wheel;
}part frontAxleAssembly{
part frontAxle:FrontAxle;part frontWheels:Wheel[2];
}part vehicleSoftware:VehicleSoftware;
}
The _VehicleConfigurations_ package also contains the _engine4Cyl_ variant that subsets _engine_. In general, an
_engine_ can contain 4 to 8 _cylinders_. The _engine4Cyl_ variant redefinesthe set of 4..8 cylinders to be exactly
4 _cylinders_ , and then subsets the set of4 cylinders to create _cylinder1_ , _cylinder2_ , _cylinder3_ , and
_cylinder4_. (See also the example of variability modeling inA.12.)

**620 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
engine4Cyl :> Engine4Cyl_Variant::engine «part»
```
```
cylinders «part»
```
```
cylinder1 :> engine4Cyl::cylinders «part» cylinder2 :> engine4Cyl::cylinders «part» cylinder3 :> engine4Cyl::cylinders «part» cylinder4 :> engine4Cyl::cylinders «part»
```
```
engine: Engine «part»
```
```
cylinders: Cylinder «part»
```
```
4
```
```
1 1 1 1
```
```
4..8
```
**Figure 62. Variant engine4Cyl**
part engine:Engine{part cylinders:Cylinder [4..8] ordered;
}
part engine4Cyl:>engine{part redefines cylinders[4];
part cylinder1[1] subsets cylinders;part cylinder2[1] subsets cylinders;
part cylinder3[1] subsets cylinders;part cylinder4[1] subsets cylinders;
}

**A.5Parts Interconnection**
The various constituent parts of _vehicle_b_ are interconnected via their ports. The _fuelCmdPort_ on _vehicle_b_ is
delegated to the _fuelCmdPort_ on the engine using a binding connection. The _controlPort_ on the
_vehicleController_ is connected to the _engineControlPort_ on the engine. The _controlPort_ is defined by
_ControlPort_ and the _engineControlPort_ is defined by a port definition that is the conjugate of the
_ControlPort_ (that is, the directions of all its directed features are reversed relative to those of the original port
definition).
The _drivePwrPort_ on the engine is connected to the _clutchPort_ on the transmission by an interface. The
interface is defined by an interface definition whose port at one end of the interface is defined as _DrivePwrPort_
and whose port at the other end of the interface is defined as the conjugate of the _DrivePwrPort_. The
_DrivePwrPort_ contains the directed feature _out engineTorque:Torque_. The conjugate of the
_DrivePwrPort_ contains the directed feature _in engineTorque:Torque_.
The _fuelOutPort_ on the _fuelTank_ isconnected to the _fuelInPort_ on the _Engine_ by an interface.
Thisinterface is defined by the interface definition _FuelInterface_ which contains a flow of _Fuel_. This flow can
be shown as a solid arrowhead on the connection between the ports but is not shown in this particular view.
Connections can be made directly between nested parts without having to establish a connection between the
corresponding composite parts. For example, the port on the _driveShaft_ can connect directly to a port on the
_differential_ without having to connect first to the _rearAxleAssembly_ that composes the _differential_.
Ports can also be nested within a composite port as shown by the _vehicleToRoadPort_ , which contains a nested
port for each rear wheel.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 621**


**Figure 63. Parts Interconnection for vehicle_b**
part vehicle_b : Vehicle{port fuelCmdPort redefines pwrCmdPort;
port vehicleToRoadPort redefines vehicleToRoadPort{port wheelToRoadPort1;
} port wheelToRoadPort2;
part fuelTank:FuelTank{port fuelOutPort;
}part rearAxleAssembly{
port shaftPort_d;part rearWheel1:Wheel{
port :>>wheelToRoadPort;port :>>wheelToAxlePort;
}part rearWheel2:Wheel{
port :>>wheelToRoadPort;port :>>wheelToAxlePort;
}part differential:Differential{
port shaftPort_d;port leftDiffPort;
} port rightDiffPort;
part rearAxle{part leftHalfAxle:HalfAxle{
port leftAxleToDiffPort;port leftAxleToWheelPort;
}part rightHalfAxle:HalfAxle{
port rightAxleToDiffPort;

**622 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
} port rightAxleToWheelPort;
}
bind shaftPort_d = differential.shaftPort_d;connect differential.leftDiffPort
connect differential.rightDiffPortto rearAxle.leftHalfAxle.leftAxleToDiffPort;
connect rearAxle.leftHalfAxle.leftAxleToWheelPortto rearAxle.rightHalfAxle.rightAxleToDiffPort;
connect rearAxle.rightHalfAxle.rightAxleToWheelPortto rearWheel1.wheelToAxlePort;
} to rearWheel2.wheelToAxlePort;
part starterMotor:StarterMotor{port ignitionCmdPort;
} port gearPort;
part engine:Engine{port fuelCmdPort;
port drivePwrPort:DrivePwrPort;port fuelInPort;
port flyWheelPort;port controlPort;
}part transmission:Transmission{
port clutchPort:~DrivePwrPort;port shaftPort_a;
}part driveshaft:Driveshaft{
port shaftPort_b;port shaftPort_c;
}part vehicleSoftware:VehicleSoftware{
part vehicleController {port controlPort;
} }
//connectionsbind engine.fuelCmdPort = fuelCmdPort;
bind starterMotor.ignitionCmdPort = ignitionCmdPort;
interface engineToTransmissionInterface:EngineToTransmissionInterfaceconnect engine.drivePwrPort to transmission.clutchPort;
interface fuelInterface:FuelInterfaceconnect fuelTank.fuelOutPort to engine.fuelInPort;
connect vehicleSoftware.vehicleController.controlPortto engine.controlPort;
connect starterMotor.gearPortto engine.flyWheelPort;
connect transmission.shaftPort_ato driveshaft.shaftPort_b;
connect driveshaft.shaftPort_cto rearAxleAssembly.shaftPort_d;
bind rearAxleAssembly.rearWheel1.wheelToRoadPort= vehicleToRoadPort.wheelToRoadPort1;
```
**OMG Systems Modeling Language (SysML) v2.0, Beta 1 623**


bind rearAxleAssembly.rearWheel2.wheelToRoadPort= vehicleToRoadPort.wheelToRoadPort2;
}

**A.6Actions**
The definition and usage pattern applies not only to parts and part definitions, but to most constructs in SysML. As
shown below, the action _providePower_ is defined by the action definition _ProvidePower_. The action
_providePower_ contains actions to _generateTorque_ , _amplifyTorque_ , _transferTorque_ , and
_distributeTorque_ , each of which have their own definitions. The actions inherit their input and output
parameters from their definition and redefine them as necessary(Note: the inherited parameters are not shown.)

```
providePower: ProvidePower «action»
```
generateTorque: GenerateTorque _«action»_ amplifyTorque: AmplifyTorque _«action»_ transferTorque: TransferTorque _«action»_ distributeTorque: DistributeTorque _«action»_
**Figure 64. Action providePower**
action providePower:ProvidePower{action generateTorque:GenerateTorque;
action amplifyTorque:AmplifyTorque;action transferTorque:TransferTorque;
action distributeTorque:DistributeTorque;...
}
As shown inFig. 60, the part _vehicle_b_ performs the action _providePower_. The subparts of _vehicle_b_ then
perform the appropriate subactions of _providePower_. For example, the part _engine_ performs the action
_providePower.generateTorque_ , which redefinesthe _generateTorque_ action inherited from its definition.
The output of each subactionof _providePower_ is connected by aflow connection to the input of anothersubaction,
except for _distributeTorque_ , whose outputs are bound to the outputs of _providePower_. The input and output
parameters are streaming unless designated as succession flows, meaning that the inputs continue to be consumed
and the outputs continue to be produced as the action executes.

**Figure 65. Action flow for providePower**
action providePower:ProvidePower{...
bind fuelCmd = generateTorque.fuelCmd;flow generateTorque.engineTorque to amplifyTorque.engineTorque;

**624 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


```
flow amplifyTorque.transmissionTorque to transferTorque.transmissionTorque;flow transferTorque.driveshaftTorque to distributeTorque.driveshaftTorque;
```
} bind distributeTorque.wheelToRoadTorque = wheelToRoadTorque;
The _transportPassenger_1_ use case containsasequence of actions fora _Vehicle_ to transport passengers.The
use case is defined by a use case definition called _TransportPassenger_ .Theactions
_passenger1GetInVehicle_ and _driverGetInvehicle_ are performed concurrently after the start of the use case.
After both these actions complete, an accept action is triggered upon receipt of an _IgnitionCmd_. After this, the
actions _driveVehicleToDestination_ and _providePower_ can proceed concurrently. Once these are both
completed, then the actions _passenger1GetOutOfVehicle_ and _driverGetOutOfvehicle_ are preformed
concurrently, after which the _transportPassenger_ use caseis done. The fork and join control nodes and the
successions (i.e., first and then) are used to control the action sequence.

```
transportPassenger_1 «use case»
```
```
ignitionCmd:IgnitionCmd «accept action»
```
```
result
```
```
vehicle
```
```
driverGetInVehicle «action» passenger1GetInVehicle «action»
```
```
driverGetOutOfVehicle «action» passenger1GetOutOfVehicle «action»
```
```
driveVehicleToDestination «action» providePower «action»
```
```
«use case» start
```
```
«use case» ^done
```
```
@
```
**Figure 66. Action flow for transportPassenger**
use case transportPassenger_1:TransportPassenger{//action declarations

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 625**


```
...first start;
then fork fork1;then driverGetInVehicle;
first driverGetInVehicle then join1;then passenger1GetInVehicle;
first passenger1GetInVehicle then join1;first join1 then trigger;
first trigger then fork2;fork fork2;
then driveVehicleToDestination;then providePower;
first driveVehicleToDestination then join2;first providePower then join2;
first join2 then fork3;fork fork3;
then driverGetOutOfVehicle;then passenger1GetOutOfVehicle;
first driverGetOutOfVehicle then join3;first passenger1GetOutOfVehicle then join3;
```
} first join3 then done;

**A.7States**
The states of a _Vehicle_ enable selected actions to be performed. The _Vehicle_ exhibits itsstate _vehicleStates_.
Thisstate is a parallel state, so its substates _operatingStates_ and _healthStates_ are concurrent. The states
_operatingStates_ and _healthStates_ are not parallel, so only one of each of their substates can be active at any
given time.

**626 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


**Figure 67. Vehicle States**
exhibit state vehicleStates parallel {ref controller;

```
state operatingStates {...
}
state healthStates {...
```
} }
Note that the state _vehicleStates_ has a referential feature _controller:VehicleController_. This allows the
substates of _vehicleStates_ tosend a signal to the _controlller_ or one of its ports, or to access any other feature of
_controller_.

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 627**


The _operatingStates_ are further decomposed into _off_ , _starting_ , and _on_ states, with an entry transition to the
_off_ substate. Upon receipt of an _ignitionCmd_ , the _off-starting_ transition fires if the _ignitionCmd_ is in the
_on_ position and the _brakePedalDepressed_ is true. A _StartSignal_ is sent to the _controller_ as part of this
transition, after which _operatingStates_ enters its _starting_ substate. The state _operatingStates_ also
includes transitions from the substates _starting_ to _on_ and _on_ to _off_.
The _ignitionCmd_ is defined by the item definition _IgnitionCmd_ , which contains an attribute defined by an
enumeration with values _on_ and _off_. This pattern is used to represent a variety of signals that may be sent by send
actions and accepted by accept actions.
The _on_ state has an entry action to _performSelfTest_ , which is performed upon entry to the state. When the entry
action completes, the do action to _providePower_ starts, and it continues to be performed until the state is exited.
Prior to exiting the state, the exit action to _applyParkingBrake_ is performed. The state also has a constraint that
the _electricalPower_ must not exceed 500 watts.
state operatingStates {entry action initial;

```
state off;state starting;
state on {entry performSelfTest;
do providePower;exit applyParkingBrake;
} constraint {electricalPower<=500[W]}
transition initial then off;
transition 'off-starting'first off
accept ignitionCmd:IgnitionCmd via ignitionCmdPortif ignitionCmd.ignitionOnOff==IgnitionOnOff::on and brakePedalDepressed
do send StartSignal() to controllerthen starting;
transition 'starting-on'first starting
accept VehicleOnSignalthen on;
transition 'on-off'first on
accept VehicleOffSignaldo send OffSignal() to controller
```
} then off;
The _healthStates_ are decomposed into _normal_ , _maintenance_ and _degraded_ states. Starting in the _normal_
state, _healthStates_ continually monitors the vehicle temperature and, when the temperature exceeds the allowed
maximum, it transitions to the _degraded_ state and notifies the _controller_. It also transitions from _normal_ to
_maintenance_ whenit is time for vehicle maintenance. In either case, it transitions back to the _normal_ state on
receipt of a ReturnToNormal signal.
state healthStates {entry action initial;
do senseTemperature{

**628 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


} out temp;
state normal;state maintenance;
state degraded;
transition initial then normal;
transition 'normal-maintenance'first normal
accept at maintenanceTimethen maintenance;
transition 'normal-degraded'first normal
accept when senseTemperature.temp > Tmaxdo send OverTemp() to controller
then degraded;
transition 'maintenance-normal'first maintenance
accept ReturnToNormalthen normal;
transition 'degraded-normal'first degraded
accept ReturnToNormalthen normal;
}

**A.8Requirements**
The requirement definition _MassRequirement_ has a shall statement that "The actual mass shall be less than the
required mass". This statement is formalized using attributes for _massRequired_ and _massActual_ and the
constraint expression _{massActual<=massRequired}_.

MassRequirement _«requirement def»_
The actual mass shall be less than therequired mass _doc_
massActual:> ISQBase::massmassRequired:> ISQBase::mass _attributes_
**require** {massActual<=massRequired} _constraints_
**Figure 68. Requirement Definition MassRequirement**
requirement def MassRequirement{doc /*The actual mass shall be less than the required mass*/
attribute massRequired:>ISQ::mass;attribute massActual:>ISQ::mass;

} require constraint {massActual<=massRequired}

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 629**


The _vehicleSpecification_ is a requirement that contains other requirements. It has a dependency to
_marketSurvey_ (not shown) that indicates its requirements are dependent on the market survey. The subject of the
_vehicleSpecification_ is _vehicle:Vehicle_ , which enables the requirements contained in the specification to
reference the features of _vehicle_. One of the requirements contained in the specification is the
_vehicleMassRequirement_ , which is defined by _MassRequirement_. The _massRequired_ attributeis redefined
to have a specific value of 2000 kg in the context of this _vehicleSpecification_. The attribute _massActual_ is
redefined to be the sum of the _dryMass_ and _fuelMassActual_ of the _vehicle_ , where the _fuelMassActual_ is
assumed to be a full tank of gas that weighs 60 kg. The _vehicleSpecficiation_ also contains
_vehicleFuelEconomyRequirements_ for both city and highway.
Although not shown, the mass requirement is allocated to the mass of the vehicle using the allocate relationship, and
theengine mass requirement is derived from the vehicle mass requirement using the derivation relationship.

```
vehicleSpecification «requirement»
```
```
«subject» vehicle
dryMass:> ISQBase::mass attributes
```
```
<1> vehicleMassRequirement: MassRequirement «requirement»
The total mass of the vehicle shall be lessthan or equal to the required mass.
Assume total mass includes a full tank ofgas of 60 kg
```
```
doc
```
```
massRequired =2000 [kg] :>>MassRequirement::massRequired
massActual = vehicle.dryMass +fuelMassActual
:>>MassRequirement::massActual fuelMassActual:> ISQBase::mass
fuelMassMax:> ISQBase::mass = 60 [kg]
```
```
attributes
```
```
assume {fuelMassActual==fuelMassMax} constraints
```
```
<2> vehicleFuelEconomyRequirements «requirement»
fuel economy requirements group doc
assumedCargoMass:> ISQBase::mass attributes
subject
```
```
<2_1> cityFuelEconomyRequirement: FuelEconomyRequirement «requirement»
requiredFuelEconomy = 10 [km / L] :>>FuelEconomyRequirement::requiredFuelEconomyreferences
assume {assumedCargoMass<=500 [kg]} constraints
```
```
<2_2> highwayFuelEconomyRequirement: FuelEconomyRequirement «requirement»
requiredFuelEconomy = 12.75 [km / L] :>>FuelEconomyRequirement::requiredFuelEconomyreferences
assume {assumedCargoMass<=500 [kg]} constraints
```
```
*
```
```
*
*
```
```
* *
```
**Figure 69. Requirements Group vehicleSpecification**
item marketSurvey;dependency from vehicleSpecification to marketSurvey;

requirement vehicleSpecification{subject vehicle:Vehicle;
requirement <'1'> vehicleMassRequirement : MassRequirement {doc /* The total mass of a vehicle shall be less than or equal to the required mass.
Assume total mass includes a full tank of gas of 60 kg*/attribute redefines massRequired=2000 [kg];
attribute redefines massActual = vehicle.dryMass + fuelMassActual;attribute fuelMassActual:>ISQ::mass;
attribute fuelMassMax:>ISQ::mass = 60 [kg];assume constraint {fuelMassActual==fuelMassMax}
}allocate vehicleMassRequirement to PartsTree::vehicle_b.mass;
requirement <'2'> vehicleFuelEconomyRequirements {doc /* fuel economy requirements group */
attribute assumedCargoMass:>ISQ::mass;requirement <'2_1'> cityFuelEconomyRequirement : FuelEconomyRequirement {
redefines requiredFuelEconomy= 10 [km / L];assume constraint {assumedCargoMass>=500 [kg]}

**630 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


}requirement <'2_2'> highwayFuelEconomyRequirement : FuelEconomyRequirement {
redefines requiredFuelEconomy= 12.75 [km / L];assume constraint {assumedCargoMass>=500 [kg]}
} }
}requirement engineSpecification{
subject engine1:Engine;requirement <'1'> enegineMassRequirement : MassRequirement {
...}
#derivation connection{end #original ::> vehicleSpecification.vehicleMassRequirement;
} end #derive ::> engineSpecification.engineMassRequirement;
}
In order to evaluate whether _vehicle_b_ satisfies the _vehicleMassRequirement_ , the _massActual_ must be
bound to the _mass_ of _vehicle_b_. This is accomplished by asserting that _vehicle_b_ satisfies the
_vehicleSpecification_ andbinding the _actualMass_ of the requirement to the _mass_ of _vehicle_b_. Asserting
_vehicle_b_ satisfies the requirement is equivalent to imposing the mass constraint contained in the requirement on
_vehicle_b_.
satisfy vehicleSpecification by vehicle_b {requirement vehicleMassRequirement :>> vehicleMassRequirement {
attribute redefines massActual = vehicle_b.mass;attribute redefines fuelMassActual = vehicle_b.fuelTank.fuel.fuelMass;

} }

**A.9Analysis**
The _FuelEconomyAnalyisModel_ package contains an analysis case called _fuelEconomyAnalysis_. The
objective for this analysis case is to estimatethe fuel economy of the vehicle. Its subject is the part _vehicle_b_. The
analysis case accepts a nominal driving scenario as an input, and returns a _calculatedFuelEconomy_ in
_KilometersPerLitre_ as an output.
The analysis includes the following calculations to determine the result:

_- TraveledDistance (scenario)
- AverageTravelTimePerDistance (scenario)
- ComputeBSFC (vehicle_b.engine)
- BestFuelConsumptionPerDistance (vehicle_b.mass, bsfc, tpd_avg, distance)
- IdlingFuelConsumptionPerTime (vehicle_b.engine)
- FuelConsumption (f_a, f_b, tpd_avg)_

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 631**


```
fuelEconomyAnalysis «analysis»
inout scenario: ScenariocalculatedFuelEconomy:>
AttributeDefinitions::distancePerVolume=FuelConsumption(f_a,f_b, tpd_avg)
```
```
parameters
```
```
bsfc= ComputeBSFC(vehicle_b.engine)distance= TraveledDistance(scenario)
f_a=BestFuelConsumptionPerDistance(vehicle_b.mass,
bsfc, tpd_avg, distance)f_b=
IdlingFuelConsumptionPerTime(vehicle_b.engine)tpd_avg=
AverageTravelTimePerDistance(scenario)
```
```
attributes
```
```
= vehicle_b subjects
```
```
fuelEconomyAnalysisObjective «requirement»
estimate the vehicle fuel economy documentations
subjects
```
```
«objective»
*
```
**Figure 70. Analysis Case fuelEconomyAnalysis**
analysis fuelEconomyAnalysis {in attribute scenario: Scenario;

subject = vehicle_b;
objective fuelEconomyAnalysisObjective {doc /* estimate the vehicle fuel economy */
}
attribute distance = TraveledDistance(scenario);attribute tpd_avg = AverageTravelTimePerDistance(scenario);
attribute bsfc = ComputeBSFC(vehicle_b.engine);attribute f_a =
attribute f_b = IdlingFuelConsumptionPerTime(vehicle_b.engine);BestFuelConsumptionPerDistance(vehicle_b.mass, bsfc, tpd_avg, distance);
return attribute calculatedFuelEconomy:>distancePerVolume =FuelConsumption(f_a, f_b, tpd_avg);
}

**A.10Verification**
The simple verification case _massTests_ is a usage of the verification case definition _MassTest_. The verification
objective is to verify the _vehicleMassRequirement_. The subject of the verification case is _vehicle_b_. The
verification case includes actions to _weighVehicle_ and _evaluatePassFail_.
The _massVerificationSystem_ performs the _massTests_. It is composed of an _operator_ and a _scale_. The
_scale_ performs the action to _weighVehicle,_ and the _operator_ performs the action to _evaluatePassFail_. The

**632 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


verification case returns a verdict of _pass_ or _fail_ based on whether the measured mass satisfies the mass
requirement.

**Figure 71. Vehicle Mass Verification Test**
package VerificationCaseDefinitions{verification def MassTest;
verification def AccelerationTest;verification def ReliabilityTest;
}package VerificationCases1{
verification massTests:MassTest {subject = vehicle_b;
objective {verify vehicleSpecification.vehicleMassRequirement{
} redefines massActual=weighVehicle.massMeasured;
}metadata VerificationMethod{
} kind = VerificationMethodKind::test;
action weighVehicle {out massMeasured:>ISQ::mass;
}then action evaluatePassFail {
in massMeasured:>ISQ::mass;out verdict = PassIf(

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 633**


); vehicleSpecification.vehicleMassRequirement(vehicle_b)
}flow from weighVehicle.massMeasured to evaluatePassFail.massMeasured;
} return :>> verdict = evaluatePassFail.verdict;
}package VerificationSystem{
part massVerificationSystem{perform massTests;
part scale{perform massTests.weighVehicle;
}part operator{
} perform massTests.evaluatePassFail;
} }

**A.11View and Viewpoint**
The _SafetyEngineer_ is a stakeholder with a concern for _VehicleSafety_. The _safetyViewpoint_ frames this
concern.The view _vehiclePartsTree_Safety_ is a _PartsTreeView_ that satisfies the _SafetyViewpoint_ , and,
therefore, addresses the _VehicleSafety_ concern.
The view definition _TreeView_ defines views that are renderedas tree diagrams. The view definition
_PartsTreeView_ specializes _TreeView_ with a filter condition that only _PartUsages_ should be included in the
view. The view usage _vehiclePartsTree_Safety_ adds the further condition to only include parts that have the
metadata annotation for _Safety_. This view then exposes all the nested parts of _vehicle_b_ , such that those parts
meeting all the filter criteria are rendered in a tree diagram.

```
ViewpointDefinitions
ViewDefinitions
```
```
VehicleSafetyView
```
```
SafetyViewpoint «viewpoint def» PartsTree
require concerns vs: VehicleSafety
SafetyEngineer «part def»
```
```
VehicleSafety «concern def»
identify system safety features doc
se: SafetyEngineer stakeholders
«view def» TreeView
asTreeDiagram:> Views::asTreeDiagram renderings
```
```
PartsTreeView «view def»
```
```
«import»* vehiclePartsTree_Safety: PartsTreeView «view»
```
```
«import»*
```
```
«import»**
«import»** «expose»**
```
```
«import»**
```
```
«satisfy»
```
**Figure 72. Vehicle Safety View**
package Viewpoints{part def SafetyEngineer;
concern def VehicleSafety {doc /* Vehicle must have necessary safety features. */
stakeholder se:SafetyEngineer;

**634 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


}viewpoint safetyViewpoint{
} frame concern vs:VehicleSafety;
}package ViewDefinitions{
view def TreeView {render asTreeDiagram;
}view def PartsTreeView:>TreeView {
} filter @SysML::PartUsage;
}package VehicleViews{
view vehiclePartsTree_Safety:PartsTreeView{satisfy safetyViewpoint;
filter @Safety;expose vehicle_b::**;

} }

**Figure 73. Rendering of view vehiclePartsTree_Safety**

**A.12Variability**

The part _vehicleFamily_ models a family of _Vehicles_ that allows variations in the subparts _engine_ ,
_transmission_ and _sunroof_. In particular, the part _engine_ has two variants, _engine4Cyl_ and _engine6Cyl_ ,
which constrain _engine.cylinders_ to have multiplicity 4 and 6, respectively. The part _cylinders_ of
_engine6Cyl_ has an attribute _diameter_ that is also a variation point, with two variants for _smallDiameter_ and
_largeDiameter_. There are also two choices for the _transmission_ and a _sunroof_ is optional. The choice of a
selected variant at one variation point can constrain the available choices at another variation point. For this
example, the choices are constrained to bea 4 cylinder engine with amanual transmission or a 6 cylinder engine
with an automatic transmission.
_vehicleFamily«part»_

```
engine«variation»«part» : Engine
```
```
engine4Cyl: Engine4Cyl «variant»«part» engine6Cyl: Engine6Cyl «variant»«part»
cylinder: Cylinder «part»
diameterattributes : LengthValue
```
```
transmissionChoices«variation»«part» : TransmissionChoices sunroof«variation»«part» : Sunroof { (engine==engine::engine4Cyl andtransmissionChoices==TransmissionChoices::transmissionManual)xor selectionConstraint «assert constraint»
(engine==engine::engine6Cyl andtransmissionChoices==TransmissionChoices::transmissionAutomatic)}
```
```
operator expressions driveshaft «part» frontAxleAssembly «part» rearAxleAssembly «part»
```
```
TransmissionChoices«part def»
```
```
transmissionAutomatic: TransmissionAutomatic «variant»«part» transmissionManual: TransmissionManual «variant»«part»
```
```
1
```
```
1 1
6
```
```
1 1
```
```
*
1 1 1
```
```
* *
```
**Figure 74. Variability Model for vehicleFamily**

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 635**


variation part def TransmissionChoices:>Transmission {variant part transmissionAutomatic:TransmissionAutomatic;

} variant part transmissionManual:TransmissionManual;
abstract part vehicleFamily:>vehicle_a{variation part engine:Engine{
variant part engine4Cyl:Engine4Cyl;variant part engine6Cyl:Engine6Cyl{
part cylinder:Cylinder [6]{variation attribute diameter:LengthValue{
variant attribute smallDiameter:LengthValue;variant attribute largeDiagmeter:LengthValue;
} }
} }
variation part transmission:TransmissionChoices;variation part sunroof:Sunroof;
assert constraint selectionConstraint {(engine==engine::engine4Cyl and
(engine==engine::engine6Cyl andtransmission==TransmissionChoices::transmissionManual) xor
} transmission==TransmissionChoices::transmissionAutomatic)
}

**A.13Individuals**
The part definition _Vehicle_ represents a class of individual vehicles with common characteristics. The parts
_vehicle_a_ and _vehicle_b_ are usages of _Vehicle_ with different part decompositions. There can be many
individual vehicles that conform to _vehicle_a_ or _vehicle_b_.
The individual part definition _Vehicle_1_ is a specialization of _Vehicle_ that restricts the part definition to a single
individual. A usage _vehicle_1_ of this definition represents that individual within a specific context. This usage can
also subset _vehicle_b and_ inheritthe parts hierarchy and other features of _vehicle_b_.
Additional individual definitions _FrontAxleAssembly_1_ , _FrontAxle_1_ , _Wheel_1_ , _Wheel_2_ , etc., are similarly
specializations of their respective part definitions. The _vehicle_1.frontAxleAssembly_ is a usage of
_FrontAxleAssembly_1_ , whose _frontAxle_ is a usage of _FrontAxle_1_ , whose _wheels_ are _Wheel_1_ and
_Wheel_2_. In this way, vehicle_1 can decompose intoahierarchy of individual parts.
An individual definition and usagecan be created for any definition and usage element. An individual action for
example, represents a particular performance of an action with individual inputs and outputs.
The part definition _VehicleRoadContext_ defines a context containing _vehicle:Vehicle_ and _road:Road_
subparts. The individual definition _VehicleRoadContext_1_ is a specialization of _VehicleRoadContext_ whose
subparts are constrained to be usages of the individual definitions _Vehicle_1_ and _Road_1_.
As shown below, there is a time sliceof _VehicleRoadContext_1_ from _t0_ to _t2_ called _t0_t2_a_ with three
snapshots _t0_a_ , _t1_a_ and _t2_a_ , at the times _t0_ , _t1_ and _t2_ , respectively. Each context snapshotcontains snapshots
of _Vehicle_1_ and _Road_1_ at the respective times. Each of the vehicle and road snapshots are characterized by
specific values for their attributes. In addition, the vehicle snapshot contains snapshots of its individual parts
consistent with the decomposition of _vehicle_1_.

**636 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


An analysis may be used to compute the values of the attributes for each snapshot. The analysis results reflect the
time history of the individuals, which may be visualized using typical time-based plots and data representations.

**Figure 75. Vehicle Individuals and Snapshots**
individual a:VehicleRoadContext_1{timeslice t0_t2_a{
snapshot t0_a {attribute t0 redefines time=0 [s];
snapshot t0_r:Road_1{:>>incline=0;
} :>>friction=.1;
snapshot t0_v:Vehicle_1{:>>position=0 [m];
:>>velocity=0 [m];:>>acceleration=1.96 [m/s**2];
snapshot t0_fa:FrontAxleAssembly_1{snapshot t0_leftFront:Wheel_1;
} snapshot t0_rightFront:Wheel_2;
} }
snapshot t1_a{attribute t1 redefines time=1 [s];
snapshot t1_r:Road_1{:>>incline=0;
} :>>friction=.1;
snapshot t1_v:Vehicle_1{:>>position=.98 [m];
:>>velocity=1.96 [m/s];

**OMG Systems Modeling Language (SysML) v2.0, Beta 1 637**


:>>acceleration=1.96 [m/s**2];snapshot t1_fa:FrontAxleAssembly_1{
snapshot t1_leftFront:Wheel_1;snapshot t1_rightFront:Wheel_2;
} }
}snapshot t2_a{
attribute t2 redefines time=2 [s];snapshot t2_r:Road_1{
:>>incline =0;:>>friction=.1;
}snapshot t2_v:Vehicle_1{
:>>position=3.92 [m];:>>velocity=3.92 [m/s];
:>>acceleration=1.96 [m/s**2];snapshot t2_fa:FrontAxleAssembly_1{
snapshot t2_leftFront:Wheel_1;snapshot t2_rightFront:Wheel_2;
} }
} }
}

**638 OMG Systems Modeling Language (SysML) v2.0 Beta 1**


